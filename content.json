{"meta":{"title":"Wqyzstql_Blog","subtitle":"以梦为马，不负年华","description":null,"author":"Wqyzstql","url":"http://yoursite.com"},"pages":[{"title":"所有标签分类","date":"2018-10-13T07:30:16.000Z","updated":"2018-11-01T12:16:27.540Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"默认分类 题解 模拟赛心得 学习笔记"},{"title":"友链","date":"2018-10-13T07:30:16.000Z","updated":"2018-10-18T13:38:37.169Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"Menci rqycn_suqingnina Law_Asias Rain Air"}],"posts":[{"title":"My_Code_Style","slug":"My_Code_Style","date":"9999-10-13T07:30:16.000Z","updated":"2018-10-18T13:30:16.593Z","comments":true,"path":"9999/10/13/My_Code_Style/","link":"","permalink":"http://yoursite.com/9999/10/13/My_Code_Style/","excerpt":"介绍下本蒟蒻的丑死的码风$qwq$…(码风大概是魔改了神犇$Menci$的) 在打CF时并不是这个码风 码风概述：","text":"介绍下本蒟蒻的丑死的码风$qwq$…(码风大概是魔改了神犇$Menci$的) 在打CF时并不是这个码风 码风概述： 所有的#include后必须有一个空格,例如#include 无论什么样子的程序，都必须写cstdio cstring algorihtm iostream这四个头文件。 在主程序的int main()中要加void，即为int main(void) 一般不写using namespace std; 所有的变量必须定义在第一个自定义函数之前，且变量和第一个自定义函数，最后一个自定义函数和$main​$之间必须有一个换行 每个函数之后尽可能有$return$， 在一般情况下，在花括号内的内容不加逗号 缩进： 对于每个代码块，使用4空格或者等长的Tab缩进。 括号： 大括号不换行 空格： 个人感觉自己的空格比较的毒瘤。 1.在每个函数声明时，函数名后的括号与函数名之间必须有一个空格,而且括号内如果需要声明变量，则要先有一个空格，且逗号的前后都必须有一个空格。 2.在for循环的声明中，每一个字符（变量名除外），都要用空格隔开。 3.数组内一般不加空格，但是如果有运算符则运算符前后必须有空格。 4.每个可以前后匹配的括号前后必须有空格。 代码大概长这样… 1234567891011121314151617struct wqwqwqwqwq &#123; int qwwq; int qwq;&#125;wwq;void qweqweqweq ( wqwqwqwq x , qwqwqwqwqwq y ) &#123; qweqweqweqweqweqweqweqwe; if ( qweqweqweqweqwe ) &#123; qewqweqweqweqweq; qweqweqweqweq; &#125; else &#123; qweqweqweqweq; qweqweqwrreeqwqqwe; qweqewqweqweqewq; &#125; return;&#125; 变量： 1.基本所有变量都是全局变量，但有些ans,sum最后统计答案时使用的变量可以定义为局部变量。 2.所有的变量名称都必须与要存储的东西的中文意思有沾边，比如树直接定义为tree而不是T。（极度不能容忍变量名直接为a,b,c,d,e,f,g,的情况。 3.定义N,M等时一般只用N,M为名称而不是MAXN,MAXM. 4.定义的结构体类型在定义变量时必须紧接着声明完成结构体后，并且结构体中变量需要定义一个加一个换行。 5.在变量命名时较长的变量名可以用_来连接，并且大小写交替使用，如$Add_Tree_Val$ 把上边所有毒瘤的码风结合起来之后代码大概长这个样子qwq.. 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int N = 1005;const int M = 100005;int n , m , s , t;int l , r;struct Node &#123; int l; int r; int sum;&#125;tree[N &lt;&lt; 2];int main ( void ) &#123; std :: memset ( tree , 0 , sizeof ( tree ) ); scanf ( \"%d%d\" , &amp;n , &amp;m ); printf ( \"%d\\n\" , n + m ); for ( int i = 1 ; i &lt;= n ; i++ ) m += i; if ( n + m &lt;= m + n ) &#123; puts ( \"HA\" ); return 0; &#125; else &#123; puts ( \"AH\" ); return 0; &#125; return 0;&#125;","categories":[{"name":"默认分类","slug":"默认分类","permalink":"http://yoursite.com/categories/默认分类/"}],"tags":[{"name":"CodeStyle","slug":"CodeStyle","permalink":"http://yoursite.com/tags/CodeStyle/"}]},{"title":"qbxt D2T2 Code 题解","slug":"题解","date":"2018-11-04T02:40:29.000Z","updated":"2018-11-04T11:01:58.811Z","comments":true,"path":"2018/11/04/题解/","link":"","permalink":"http://yoursite.com/2018/11/04/题解/","excerpt":"看了一眼之后完全就是一脸懵逼的题….","text":"看了一眼之后完全就是一脸懵逼的题….","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/tags/题解/"}]},{"title":"[题解] Noip2016D1T3 换教室","slug":"换教室题解","date":"2018-11-02T03:10:17.000Z","updated":"2018-11-02T03:35:04.315Z","comments":true,"path":"2018/11/02/换教室题解/","link":"","permalink":"http://yoursite.com/2018/11/02/换教室题解/","excerpt":"一道被天天爱跑步抢尽了风头的最没有排面的$T3…..$","text":"一道被天天爱跑步抢尽了风头的最没有排面的$T3…..$说实话，这道题我刚开始是不会的，然后我看了L_Y_T大爷的$Blog$之后才恍然大悟（$Blog$写的很好，赞一个）先安利完$Blog$再说L_Y_T大爷的Blog 看了$Blog$之后,突然发现，这东西要求的概率知识点我都是会的，只是DP式子想不出来而已$qaq…$(我好菜啊) 因为题目中说，我们最多可以换$m$次，而题目中说的你只能在开始之前选择方案的说法完全没用，毕竟谁会知道你是预测了未来呢（逃 然后，因为有$n$个课程，所以我们设$f[i][j][0/1]$来表示第i个点,第j次换,换不换 然后我们分情况来表示转移：每个教室分为两种情况 1.换2.不换这个是挺平常的然后复杂在换与不换的分情况上了~~~不换:不换是分为这样几种情况:上一个也不换 , 上一个换 且成功,上一个换但失败同理,换也有好多种情况:上一个点不换,这个点失败上一个点不换,这个点成功上一个点换成功,这个点成功上一个点换成功,这个点失败上一个点换失败,这个点成功上一个点换失败,这个点也失败 然后方程好复杂的，是：1234567891011121314151617181920212223242526 上一点不换:f[i-1][j-1][0]这一点换1.失败消耗体力: dis[c[i-1]][c[i]] 分析: 由于上一个点不换,所以上一个点一定是在c[]中的;假定这次失败,那么这次也只能去c[]中的教室;2.成功消耗体力: dis[c[i-1]][d[i]]分析: 由于上一个点不换,所以上一个点一定是在c[]中的;假定这次成功,那么这次能去d[]中的教室;那么,失败的概率是1-k[],成功的概率是k[].综上,这种情况就是:f[i-1][j-1][0]+dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1.0-k[i]) 同理,上一点换,这一点换1.上一点失败,这一点失败(以后省一点哈)消耗体力: dis[c[i-1]][c[i]]概率:都失败这运气也没谁了!!!! 概率:(1.0-k[i-1])*(1.0-k[i])2.失败,成功消耗体力: dis[c[i-1]][d[i]]概率 : (1.0-k[i-1])*k[i]3.成功,失败消耗体力 : dis[d[i-1]][c[i]]概率: k[i-1]*(1.0-k[i])4.成功,成功消耗体力: dis[d[i-1]][d[i]] 概率: k[i-1]*k[i] 然后对于不换的方程：12f[i][j][0] = min(f[i-1][j][0]+dis[c[i-1]][c[i]],f[i-1][j][1]+dis[c[i-1]][c[i]]*(1.0-k[i-1])+dis[d[i-1]][c[i]]*k[i-1]) ; 之前需要Floyd预处理一下，然后就好啦(这道题的确比天天爱跑步简单23333)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 2050;const int M = 350;int n , m , v , e;int c[N] , d[N] ;double G[M][M] , f[N][N][2];double k[N];template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;int main ( void ) &#123; scanf ( \"%d%d%d%d\" , &amp;n , &amp;m , &amp;v , &amp;e ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( \"%d\" , &amp;c[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( \"%d\" , &amp;d[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( \"%lf\" , &amp;k[i] ); for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) f[i][j][0] = f[i][j][1] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= v ; i++ ) G[i][i] = 0 ; for ( int i = 1 ; i &lt;= e ; i++ ) &#123; int x , y; double z; scanf ( \"%d%d%lf\" , &amp;x , &amp;y , &amp;z ); if ( G[x][y] &gt; z ) G[x][y] = G[y][x] = z; &#125; for ( int l = 1 ; l &lt;= v ; l++ ) for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = min ( G[i][j] , G[i][l] + G[l][j] ); f[1][0][0] = f[1][1][1] = 0.0000; for ( int i = 2 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= min ( i , m ) ; j++ ) &#123; f[i][j][0] = min ( f[i - 1][j][0] + G[c[i - 1]][c[i]] , f[i - 1][j][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1] ); if(j &gt;= 1) &#123; f[i][j][1] = min ( f[i - 1][j - 1][0] + G[c[i - 1]][d[i]] * k[i] + G[c[i - 1]][c[i]] * ( 1.0 - k[i] ) , f[i - 1][j - 1][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) * ( 1.0 - k[i] ) + G[c[i - 1]][d[i]] *k[i] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1]* ( 1.0 - k[i] ) + G[d[i - 1]][d[i]] * k[i - 1] * k[i] ); &#125; &#125; double ans = 0x7fffffff; for ( int i = 0 ; i &lt;= m ; i++ ) for ( int j = 0 ; j &lt;= 1 ; j++ ) ans = min ( ans , f[n][i][j] ); printf ( \"%.2lf\\n\" , ans ) ; return 0 ;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/tags/题解/"}]},{"title":"概率入门","slug":"概率入门","date":"2018-11-02T03:04:29.000Z","updated":"2018-11-02T03:07:25.525Z","comments":true,"path":"2018/11/02/概率入门/","link":"","permalink":"http://yoursite.com/2018/11/02/概率入门/","excerpt":"其实这道初赛题是我第一次做的概率题","text":"其实这道初赛题是我第一次做的概率题 我们来看一眼这道毒瘤题： 题面其实已经很清楚了，我们可以发现，当这个青蛙在第$1$块石头时，那么这只青蛙完全可以不用跳，我们设$f(k)$表示这只青蛙在$k$号荷叶上，期望需要$f(k)$次跳到$1$号荷叶，那么我们有： f(1)=0我们接着来考虑当这只青蛙在$2$号荷叶时的情况，它可以跳到$1$号和$2$号荷叶，当它跳到$1$号荷叶时，它完成了任务，跳了一步。当它跳到$2$号时，它还有$f(2)$步，因为每一次跳跃时，跳跃到每一个荷叶上的几率是相等的，所以我们有： f(2)=[1+(1+f(2))]/2同理，我们可以得到： f(3)=[1+(1+f(2))+(1+f(3))]/3推广到一般形式则有: f(k)=[\\sum_{i=1}^k{f(i)+1}]/k我们化简一下，有： f(k)=1+\\frac {1}{k}\\sum_{i=1}^kf(i) 我们看到这个式子：$f(k)=1+\\frac {1}{k}\\sum_{i=1}^kf(i)$ 当$i==k$的时候,我们会发现式子里出现了一个$f(k)$….. 这咋求啊 我们展开这个式子，会发现原来的式子等价于： f(k)=1+\\frac {1}{k}\\sum_{i=1}^{k-1}f(i)+\\frac 1kf(k)这时候如果把$f(k)$看作一个未知数的话，我们可以发现$f(k)$的这一项是可以合并的。但是我们先两边同乘一个$k$，把分母去掉，就会有： k*f(k)=k+\\sum_{i=1}^{k-1}f(i)+f(k)这样答案就很显然了，合并掉等式两边相等的$f(k)$，会得到： (k-1)*f(k)=k+\\sum_{i=1}^{k-1}f(i)最后，两边同除$(k-1)$，有最后答案上的公式： f(k)=\\frac{k}{k-1}(1+\\frac {\\sum_{i=1}^{k-1}f(i)}{k-1})通过这个式子计算可以得到$f(5)=\\frac{37}{12}$,也就是答案 做完了QAQ(写Markdown好累啊qwq…)","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"[POI2015]WIL-Wilcze题解","slug":"POI2015-WIL-Wilcze题解","date":"2018-11-02T02:40:29.000Z","updated":"2018-11-02T02:56:17.167Z","comments":true,"path":"2018/11/02/POI2015-WIL-Wilcze题解/","link":"","permalink":"http://yoursite.com/2018/11/02/POI2015-WIL-Wilcze题解/","excerpt":"其实这本来是$QBXT$的$T2$，但是由于毒瘤$zhw$跑得快（雾），导致我们发现这是某$poi$原题。","text":"其实这本来是$QBXT$的$T2$，但是由于毒瘤$zhw$跑得快（雾），导致我们发现这是某$poi$原题。 首先看题面:题目链接 详细读了一遍之后，其实对于这道题，我的第一反应是贪心（也许是因为我太菜了）。然后打了一遍，小样例过了，然后被大样例$hack$。 之后我又用命分析了一下。可以发现，因为题目中保证每个数的值全部$&gt;=0$，即每个数都是正整数。所以我们与其选长度不到$d$的区间删除，不如直接选择长度为$d$的区间删除。 那么在一段长度已知的序列中，长度为$d$的子序列个数是已知的，那么我们就可以预处理出每一段长度为$d$的子序列。然后我们又发现，题目中要求区间的长度不超过p，那么我们很明显的可以想到尺取法。 然后我们就可以用单调队列来维护我们预处理出的这些长度为$d$的子序列。然后对于区间长度取$max$就是答案了。 最后怒斥一波出原题的出题人$qaq$….(虽然$zhw$很帅) 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;deque&gt;typedef long long ll;using std::deque;const ll N=2000010;ll n,p,d;ll a[N];ll sum[N];ll hea[N];struct Node&#123; ll pos,val; Node(ll pos,ll val):pos(pos),val(val)&#123;&#125; Node()&#123;&#125;&#125;;inline void read(ll &amp;x)&#123; ll s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; x=s*w; return;&#125;deque&lt;Node&gt;q;int main()&#123; read(n);read(p);read(d); for(int i=1;i&lt;=n;i++)read(a[i]),sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n-d;i++) hea[i]=sum[i+d]-sum[i]; for(int i=n-d+1;i&lt;=n;i++) hea[i]=sum[n]-sum[i]; ll ans=0; int l=0; for(int i=d+1;i&lt;=n;i++) &#123; while(!q.empty()&amp;&amp;q.back().val&lt;hea[i-d])q.pop_back(); q.push_back(Node(i-d,hea[i-d])); while(l&lt;i-d&amp;&amp;sum[i]-sum[l]-q.front().val&gt;p) &#123; l++; while(l&gt;q.front().pos)q.pop_front(); &#125; ans=std::max(ans,(ll)i-l); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/tags/题解/"}]},{"title":"复赛冲刺Day1R1-Color题解","slug":"复赛冲刺Day1R1-Colory题解","date":"2018-11-01T11:28:35.000Z","updated":"2018-11-01T12:07:59.841Z","comments":true,"path":"2018/11/01/复赛冲刺Day1R1-Colory题解/","link":"","permalink":"http://yoursite.com/2018/11/01/复赛冲刺Day1R1-Colory题解/","excerpt":"这道题是考试时的$T2$，我感觉这道题出的特别好（虽然当时并不会做","text":"这道题是考试时的$T2$，我感觉这道题出的特别好（虽然当时并不会做 首先看题目:$emmmmm…..$什么鬼啊这个题是$QAQ$ 当时直接一脸懵逼，然后只会写2^n 枚举每一种填充方式，然后再检测的方法…然而这道题这么做只有10分啊$qaq….$ 然后赛后题解告诉我：这题TM是个欧拉回路！！！！当时我就懵逼了….然后当dalao们给我把这道题讲明白了之后，我才发现这道题思路的奇妙。 首先，我们发现，对于一个点，它对应着一个横坐标和一个纵坐标。蒽….一个点对应着两个数值，这个时候我们应该想到什么？二分图？对了，这东西还真的就是要你用二分图的思想来建图….(心态崩了我要妹子$QAQ$) 我们建图，然后我们发现，因为一个点对应着一个横坐标和一个纵坐标，那么我们想到：在二分图中，每一条边也是对应着两种点。那么受到这样的启发，我们就可以建图了：我们把横坐标和纵坐标分别看成一种点，然后将题目中给你的点看成这张图上的边，那么因为题目中要求：黑点和白点的绝对值差不大于1…..，那么我们能想到什么呢？我们要对这些边进行黑白染色，所以我们要一个点出发，一直走一条欧拉回路，这样能走遍所有的边。 但是这样做，我们会发现一个问题：只有$subtask4$的$30$分数据告诉你是偶数。而存在欧拉回路的图的特点是什么呢？每个点的度数都是偶数，那么当点的度数是奇数的时候，我们怎么办呢？ 我在这里选择了度数为奇数的点向一个虚拟节点连边，然后当所有点的度数都是偶数时，这时候没有其他点向这个点连边所以这时候这个虚拟节点对答案没有影响。 然后，我们就直接对边进行染色就可以了。 我只想说，这道题出的真的好，佩服出题人。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt; const int N = 5e5 + 10; struct Data &#123; int v; int p;&#125;data[N];struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int n , m , t = 1 , num;int head[N] , d[N];int x[N] , y[N] , ans[N];bool flag[N]; inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline bool cmp ( Data x , Data y ) &#123; return x.v&lt;y.v;&#125;void lisanhua () &#123; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = x[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; x[data[i].p] = num; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = y[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; y[data[i].p] = num; &#125; return;&#125;void dfs ( int cur , bool last ) &#123; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; if ( flag[i &gt;&gt; 1] ) continue; int j = e[i].to; flag[i &gt;&gt; 1] = 1; d[cur]--; d[j]--; ans[i &gt;&gt; 1] = !last; dfs ( j , !last ); &#125; return;&#125; int main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; x[i] = read (); y[i] = read (); &#125; lisanhua(); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; d[x[i]]++; d[y[i]]++; add ( x[i] , y[i] ); add ( y[i] , x[i] ); &#125; for ( int i = 1 ; i &lt;= num ; i++ ) if ( d[i] &amp; 1 ) &#123; d[i]++; d[num + 1]++; add ( i , num + 1 ); add ( num + 1 , i ); &#125; num++; memset ( ans , -1 , sizeof ( ans ) ); for ( int i = 1 ; i &lt;= num ; i++ ) while ( d[i] ) dfs ( i , 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( \"%d%c\" , ans[i] , i == n ? '\\n' : ' ' ); return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/tags/题解/"}]},{"title":"复赛冲刺Day1R1-Count题解","slug":"qbxtD1T1题解","date":"2018-11-01T03:19:25.000Z","updated":"2018-11-01T12:09:12.244Z","comments":true,"path":"2018/11/01/qbxtD1T1题解/","link":"","permalink":"http://yoursite.com/2018/11/01/qbxtD1T1题解/","excerpt":"其实我感觉这道数论题还是挺简单的（虽然我不会）","text":"其实我感觉这道数论题还是挺简单的（虽然我不会） 这道数论题，我初看的时候是挺一脸懵逼的，然后据$wucstdio$大爷提供的思路，我们可以发现：题意求的是$x$,$y$在$mod P$下的逆元，存在解的条件是$gcd(x,p)==1$，即x,p互质。所以由题解有设 1 到 P − 1 中与 P 互质的数有 s 个，考虑这 s 个数与它们的逆元组成的二元组，这些二元组一定符合条件，那么只要考虑去重的问题 所以我们只需要知道从$1$到$n$中和$n$互质的数的个数这个东西是什么呢？这个东西很明显是$phi$函数。所以我们只需要求出$\\phi(p)$，再加上$x^2\\equiv1\\pmod{p}$的数，最后除$2$就好了。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e7 + 10;int n;int tot , prime[N] , phi[N];bool flag[N];int main ( void ) &#123; scanf ( \"%d\" , &amp;n ); flag[1] = 1; phi[1] = 1; for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; prime[++tot] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] *prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; long long ans = phi[n]; for ( long long i = 1 ; i &lt;= n ; i++ ) if ( i * i % n == 1 ) ans++; printf ( \"%lld\\n\" , ( long long ) ( ans ) / 2 ); return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/tags/题解/"}]},{"title":"A*学习笔记","slug":"A-学习笔记","date":"2018-10-19T03:26:25.000Z","updated":"2018-11-01T03:09:42.226Z","comments":true,"path":"2018/10/19/A-学习笔记/","link":"","permalink":"http://yoursite.com/2018/10/19/A-学习笔记/","excerpt":"例题：$LuoguP2324$:骑士精神 $A*$嘛，很早时候就听说过，貌似是一种很神奇的算法。听长者讲过一遍，一直都想自己打一遍。但是一直没机会。所以来自己写一遍就好啦。","text":"例题：$LuoguP2324$:骑士精神 $A*$嘛，很早时候就听说过，貌似是一种很神奇的算法。听长者讲过一遍，一直都想自己打一遍。但是一直没机会。所以来自己写一遍就好啦。 $A*$的重点就是一个叫做估价函数的东西，但是这个叫估价函数的东西你必须要好好写，不然你会搜出来$WA$的好成绩对于这道题，我就是将现在的棋盘和目标棋盘不同棋子数的差当作估价函数（其实是正确的)。然后，我们就可以加一个类似于剪枝的东西：如果现在的步数$+$估价函数估计的值$&gt;$现在的$max$，直接$return$就好。剩下的东西就是个大爆搜了， 以下是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int goal[7][7] = &#123; &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;, &#123; 0 , 1 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 2 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;&#125;;char mp[6][6];int now[6][6];bool flag;int dx[] = &#123; 0 , 1 , 1 , -1 , -1 , 2 , 2 , -2 , -2 &#125;;int dy[] = &#123; 0 , 2 , -2 , 2 , -2 , 1 , -1 , 1 , -1 &#125;;inline int calcu () &#123; int tmp = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) &#123; if ( now[i][j] != goal[i][j] ) tmp++; &#125; return tmp;&#125;inline void swap ( int &amp;x , int &amp;y ) &#123; int t = x; x = y; y = t; return;&#125;void A_Star ( int x , int y , int dep , int MaxStep ) &#123; if ( flag ) return; if ( dep == MaxStep ) &#123; if ( calcu () == 0 ) &#123; flag = 1; printf ( \"%d\\n\" , MaxStep ); return; &#125; return; &#125; for ( int i = 1 ; i &lt;= 8 ; i++ ) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if ( xx &gt; 5 || xx &lt; 1 || yy &gt; 5 || yy &lt; 1 ) continue; swap ( now[x][y] , now[xx][yy] ); if ( calcu () + dep &lt;= MaxStep ) A_Star ( xx , yy , dep + 1 , MaxStep ); swap ( now[x][y] , now[xx][yy] ); &#125; return;&#125;int main ( void ) &#123; int ttt; scanf ( \"%d\" , &amp;ttt ); while ( ttt-- ) &#123; flag = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) scanf ( \"%s\" , mp[i] + 1 ); int st_x , st_y; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) if ( mp[i][j] == '*' ) &#123; st_x = i; st_y = j; now[i][j] = 2; &#125; else now[i][j] = mp[i][j] - '0'; if ( calcu () == 0 ) &#123; puts ( \"0\" ); return 0; &#125; for ( int i = 1 ; i &lt;= 15 ; i++ ) if ( !flag ) A_Star ( st_x , st_y , 0 , i ); if ( !flag ) puts ( \"-1\" ); &#125; return 0;&#125;","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"wucstdio的毒瘤模拟赛","slug":"wucstdio的毒瘤模拟赛","date":"2018-10-18T09:25:47.000Z","updated":"2018-10-18T11:32:28.247Z","comments":true,"path":"2018/10/18/wucstdio的毒瘤模拟赛/","link":"","permalink":"http://yoursite.com/2018/10/18/wucstdio的毒瘤模拟赛/","excerpt":"$wucstdio$大爷的Flag还是没有倒….","text":"$wucstdio$大爷的Flag还是没有倒…. T1: 反正我刚开始对这道题是完全没有什么信心的qaq（才不会告诉你我直接去看的$T2$） 考虑$50$分的情况：一条链。所以就是一个等差数列了qwq 考虑剩余的正解，我们可以把每一步的期望值当成这棵树的权值，然后因为从上向下和从下向上的期望值可能不太一样，所以我们需要两个函数来表示：（相当于两条边）。 我们设$f(x) g(x)$分别表示从下向上和从上向下的情况，所以我们考虑求出$f(x)$时，我们要考虑以下情况： 直接走到这个节点的父节点，所以这种情况下，对这个节点对答案的贡献就是$\\frac {1}{d[x]}了$ 还有一种情况就是这个节点先跳到他的儿子，再跳回这个节点，再跳过去。这个时候，因为我们需要一步来跳过去，所以这种情况对答案的贡献就是:$\\sum_{j=son} \\frac {1}{d[x]}[1 + f(x) + f(j) ]$ 我们综合考虑一下这两种情况对答案的贡献值，将这两个式子加起来，我们就会得到下边的这个式子： f(x) = \\frac{1}{d} + \\sum_{j=son}\\frac{1}{d}\\times[1 +f(x) + f ( j )]我们安置我们做期望的一贯思路（好像我做过多少期望一样QwQ），因为$num[son]=p-1$，所以我们可以得到这样一个式子： d\\times f(x)=1+d-1+(d-1)f(x)+\\sum_{j}f(j)化简一下之后有： f(x)=d+\\sum_{j}f(j)然后我们来考虑一下$g(x)$这个东西怎么求，当我们经过观察之后，我们可以发现这个式子有三种情况： 他的父亲直接跳到他这里，这种情况对答案的贡献就是$\\frac{1}{d[father]}$ 他的父亲先跳到他的爷爷，然后再跳回来，这种情况下，对答案的贡献就是：$\\frac{1}{d[father]}\\times (1 + g(p) +g(x) )$ 他的父亲跳到他的兄弟然后再跳到他自己。 我们把这三种情况加起来，就会有： g(x)=\\dfrac {1}{d[father]} \\times(1+g(p)+g(x))+\\dfrac {1}{d[father]}+\\sum_{pa_j=pa_x\\&\\&j\\not=x}\\dfrac {1}{d[father]} (1+f(j)+g(x))继续化简有： g(x)=g(p)+f(p)-f(x)通过这种方式，我们就可以把$g(x) f(x)$算出来，相当于边长。 算出边长后，这个问题就转化成了：给你一颗树，求树的直径。我选择了DP求直径，就很简单了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;const int N = 2e5 + 10;int n , m , t;struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int head[N];int now_ans;int f[N] , g[N] , p[N];int LongDis[N][2] , SecondDis[N][2];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline int min ( int x , int y ) &#123; return x &lt; y ? x : y;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;void Find_f ( int root , int fa ) &#123; f[root] = p[root]; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Find_f ( j , root ); f[root] += f[j]; &#125; return;&#125;void Find_g ( int root , int fa ) &#123; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; g[j] = f[root] + g[root] - f[j]; Find_g ( j , root ); &#125; return;&#125;void Work ( int root , int fa ) &#123; int Frist = 0 , Second = 0; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Work ( j , root ); if ( LongDis[j][0] + g[j] &gt; LongDis[root][0] ) &#123; SecondDis[root][0] = LongDis[root][0]; LongDis[root][0] = LongDis[j][0] + g[j]; Frist = j; &#125; else if ( LongDis[j][0] + g[j] &gt; SecondDis[root][0] ) SecondDis[root][0] = LongDis[j][0] + g[j]; if ( LongDis[j][1] + f[j] &gt; LongDis[root][1] ) &#123; SecondDis[root][1] = LongDis[root][1]; LongDis[root][1] = LongDis[j][1] + f[j]; Second = j; &#125; else if ( LongDis[j][1] + f[j] &gt; SecondDis[root][1] ) SecondDis[root][1] = LongDis[j][1] + f[j]; &#125; if ( Frist != Second ) now_ans = max ( LongDis[root][0] + LongDis[root][1] , now_ans ); else if ( Frist == Second ) now_ans = max ( now_ans , max ( SecondDis[root][1] + LongDis[root][0] , SecondDis[root][0] + LongDis[root][1] ) ); return;&#125;int main ( void ) &#123; freopen ( \"tree.in\" , \"r\" , stdin ); freopen ( \"tree.out\" , \"w\" , stdout ); n = read (); for ( int i = 1 ; i &lt; n ; i++ ) &#123; int x = read () , y = read (); add ( x , y ); add ( y , x ); p[x]++; p[y]++; &#125; Find_f ( 1 , 0 ); Find_g ( 1 , 0 ); Work ( 1 , 0 ); printf ( \"%d.00000\\n\" , now_ans ); return 0;&#125; T2:其实暴力还是挺显然的","categories":[],"tags":[{"name":"模拟赛心得","slug":"模拟赛心得","permalink":"http://yoursite.com/tags/模拟赛心得/"}]},{"title":"前排打出题人的一套题","slug":"前排打出题人的一套题","date":"2018-10-17T12:38:43.000Z","updated":"2018-11-01T23:06:11.043Z","comments":true,"path":"2018/10/17/前排打出题人的一套题/","link":"","permalink":"http://yoursite.com/2018/10/17/前排打出题人的一套题/","excerpt":"不管怎么样，先打死出题人再说qaq…","text":"不管怎么样，先打死出题人再说qaq… T1:人贩子$LLFZ$ 题意很显然就是最优贸易啊…. 一眼看出来是缩点+DP….但是为什么我之前是SPFA过的啊QAQ…写SPFA比较稳….然后….就写了…. 上代码吧…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int N = 1e5 + 10;const int M = 1e6 + 10;const int INF = 2147483647;#define G(i,a,b,c) for ( int i = b[a] ; i ; i = c[i].next )int n , m , t , cnt;struct Edge &#123; int to; int data; int next;&#125;e[M] , e_[M];int head[N] , head_[N];int maxs[N] , mins[N];int dis[N] , value[N];bool inque[N];std :: queue &lt; int &gt; qu;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void add_ ( int x , int y , int z ) &#123; e_[++cnt].to = y; e_[cnt].data = z; e_[cnt].next = head_[x]; head_[x] = cnt; return;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;void Heap_Dijkstra () &#123; std :: memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[1] = 1 , dis[1] = value[1]; qu.push ( 1 ); while ( !qu.empty () ) &#123; int j = qu.front (); inque[j] = 0; qu.pop (); G ( i , j , head , e ) &#123; int k = e[i].to; if ( dis[k] &gt; min ( dis[j] , e[i].data ) ) &#123; dis[k] = min ( dis[j] , e[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) mins[i] = dis[i]; std :: memset ( dis , -0x3f3f3f3f , sizeof ( dis ) ); inque[n] = 1 , dis[n] = value[n]; qu.push ( n ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; G ( i , j , head_ , e_ ) &#123; int k = e_[i].to; if ( dis[k] &lt; max ( dis[j] , e_[i].data ) ) &#123; dis[k] = max ( dis[j] , e_[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) maxs[i] = dis[i]; return;&#125; int main ( void ) &#123; freopen ( \"child.in\" , \"r\" , stdin ); freopen ( \"child.out\" , \"w\" , stdout ); n = read (); m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) value[i] = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); if ( z == 1 ) &#123; add ( x , y , value[y] ); add_ ( y , x , value[x] ); &#125; else if ( z == 2 ) &#123; add ( x , y , value[y] ); add ( y , x , value[x] ); add_ ( y , x , value[x] ); add_ ( x , y , value[y] ); &#125; &#125; Heap_Dijkstra (); int ans = -INF; for ( int i = 1 ; i &lt;= n ; i++ ) ans = max ( ans , maxs[i] - mins[i] ); printf ( \"%d\\n\" , ans ); return 0;&#125; T2 : food 再来拿出题人祭天祭一波… 话说我直接读题读错了然后写了个错误的DP然后还A了是什么鬼啊…. 话说我考虑了前缀和，那么我还过了，说明直接加起来然后除就可以? 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int N = 15;int n , ans = -1;int A , B , C;int p1 , p2 , p3;int MaxTime[N];int f[N][105][105][105];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;int main ( void ) &#123; freopen ( \"food.in\" , \"r\" , stdin ); freopen ( \"food.out\" , \"w\" , stdout ); A = read () , B = read () , C = read (); p1 = read () , p2 = read () , p3 = read (); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; MaxTime[i] = read (); MaxTime[i] = MaxTime[i - 1] + MaxTime[i]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = A ; j * p1 &lt;= MaxTime[i] &amp;&amp; j&lt;=100 ; j++ ) for ( int k = B; j * p1 + k * p2 &lt;= MaxTime[i] &amp;&amp; k &lt;= 100 ; k++ ) for ( int l = C ; j * p1 + k * p2 + l * p3 &lt;= MaxTime[i] &amp;&amp; l &lt;=100 ; l++ ) &#123; f[i][j][k][l] = max ( f[i][j][k][l] , max ( f[i - 1][j - A][k - B][l - C] + 1 , f[i][j - A][k - B][l - C] + 1 ) ); ans = max ( ans , f[i][j][k][l] ); &#125; printf ( \"%d\\n\" , ans ); return 0;&#125; T3: Happy 再吐槽一波为什么Noip模拟赛会考离散对数（然而我并不会….） 其实应该是一道签到题吧。。。 暴力水过…. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int P , A , B;bool app[50005];int main ( void ) &#123; freopen ( \"happy.in\" , \"r\" , stdin ); freopen ( \"happy.out\" , \"w\" , stdout ); int T = read (); while ( T-- ) &#123; int now = 1; memset ( app , false , sizeof ( app ) ); P = read () , A = read () , B = read (); for ( int i = 1 ; ; i++ ) &#123; now = ( now * A ) % P; if ( now == B ) &#123; printf ( \"%d\\n\" , i ); break; &#125; if ( app[now] ) &#123; puts ( \"Couldn't Produce!\" ); break; &#125; app[now] = 1; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"模拟赛心得","slug":"模拟赛心得","permalink":"http://yoursite.com/tags/模拟赛心得/"}]}]}