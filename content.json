{"meta":{"title":"Wqyzstql_Blog","subtitle":"以梦为马，不负年华","description":null,"author":"Wqyzstql","url":"http://yoursite.com"},"pages":[{"title":"所有标签分类","date":"2018-10-13T07:30:16.000Z","updated":"2018-10-18T02:30:28.653Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"默认分类"},{"title":"友链","date":"2018-10-13T07:30:16.000Z","updated":"2018-10-18T13:38:37.169Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"Menci rqycn_suqingnina Law_Asias Rain Air"}],"posts":[{"title":"My_Code_Style","slug":"My_Code_Style","date":"9999-10-13T07:30:16.000Z","updated":"2018-10-18T13:30:16.593Z","comments":true,"path":"9999/10/13/My_Code_Style/","link":"","permalink":"http://yoursite.com/9999/10/13/My_Code_Style/","excerpt":"介绍下本蒟蒻的丑死的码风$qwq$…(码风大概是魔改了神犇$Menci$的) 在打CF时并不是这个码风 码风概述：","text":"介绍下本蒟蒻的丑死的码风$qwq$…(码风大概是魔改了神犇$Menci$的) 在打CF时并不是这个码风 码风概述： 所有的#include后必须有一个空格,例如#include 无论什么样子的程序，都必须写cstdio cstring algorihtm iostream这四个头文件。 在主程序的int main()中要加void，即为int main(void) 一般不写using namespace std; 所有的变量必须定义在第一个自定义函数之前，且变量和第一个自定义函数，最后一个自定义函数和$main​$之间必须有一个换行 每个函数之后尽可能有$return$， 在一般情况下，在花括号内的内容不加逗号 缩进： 对于每个代码块，使用4空格或者等长的Tab缩进。 括号： 大括号不换行 空格： 个人感觉自己的空格比较的毒瘤。 1.在每个函数声明时，函数名后的括号与函数名之间必须有一个空格,而且括号内如果需要声明变量，则要先有一个空格，且逗号的前后都必须有一个空格。 2.在for循环的声明中，每一个字符（变量名除外），都要用空格隔开。 3.数组内一般不加空格，但是如果有运算符则运算符前后必须有空格。 4.每个可以前后匹配的括号前后必须有空格。 代码大概长这样… 1234567891011121314151617struct wqwqwqwqwq &#123; int qwwq; int qwq;&#125;wwq;void qweqweqweq ( wqwqwqwq x , qwqwqwqwqwq y ) &#123; qweqweqweqweqweqweqweqwe; if ( qweqweqweqweqwe ) &#123; qewqweqweqweqweq; qweqweqweqweq; &#125; else &#123; qweqweqweqweq; qweqweqwrreeqwqqwe; qweqewqweqweqewq; &#125; return;&#125; 变量： 1.基本所有变量都是全局变量，但有些ans,sum最后统计答案时使用的变量可以定义为局部变量。 2.所有的变量名称都必须与要存储的东西的中文意思有沾边，比如树直接定义为tree而不是T。（极度不能容忍变量名直接为a,b,c,d,e,f,g,的情况。 3.定义N,M等时一般只用N,M为名称而不是MAXN,MAXM. 4.定义的结构体类型在定义变量时必须紧接着声明完成结构体后，并且结构体中变量需要定义一个加一个换行。 5.在变量命名时较长的变量名可以用_来连接，并且大小写交替使用，如$Add_Tree_Val$ 把上边所有毒瘤的码风结合起来之后代码大概长这个样子qwq.. 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int N = 1005;const int M = 100005;int n , m , s , t;int l , r;struct Node &#123; int l; int r; int sum;&#125;tree[N &lt;&lt; 2];int main ( void ) &#123; std :: memset ( tree , 0 , sizeof ( tree ) ); scanf ( \"%d%d\" , &amp;n , &amp;m ); printf ( \"%d\\n\" , n + m ); for ( int i = 1 ; i &lt;= n ; i++ ) m += i; if ( n + m &lt;= m + n ) &#123; puts ( \"HA\" ); return 0; &#125; else &#123; puts ( \"AH\" ); return 0; &#125; return 0;&#125;","categories":[{"name":"默认分类","slug":"默认分类","permalink":"http://yoursite.com/categories/默认分类/"}],"tags":[{"name":"CodeStyle","slug":"CodeStyle","permalink":"http://yoursite.com/tags/CodeStyle/"}]},{"title":"A*学习笔记","slug":"A-学习笔记","date":"2018-10-19T03:26:25.000Z","updated":"2018-10-19T03:29:54.698Z","comments":true,"path":"2018/10/19/A-学习笔记/","link":"","permalink":"http://yoursite.com/2018/10/19/A-学习笔记/","excerpt":"","text":"例题：$LuoguP2324$:骑士精神 A*嘛，很早时候就听说过，貌似是一种很神奇的算法。听长者讲过一遍，一直都想自己打一遍。但是一直没机会。所以来自己写一遍就好啦。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"wucstdio的毒瘤模拟赛","slug":"wucstdio的毒瘤模拟赛","date":"2018-10-18T09:25:47.000Z","updated":"2018-10-18T11:32:28.247Z","comments":true,"path":"2018/10/18/wucstdio的毒瘤模拟赛/","link":"","permalink":"http://yoursite.com/2018/10/18/wucstdio的毒瘤模拟赛/","excerpt":"$wucstdio$大爷的Flag还是没有倒….","text":"$wucstdio$大爷的Flag还是没有倒…. T1: 反正我刚开始对这道题是完全没有什么信心的qaq（才不会告诉你我直接去看的$T2$） 考虑$50$分的情况：一条链。所以就是一个等差数列了qwq 考虑剩余的正解，我们可以把每一步的期望值当成这棵树的权值，然后因为从上向下和从下向上的期望值可能不太一样，所以我们需要两个函数来表示：（相当于两条边）。 我们设$f(x) g(x)$分别表示从下向上和从上向下的情况，所以我们考虑求出$f(x)$时，我们要考虑以下情况： 直接走到这个节点的父节点，所以这种情况下，对这个节点对答案的贡献就是$\\frac {1}{d[x]}了$ 还有一种情况就是这个节点先跳到他的儿子，再跳回这个节点，再跳过去。这个时候，因为我们需要一步来跳过去，所以这种情况对答案的贡献就是:$\\sum_{j=son} \\frac {1}{d[x]}[1 + f(x) + f(j) ]$ 我们综合考虑一下这两种情况对答案的贡献值，将这两个式子加起来，我们就会得到下边的这个式子： f(x) = \\frac{1}{d} + \\sum_{j=son}\\frac{1}{d}\\times[1 +f(x) + f ( j )]我们安置我们做期望的一贯思路（好像我做过多少期望一样QwQ），因为$num[son]=p-1$，所以我们可以得到这样一个式子： d\\times f(x)=1+d-1+(d-1)f(x)+\\sum_{j}f(j)化简一下之后有： f(x)=d+\\sum_{j}f(j)然后我们来考虑一下$g(x)$这个东西怎么求，当我们经过观察之后，我们可以发现这个式子有三种情况： 他的父亲直接跳到他这里，这种情况对答案的贡献就是$\\frac{1}{d[father]}$ 他的父亲先跳到他的爷爷，然后再跳回来，这种情况下，对答案的贡献就是：$\\frac{1}{d[father]}\\times (1 + g(p) +g(x) )$ 他的父亲跳到他的兄弟然后再跳到他自己。 我们把这三种情况加起来，就会有： g(x)=\\dfrac {1}{d[father]} \\times(1+g(p)+g(x))+\\dfrac {1}{d[father]}+\\sum_{pa_j=pa_x\\&\\&j\\not=x}\\dfrac {1}{d[father]} (1+f(j)+g(x))继续化简有： g(x)=g(p)+f(p)-f(x)通过这种方式，我们就可以把$g(x) f(x)$算出来，相当于边长。 算出边长后，这个问题就转化成了：给你一颗树，求树的直径。我选择了DP求直径，就很简单了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;const int N = 2e5 + 10;int n , m , t;struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int head[N];int now_ans;int f[N] , g[N] , p[N];int LongDis[N][2] , SecondDis[N][2];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline int min ( int x , int y ) &#123; return x &lt; y ? x : y;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;void Find_f ( int root , int fa ) &#123; f[root] = p[root]; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Find_f ( j , root ); f[root] += f[j]; &#125; return;&#125;void Find_g ( int root , int fa ) &#123; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; g[j] = f[root] + g[root] - f[j]; Find_g ( j , root ); &#125; return;&#125;void Work ( int root , int fa ) &#123; int Frist = 0 , Second = 0; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Work ( j , root ); if ( LongDis[j][0] + g[j] &gt; LongDis[root][0] ) &#123; SecondDis[root][0] = LongDis[root][0]; LongDis[root][0] = LongDis[j][0] + g[j]; Frist = j; &#125; else if ( LongDis[j][0] + g[j] &gt; SecondDis[root][0] ) SecondDis[root][0] = LongDis[j][0] + g[j]; if ( LongDis[j][1] + f[j] &gt; LongDis[root][1] ) &#123; SecondDis[root][1] = LongDis[root][1]; LongDis[root][1] = LongDis[j][1] + f[j]; Second = j; &#125; else if ( LongDis[j][1] + f[j] &gt; SecondDis[root][1] ) SecondDis[root][1] = LongDis[j][1] + f[j]; &#125; if ( Frist != Second ) now_ans = max ( LongDis[root][0] + LongDis[root][1] , now_ans ); else if ( Frist == Second ) now_ans = max ( now_ans , max ( SecondDis[root][1] + LongDis[root][0] , SecondDis[root][0] + LongDis[root][1] ) ); return;&#125;int main ( void ) &#123; freopen ( \"tree.in\" , \"r\" , stdin ); freopen ( \"tree.out\" , \"w\" , stdout ); n = read (); for ( int i = 1 ; i &lt; n ; i++ ) &#123; int x = read () , y = read (); add ( x , y ); add ( y , x ); p[x]++; p[y]++; &#125; Find_f ( 1 , 0 ); Find_g ( 1 , 0 ); Work ( 1 , 0 ); printf ( \"%d.00000\\n\" , now_ans ); return 0;&#125; T2:其实暴力还是挺显然的","categories":[],"tags":[{"name":"模拟赛心得","slug":"模拟赛心得","permalink":"http://yoursite.com/tags/模拟赛心得/"}]},{"title":"'前排打出题人的一套题'","slug":"前排打出题人的一套题","date":"2018-10-17T12:38:43.000Z","updated":"2018-10-17T12:46:26.907Z","comments":true,"path":"2018/10/17/前排打出题人的一套题/","link":"","permalink":"http://yoursite.com/2018/10/17/前排打出题人的一套题/","excerpt":"不管怎么样，先打死出题人再说qaq…","text":"不管怎么样，先打死出题人再说qaq… T1:人贩子$LLFZ$ 题意很显然就是最优贸易啊…. 一眼看出来是缩点+DP….但是为什么我之前是SPFA过的啊QAQ…写SPFA比较稳….然后….就写了…. 上代码吧…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int N = 1e5 + 10;const int M = 1e6 + 10;const int INF = 2147483647;#define G(i,a,b,c) for ( int i = b[a] ; i ; i = c[i].next )int n , m , t , cnt;struct Edge &#123; int to; int data; int next;&#125;e[M] , e_[M];int head[N] , head_[N];int maxs[N] , mins[N];int dis[N] , value[N];bool inque[N];std :: queue &lt; int &gt; qu;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void add_ ( int x , int y , int z ) &#123; e_[++cnt].to = y; e_[cnt].data = z; e_[cnt].next = head_[x]; head_[x] = cnt; return;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;void Heap_Dijkstra () &#123; std :: memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[1] = 1 , dis[1] = value[1]; qu.push ( 1 ); while ( !qu.empty () ) &#123; int j = qu.front (); inque[j] = 0; qu.pop (); G ( i , j , head , e ) &#123; int k = e[i].to; if ( dis[k] &gt; min ( dis[j] , e[i].data ) ) &#123; dis[k] = min ( dis[j] , e[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) mins[i] = dis[i]; std :: memset ( dis , -0x3f3f3f3f , sizeof ( dis ) ); inque[n] = 1 , dis[n] = value[n]; qu.push ( n ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; G ( i , j , head_ , e_ ) &#123; int k = e_[i].to; if ( dis[k] &lt; max ( dis[j] , e_[i].data ) ) &#123; dis[k] = max ( dis[j] , e_[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) maxs[i] = dis[i]; return;&#125; int main ( void ) &#123; freopen ( \"child.in\" , \"r\" , stdin ); freopen ( \"child.out\" , \"w\" , stdout ); n = read (); m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) value[i] = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); if ( z == 1 ) &#123; add ( x , y , value[y] ); add_ ( y , x , value[x] ); &#125; else if ( z == 2 ) &#123; add ( x , y , value[y] ); add ( y , x , value[x] ); add_ ( y , x , value[x] ); add_ ( x , y , value[y] ); &#125; &#125; Heap_Dijkstra (); int ans = -INF; for ( int i = 1 ; i &lt;= n ; i++ ) ans = max ( ans , maxs[i] - mins[i] ); printf ( \"%d\\n\" , ans ); return 0;&#125; T2 : food 再来拿出题人祭天祭一波… 话说我直接读题读错了然后写了个错误的DP然后还A了是什么鬼啊…. 话说我考虑了前缀和，那么我还过了，说明直接加起来然后除就可以? 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int N = 15;int n , ans = -1;int A , B , C;int p1 , p2 , p3;int MaxTime[N];int f[N][105][105][105];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;int main ( void ) &#123; freopen ( \"food.in\" , \"r\" , stdin ); freopen ( \"food.out\" , \"w\" , stdout ); A = read () , B = read () , C = read (); p1 = read () , p2 = read () , p3 = read (); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; MaxTime[i] = read (); MaxTime[i] = MaxTime[i - 1] + MaxTime[i]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = A ; j * p1 &lt;= MaxTime[i] &amp;&amp; j&lt;=100 ; j++ ) for ( int k = B; j * p1 + k * p2 &lt;= MaxTime[i] &amp;&amp; k &lt;= 100 ; k++ ) for ( int l = C ; j * p1 + k * p2 + l * p3 &lt;= MaxTime[i] &amp;&amp; l &lt;=100 ; l++ ) &#123; f[i][j][k][l] = max ( f[i][j][k][l] , max ( f[i - 1][j - A][k - B][l - C] + 1 , f[i][j - A][k - B][l - C] + 1 ) ); ans = max ( ans , f[i][j][k][l] ); &#125; printf ( \"%d\\n\" , ans ); return 0;&#125; T3: Happy 再吐槽一波为什么Noip模拟赛会考离散对数（然而我并不会….） 其实应该是一道签到题吧。。。 暴力水过…. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int P , A , B;bool app[50005];int main ( void ) &#123; freopen ( \"happy.in\" , \"r\" , stdin ); freopen ( \"happy.out\" , \"w\" , stdout ); int T = read (); while ( T-- ) &#123; int now = 1; memset ( app , false , sizeof ( app ) ); P = read () , A = read () , B = read (); for ( int i = 1 ; ; i++ ) &#123; now = ( now * A ) % P; if ( now == B ) &#123; printf ( \"%d\\n\" , i ); break; &#125; if ( app[now] ) &#123; puts ( \"Couldn't Produce!\" ); break; &#125; app[now] = 1; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"模拟赛心得","slug":"模拟赛心得","permalink":"http://yoursite.com/tags/模拟赛心得/"}]}]}