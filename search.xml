<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Noip2018游记]]></title>
    <url>%2F2018%2F11%2F17%2FNoip2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[真没想到我能活着苟到写游记的一天$qwq$ Day-1最近几天有点累，早上就不去学校了（然而事实证明这是很正确的抉择）。早上一觉睡到了$8:20$，早上起来想起来$wucstdio$大佬说过立过的$flag$不拔在$Noip$会掉$rp$然后早睡起来就开始肝猪国杀，一直到$10:40$左右重构完了（历时$3$天终于写完了）下午回到学校，发现早上是信心鼓励赛幸好没去23333然后下午+晚上一直在写模板题。（顺便凑出来了$AC520$） Day 0早上教练居然给我们请假不用早来了哎$qwq….$上午开始走，一开始的时候还想在车上背个板子什么的然后SCP真好看又颓了会知乎然后就发现到了$cyyz$了 住宿安排完成了之后居然才$2:30$多一点，然后在宿舍里不知道该干啥。不过感觉$cyyz$的移动信号貌似比$SDSC$的时候快了一点（大雾）然后$wucstdio$给我打电话说楼下有很多大佬，自己迅速下楼去膜神仙。 终于见到了$rqy$姐姐本人了好兴奋$qwq$，不过$rqy$姐姐好像比自己想的稍微内敛了一点。 但是这并改变不了rqy姐姐是人赢的性质据说看见神仙可以rp++,（但是rp貌似被rqy姐姐吸走了QAQ) 晚上全宿舍都在打板子，但是试机的时候$wyxdrqc$和$zyp$大佬还有很多人（包括我）试机的时候线段树都打错了（大雾）。给自己喜欢的人打了个电话，加油qaq… Day 1早上起来，自己冷静了一下，打开题目一看$T1$，哎我为什么$T1$只会$70$分啊….，然后自己又推了1h还是没有推出来，心态当场爆炸qwq…T2当成数论推了半天，然后自己冷静的写了一个乱搞做法，也不知道能得多少分。T3完全不会，打一个直径分滚粗了。 出考场：啊你们怎么都做过原题吗？啊T2是个裸背包吗？啊T3你们都会写70分吗？心态崩了我要妹子QWQ….. 下午心态一直RE中，在宿舍里颓了一下午。不管怎么说第二天都想翻盘。 Day 2第二天睡了一觉，发现心情稍微好了一点。到了考场之后，看到第一题$m=n$我就感觉药丸…. 为什么$Noip$的$T1$要考基环树啊….. 写了个$60$分的树上贪心，然后开始想环上怎么做。然而我很$zz$的没有看数据范围可以$n^2$过，一直在写$O(n)$的做法。然后我就写挂了，自己补了只有环的做法，$72分滚了$。 T2看的时候：啊？读题读了$10mins$确定我不会，然后就决定打表了。 T3：……为什么$Noip$要考$ddp$啊。。。。 出了考场发现大家都说D2不会做当时甚至有些开心。 然后晚上就回去上晚自习了。 一年半的OI一场空，$D1TI$见祖宗说我是再适合不过的了。本来还以为自己能去$PKUWC$,好吧，我还是太$naive$了，感觉自己要与省一擦肩而过….剩下一年自己就养生好了，再来一年起码要拿一个$1=$啊$qwq…..$ 回家之后心态一直RE,,,,不过幸好$wucstdio$大佬能和我谈了谈人生….瞬间感觉$wucstdio$成了我的人生导师qaq…. 以后的路自己就要自己决定了，不过自己决定那些比赛也是要一起参加的qaq… 那些能进入省选的$OIer$们要加油鸭$qaq…$我会一直陪着你们的$@wyxdrqc @wucstdio @lingyuqing$ 你们的$wqyzstql$也要和你们一起努力了。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考前模板整理]]></title>
    <url>%2F2018%2F11%2F07%2F%E8%80%83%E5%89%8D%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[$Noip$之前在这里整理一波模板….集成了一下所有的$TG$和$PJ$应该会考的模板 PS:所有模板纯属现场手搓，不保证正确性（比如手抖打错字母什么的），如果找到错误请及时告知我qwq 快速排序最基本的板子了吧,$C++$选手表示开心$qaq$。1234567891011121314151617#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5 + 10int n;int num[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;num[i] ); sort ( num + 1 , num + 1 + n ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , num[i] , i == n ? '\n' : ' ' ); return 0;&#125; 并查集12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5 + 10;int n , m;int find ( int x ) &#123; if ( x != father[x] ) father[x] = find ( father[x] ); return father[x];&#125;int main ( void ) &#123; scanf ( "%d%d" , &amp;n , &amp;m ); for ( int i = 1 ; i &lt;= n ; i++ ) father[i] = i; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x , y , z; scanf ( "%d%d%d" , &amp;z , &amp;x , &amp;y ); if ( z == 1 ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; &#125; else if ( z == 2 ) &#123; x = find ( x ) , y = find ( y ); if ( x == y ) puts ( "Y" ); else puts ( "N" ); &#125; &#125; return 0;&#125; 快速幂个人感觉这个还是个挺重要的板子了吧…..12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int Fast_Power ( int x , int y ) &#123; int sum = 1; while ( y ) &#123; if ( y &amp; 1 ) sum = sum * x; x = x * x; y &gt;&gt;= 1; &#125; return sum;&#125;int main ( void ) &#123; int n , m; scanf ( "%d%d" , &amp;n , &amp;m ); printf ( "%d\n" , Fast_Power ( n , m ) ); return 0;&#125; 线性筛素数这个其实只是筛素数的话是挺简单的，但是我决定连$\phi$一起筛出来（如果用不到的话就把$phi$数组自动忽略掉就好了）12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 5e5 + 10;int n , cnt;int prime[N] , phi[N];bool flag[N];int main ( void ) &#123; flag[1] = 1; phi[1] = 1; scanf ( "%d" , &amp;n ); for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; flag[i] = 1; prime[++cnt] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; for ( int i = 1 ; i &lt;= cnt ; i++ ) printf ( "%d " , prime[i] ); puts ( "" ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d " , phi[i] ); return 0;&#125; 【模板】堆又是一个$C++$党的福利$qwq$,直接用$priority_queue$模拟就好啦123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using std :: priority_queue;int n;priority_queue &lt; int , std :: vector &lt; int &gt; , std :: greater &lt; int &gt; &gt; qu;int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int opts; scanf ( "%d" , &amp;opts ); if ( opts == 1 ) &#123; int x; scanf ( "%d" , &amp;x ); qu.push ( x ); &#125; else if ( opts == 2 ) printf ( "%d\n" , qu.top () ); else if ( opts == 3 ) qu.pop (); &#125; return 0;&#125; 字符串蛤希其实我个人比较倾向于写自然溢出或者直接随机一个质数$qwq$12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;typedef unsigned long long ull;const ull base = 233;const int N = 1e4;const int M = 1e3;int n;char s[N][M];ull has[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%s" , s[i] + 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int len = strlen ( s[i] + 1 ); for ( int j = 1 ; j &lt;= len ; j++ ) has[i] = has[i] * base + s[i][j]; &#125; std :: sort ( has + 1 , has + 1 + n ); int ans = 0; for ( int i = 1 ; i &lt;= n ; i++ ) if ( has[i] != has[i + 1] ) ans++; printf ( "%d\n" , ans ); return 0;&#125; 最小生成树不会写$prim$的蒟蒻瑟瑟发抖….123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e4 + 10;const int M = 2e5 + 10;int n , m;struct Edge &#123; int from; int to; int data;&#125;e[M];int father[N];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline bool cmp ( Edge x , Edge y ) &#123; return x.data &lt; y.data;&#125;int find ( int x ) &#123; if ( x != father[x] ) father[x] = find ( father[x] ); return father[x];&#125;void Union ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; return;&#125;inline bool Judge ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); return ( x == y ) ? true : false;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) father[i] = i; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); e[i].from = x; e[i].to = y; e[i].data = z; &#125; std :: sort ( e + 1 , e + 1 + m , cmp ); int NowEdge = 0 , NowVal = 0; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int l = e[i].from , r = e[i].to; if ( Judge ( l ,r ) ) continue; Union ( l , r ); NowEdge++; NowVal += e[i].data; if ( NowEdge == n - 1 ) break; &#125; if ( NowEdge == n - 1 ) printf ( "%d\n" , NowVal ); else puts ( "orz" ); return 0;&#125; 单源最短路 （有负权边）这张图有负权边，所以只能写某已经死掉的$SPFA$了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N = 1e4 + 10;const int M = 1e5 + 10;using std :: queue;int n , m , t;struct Edge &#123; int to; int data; int next;&#125;e[M];int head[N] , dis[N];bool inque[N];inline int read () &#123; int s = 0; bool flag = 0; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '0' ) flag = 1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return ( flag ) ? -s : s;&#125;void Spfa ( int x ) &#123; memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[x] = 1;dis[x] = 0; qu.push ( x ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].data ) &#123; dis[k] = dis[j] + e[i].data; if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; return;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); add ( x , y , z ); &#125; Spfa ( 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , dis[i] == 0x3f3f3f3f ? 2147483647 : dis[i] , i == n ? '\n' : ' ' ); return 0;&#125; 单源最短路 （无负权边）在题目明确说没有负权边的情况下，跑堆优化的$Dijkstra$一定是最稳的其实代码长得都差不多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define F(i,a,b) for ( int i = a ; i &lt;= b ; i++ )#define MP std::make_pair#define se second#define fi firsttypedef std::pair &lt; int , int &gt; pll;const int N = 1e5 + 10; const int M = 4e5 + 20;std::priority_queue &lt; pll , std::vector &lt; pll &gt; , std::greater &lt; pll &gt; &gt; qu;int n , m , s , t;struct Edge &#123; int to; int data; int next;&#125;e[M];int head[N] , dis[N];bool inque[N];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void Heap_Dijkstra ( int x ) &#123; memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); dis[x] = 0; qu.push ( MP ( dis[x] , x ) ); while ( !qu.empty () ) &#123; int j = qu.top ().se; qu.pop (); if ( inque[j] ) continue; inque[j] = 1; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].data ) &#123; dis[k] = dis[j] + e[i].data; qu.push ( MP ( dis[k] , k ) ); &#125; &#125; &#125; return;&#125;int main ( void ) &#123; n = read (); m = read (); s = read (); F ( i , 1 , m ) &#123; int x = read () , y = read () , z = read (); add ( x , y , z ); &#125; Heap_Dijkstra ( s ); F ( i , 1 , n ) printf ( "%d " , dis[i] ); return 0;&#125; 就先整理这些吧…留个坑等着填….]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2010] 所驼门王的宝藏]]></title>
    <url>%2F2018%2F11%2F05%2Fi-t%2F</url>
    <content type="text"><![CDATA[一道思维难度很简单，代码实现难度非常$mmp$的毒瘤题…..(这很$SDOI…..$) 题目连接：SDOI2010 所驼门王的宝藏 好，我们直接跳过题目背景。 然后我们会发现，如果这道题能把图建出来，那么直接一遍$DAG$上$DP$就过了。 蒽，这不是$sb$题吗？ 然后让我们看数据范围：$1&lt;=n&lt;=1000000$ 笑容逐渐消失 但是我们考虑一下，既然我们要建一张$DAG$。那么，我们完全没有必要对所有的点进行两两连边。我们只需要对每一行和每一列进行连边，把他们连成一个环，这样的话，建边复杂度就会从$O(n^2)$变成$O(n)$了。 然后对于自由门的情况，对不起，我不知道怎么优化，所以我决定暴力建边。 （分析可以发现即使全是自由门，你暴力建边也不会$TLE$） 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;map&gt;const int N = 1e6 + 10;const int M = 5e6 + 10;using std :: map;using std :: stack;int ans = -0x3f3f3f3f;int n , r , c , t;int dx[] = &#123; 0 , 0 , 1 , 1 , 1 , -1 , -1 , -1 &#125;;int dy[] = &#123; 1 , -1 , 1 , 0 , -1 , 1 , 0 , -1 &#125;;struct Node &#123; int x; int y; int opts; int id;&#125;p[N];struct Edge &#123; int from; int to; int next; &#125;e[M];int idx , Bcnt;int head[N] , dfn[N] , low[N];int Belong[N] , size[N] , f[N];int degree[N];bool instack[N];map &lt; std :: pair &lt; int , int &gt; , int &gt; mp;map &lt; std :: pair &lt; int , int &gt; , int &gt; mat;stack &lt; int &gt; st;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].from = x; e[t].next = head[x]; head[x] = t; return;&#125;bool cmp1 ( Node a , Node b ) &#123; if ( a.x != b.x ) return a.x &lt; b.x; if ( a.opts == 1 ) return 1; if ( b .opts == 1 ) return 0; return a.y &lt; b.y;&#125;bool cmp2 ( Node a , Node b ) &#123; if ( a.y != b.y ) return a.y &lt; b.y; if ( a.opts == 2 ) return 1; if ( b.opts == 2 ) return 0; return a.x &lt; b.x;&#125;void Tarjan ( int cur ) &#123; dfn[cur] = low[cur] = ++idx; instack[cur] = 1; st.push ( cur ); for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( !dfn[j] ) &#123; Tarjan ( j ); low[cur] = min ( low[cur] , low[j] ); &#125; else if ( instack[j] ) low[cur] = min ( low[cur] , dfn[j] ); &#125; int k; if ( low[cur] == dfn[cur] ) &#123; Bcnt++; do &#123; k = st.top ();; st.pop (); instack[k] = 0; Belong[k] = Bcnt; size[Bcnt]++; &#125; while ( k != cur ); &#125; return;&#125;void dfs ( int cur , int father ) &#123; if ( f[cur] &gt; size[cur] ) return; f[cur] = size[cur]; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == father ) continue; dfs ( j , cur ); f[cur] = max ( f[cur] , f[j] + size[cur] ); &#125; return;&#125;int main ( void ) &#123; n = read () , r = read () , c = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; p[i].x = read (); p[i].y = read (); p[i].opts = read (); p[i].id = i; mp[std::make_pair ( p[i].x , p[i].y )] = i; &#125; std :: sort ( p + 1 , p + n + 1 , cmp1 ); int first = 1 , last = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( p[i].x != p[i + 1].x ) &#123; if ( first != last ) add ( p[last].id , p[first].id ); last = first = i + 1; &#125; else &#123; if ( p[last].opts == 1 ) add ( p[last].id , p[i + 1].id ); if ( p[i + 1].opts == 1 ) last = i + 1; if ( p[first].opts != 1 ) last = first = i + 1; &#125; &#125; first = last = 1; std :: sort ( p + 1 , p + 1 + n , cmp2 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( p[i].y != p[i + 1].y ) &#123; if ( first != last ) add ( p[last].id , p[first].id ); last = first = i + 1; &#125; else &#123; if ( p[last].opts == 2 ) add ( p[last].id , p[i + 1].id ); if ( p[i + 1].opts == 2 ) last = i + 1; if ( p[first].opts != 2 ) last = first = i + 1; &#125; &#125; //printf ( "%d\n" , t ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( p[i].opts == 3 ) for ( int j = 0 ; j &lt; 8 ; j++ ) &#123; int xx = p[i].x + dx[j]; int yy = p[i].y + dy[j]; if ( mp[std :: pair &lt; int , int &gt; ( xx , yy )] ) add ( p[i].id , mp[std :: pair &lt; int , int &gt; ( xx , yy )] ); &#125; // printf ( "%d\n" , t ); // for ( int i = 1 ; i &lt;= t ; i++ ) // printf ( "%d %d\n" , e[i].from , e[i].to ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( !Belong[i] ) Tarjan ( i ); for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = head[i] ; j ; j = e[j].next ) &#123; int k = e[j].to; if ( Belong[i] != Belong[k] ) mat[std :: make_pair ( Belong[i] , Belong[k] )] = 1; &#125; t = 0; memset ( head, 0 , sizeof ( head ) ); for ( auto it = mat.begin () ; it != mat.end() ; it++ ) &#123; add ( it -&gt; first.first , it -&gt; first.second ); degree[it -&gt; first.second]++; &#125; // for ( int i = 1 ; i &lt;= Bcnt ; i++ ) // printf ( "%d " , degree[i] ); for ( int i = 1 ; i &lt;= Bcnt ; i++ ) if ( degree[i] == 0 ) &#123; dfs ( i , 0 ); ans = max ( ans , f[i] ); &#125; printf ( "%d\n" , ans ); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qbxt D2T2 Code 题解]]></title>
    <url>%2F2018%2F11%2F04%2F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[看了一眼之后完全就是一脸懵逼的题…. 首先先读题$qaq$…..题目的大致意思就是给你一个矩阵，然后问你把这个矩阵横竖填成异或值为$1$的矩阵的方案数。 很明显，这道题没有什么枚举上界，所以你想直接枚举的话是不太可能的。那么我们怎么办呢$?$ 我也不知道 既然枚举补星，那么我们就用一个比较常见的正难则反的思想。对于这道题，我们可以容斥的去做 那么，首先，所有的方案是什么呢？ All = 2^{n*m}为什么呢？一共有n+m个校验码，我们按位数考虑，在只有1位的情况下，那么这一位可能是$0$或者$1$。那么就是$(2^n)^m$的方案数了。 然后我们考虑对于每一位删掉不合法的情况：因为异或起来是$1$，那么对于没一行或者每一列，$1$的个数总是奇数。那么我们就可以根据这个东西来进行删除不合法状态的操作了 最后统计出来答案 我们发现，因为有$k$位，而我们是按位考虑的。所以我们最后要取答案的$k$次方。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define int long longconst int N = 505;const int MOD = 1e9 + 7;int c[N][N];int n , m , k , t , ans;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int Fast_Power ( int x , int y ) &#123; int sum = 1; while ( y ) &#123; if ( y &amp; 1 ) sum = sum * x % MOD; x = x * x % MOD; y &gt;&gt;= 1; &#125; return sum;&#125;signed main() &#123; for ( int i = 1 ; i &lt;= 500 ; i++ ) c[i][i] = c[i][0]=1; for ( int i = 2 ; i &lt;= 500 ; i++ ) for ( int j = 1 ; j &lt; i ; j++ ) c[i][j] = ( c[i - 1][j] + c[i - 1][j - 1] ) %MOD; t = read(); while ( t-- ) &#123; n = read () , m = read() , k = read (); int ans = Fast_Power ( 2 , n * m ); for ( int i = 0 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) &#123; if ( i == 0 &amp;&amp; j == 0 ) continue; if ( ( i + j ) &amp; 1 ) ans = ( ans + MOD - Fast_Power ( 2 , ( n - i ) * ( m - j ) ) * c[n][i] % MOD * c[m][j] % MOD ) % MOD; else ans = ( ans + Fast_Power ( 2 , ( n - i ) * ( m - j ) ) * c[n][i] % MOD * c[m][j] % MOD ) % MOD; &#125; ans = Fast_Power ( ans , k ); printf ( "%lld\n" , ans ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解] Noip2016D1T3 换教室]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%8D%A2%E6%95%99%E5%AE%A4%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一道被天天爱跑步抢尽了风头的最没有排面的$T3…..$说实话，这道题我刚开始是不会的，然后我看了L_Y_T大爷的$Blog$之后才恍然大悟（$Blog$写的很好，赞一个）先安利完$Blog$再说L_Y_T大爷的Blog 看了$Blog$之后,突然发现，这东西要求的概率知识点我都是会的，只是DP式子想不出来而已$qaq…$(我好菜啊) 因为题目中说，我们最多可以换$m$次，而题目中说的你只能在开始之前选择方案的说法完全没用，毕竟谁会知道你是预测了未来呢（逃 然后，因为有$n$个课程，所以我们设$f[i][j][0/1]$来表示第i个点,第j次换,换不换 然后我们分情况来表示转移：每个教室分为两种情况 1.换2.不换这个是挺平常的然后复杂在换与不换的分情况上了~~~不换:不换是分为这样几种情况:上一个也不换 , 上一个换 且成功,上一个换但失败同理,换也有好多种情况:上一个点不换,这个点失败上一个点不换,这个点成功上一个点换成功,这个点成功上一个点换成功,这个点失败上一个点换失败,这个点成功上一个点换失败,这个点也失败 然后方程好复杂的，是：1234567891011121314151617181920212223242526 上一点不换:f[i-1][j-1][0]这一点换1.失败消耗体力: dis[c[i-1]][c[i]] 分析: 由于上一个点不换,所以上一个点一定是在c[]中的;假定这次失败,那么这次也只能去c[]中的教室;2.成功消耗体力: dis[c[i-1]][d[i]]分析: 由于上一个点不换,所以上一个点一定是在c[]中的;假定这次成功,那么这次能去d[]中的教室;那么,失败的概率是1-k[],成功的概率是k[].综上,这种情况就是:f[i-1][j-1][0]+dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1.0-k[i]) 同理,上一点换,这一点换1.上一点失败,这一点失败(以后省一点哈)消耗体力: dis[c[i-1]][c[i]]概率:都失败这运气也没谁了!!!! 概率:(1.0-k[i-1])*(1.0-k[i])2.失败,成功消耗体力: dis[c[i-1]][d[i]]概率 : (1.0-k[i-1])*k[i]3.成功,失败消耗体力 : dis[d[i-1]][c[i]]概率: k[i-1]*(1.0-k[i])4.成功,成功消耗体力: dis[d[i-1]][d[i]] 概率: k[i-1]*k[i] 然后对于不换的方程：12f[i][j][0] = min(f[i-1][j][0]+dis[c[i-1]][c[i]],f[i-1][j][1]+dis[c[i-1]][c[i]]*(1.0-k[i-1])+dis[d[i-1]][c[i]]*k[i-1]) ; 之前需要Floyd预处理一下，然后就好啦(这道题的确比天天爱跑步简单23333)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 2050;const int M = 350;int n , m , v , e;int c[N] , d[N] ;double G[M][M] , f[N][N][2];double k[N];template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;int main ( void ) &#123; scanf ( "%d%d%d%d" , &amp;n , &amp;m , &amp;v , &amp;e ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;c[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;d[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%lf" , &amp;k[i] ); for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) f[i][j][0] = f[i][j][1] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= v ; i++ ) G[i][i] = 0 ; for ( int i = 1 ; i &lt;= e ; i++ ) &#123; int x , y; double z; scanf ( "%d%d%lf" , &amp;x , &amp;y , &amp;z ); if ( G[x][y] &gt; z ) G[x][y] = G[y][x] = z; &#125; for ( int l = 1 ; l &lt;= v ; l++ ) for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = min ( G[i][j] , G[i][l] + G[l][j] ); f[1][0][0] = f[1][1][1] = 0.0000; for ( int i = 2 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= min ( i , m ) ; j++ ) &#123; f[i][j][0] = min ( f[i - 1][j][0] + G[c[i - 1]][c[i]] , f[i - 1][j][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1] ); if(j &gt;= 1) &#123; f[i][j][1] = min ( f[i - 1][j - 1][0] + G[c[i - 1]][d[i]] * k[i] + G[c[i - 1]][c[i]] * ( 1.0 - k[i] ) , f[i - 1][j - 1][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) * ( 1.0 - k[i] ) + G[c[i - 1]][d[i]] *k[i] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1]* ( 1.0 - k[i] ) + G[d[i - 1]][d[i]] * k[i - 1] * k[i] ); &#125; &#125; double ans = 0x7fffffff; for ( int i = 0 ; i &lt;= m ; i++ ) for ( int j = 0 ; j &lt;= 1 ; j++ ) ans = min ( ans , f[n][i][j] ); printf ( "%.2lf\n" , ans ) ; return 0 ;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率入门]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%A6%82%E7%8E%87%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[其实这道初赛题是我第一次做的概率题 我们来看一眼这道毒瘤题： 题面其实已经很清楚了，我们可以发现，当这个青蛙在第$1$块石头时，那么这只青蛙完全可以不用跳，我们设$f(k)$表示这只青蛙在$k$号荷叶上，期望需要$f(k)$次跳到$1$号荷叶，那么我们有： f(1)=0我们接着来考虑当这只青蛙在$2$号荷叶时的情况，它可以跳到$1$号和$2$号荷叶，当它跳到$1$号荷叶时，它完成了任务，跳了一步。当它跳到$2$号时，它还有$f(2)$步，因为每一次跳跃时，跳跃到每一个荷叶上的几率是相等的，所以我们有： f(2)=[1+(1+f(2))]/2同理，我们可以得到： f(3)=[1+(1+f(2))+(1+f(3))]/3推广到一般形式则有: f(k)=[\sum_{i=1}^k{f(i)+1}]/k我们化简一下，有： f(k)=1+\frac {1}{k}\sum_{i=1}^kf(i) 我们看到这个式子：$f(k)=1+\frac {1}{k}\sum_{i=1}^kf(i)$ 当$i==k$的时候,我们会发现式子里出现了一个$f(k)$….. 这咋求啊 我们展开这个式子，会发现原来的式子等价于： f(k)=1+\frac {1}{k}\sum_{i=1}^{k-1}f(i)+\frac 1kf(k)这时候如果把$f(k)$看作一个未知数的话，我们可以发现$f(k)$的这一项是可以合并的。但是我们先两边同乘一个$k$，把分母去掉，就会有： k*f(k)=k+\sum_{i=1}^{k-1}f(i)+f(k)这样答案就很显然了，合并掉等式两边相等的$f(k)$，会得到： (k-1)*f(k)=k+\sum_{i=1}^{k-1}f(i)最后，两边同除$(k-1)$，有最后答案上的公式： f(k)=\frac{k}{k-1}(1+\frac {\sum_{i=1}^{k-1}f(i)}{k-1})通过这个式子计算可以得到$f(5)=\frac{37}{12}$,也就是答案 做完了QAQ(写Markdown好累啊qwq…)]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2015]WIL-Wilcze题解]]></title>
    <url>%2F2018%2F11%2F02%2FPOI2015-WIL-Wilcze%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[其实这本来是$QBXT$的$T2$，但是由于毒瘤$zhw$跑得快（雾），导致我们发现这是某$poi$原题。 首先看题面:题目链接 详细读了一遍之后，其实对于这道题，我的第一反应是贪心（也许是因为我太菜了）。然后打了一遍，小样例过了，然后被大样例$hack$。 之后我又用命分析了一下。可以发现，因为题目中保证每个数的值全部$&gt;=0$，即每个数都是正整数。所以我们与其选长度不到$d$的区间删除，不如直接选择长度为$d$的区间删除。 那么在一段长度已知的序列中，长度为$d$的子序列个数是已知的，那么我们就可以预处理出每一段长度为$d$的子序列。然后我们又发现，题目中要求区间的长度不超过p，那么我们很明显的可以想到尺取法。 然后我们就可以用单调队列来维护我们预处理出的这些长度为$d$的子序列。然后对于区间长度取$max$就是答案了。 最后怒斥一波出原题的出题人$qaq$….(虽然$zhw$很帅) 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;deque&gt;typedef long long ll;using std::deque;const ll N=2000010;ll n,p,d;ll a[N];ll sum[N];ll hea[N];struct Node&#123; ll pos,val; Node(ll pos,ll val):pos(pos),val(val)&#123;&#125; Node()&#123;&#125;&#125;;inline void read(ll &amp;x)&#123; ll s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; x=s*w; return;&#125;deque&lt;Node&gt;q;int main()&#123; read(n);read(p);read(d); for(int i=1;i&lt;=n;i++)read(a[i]),sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n-d;i++) hea[i]=sum[i+d]-sum[i]; for(int i=n-d+1;i&lt;=n;i++) hea[i]=sum[n]-sum[i]; ll ans=0; int l=0; for(int i=d+1;i&lt;=n;i++) &#123; while(!q.empty()&amp;&amp;q.back().val&lt;hea[i-d])q.pop_back(); q.push_back(Node(i-d,hea[i-d])); while(l&lt;i-d&amp;&amp;sum[i]-sum[l]-q.front().val&gt;p) &#123; l++; while(l&gt;q.front().pos)q.pop_front(); &#125; ans=std::max(ans,(ll)i-l); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复赛冲刺Day1R1-Color题解]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%A4%8D%E8%B5%9B%E5%86%B2%E5%88%BADay1R1-Colory%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这道题是考试时的$T2$，我感觉这道题出的特别好（虽然当时并不会做 首先看题目:$emmmmm…..$什么鬼啊这个题是$QAQ$ 当时直接一脸懵逼，然后只会写2^n 枚举每一种填充方式，然后再检测的方法…然而这道题这么做只有10分啊$qaq….$ 然后赛后题解告诉我：这题TM是个欧拉回路！！！！当时我就懵逼了….然后当dalao们给我把这道题讲明白了之后，我才发现这道题思路的奇妙。 首先，我们发现，对于一个点，它对应着一个横坐标和一个纵坐标。蒽….一个点对应着两个数值，这个时候我们应该想到什么？二分图？对了，这东西还真的就是要你用二分图的思想来建图….(心态崩了我要妹子$QAQ$) 我们建图，然后我们发现，因为一个点对应着一个横坐标和一个纵坐标，那么我们想到：在二分图中，每一条边也是对应着两种点。那么受到这样的启发，我们就可以建图了：我们把横坐标和纵坐标分别看成一种点，然后将题目中给你的点看成这张图上的边，那么因为题目中要求：黑点和白点的绝对值差不大于1…..，那么我们能想到什么呢？我们要对这些边进行黑白染色，所以我们要一个点出发，一直走一条欧拉回路，这样能走遍所有的边。 但是这样做，我们会发现一个问题：只有$subtask4$的$30$分数据告诉你是偶数。而存在欧拉回路的图的特点是什么呢？每个点的度数都是偶数，那么当点的度数是奇数的时候，我们怎么办呢？ 我在这里选择了度数为奇数的点向一个虚拟节点连边，然后当所有点的度数都是偶数时，这时候没有其他点向这个点连边所以这时候这个虚拟节点对答案没有影响。 然后，我们就直接对边进行染色就可以了。 我只想说，这道题出的真的好，佩服出题人。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt; const int N = 5e5 + 10; struct Data &#123; int v; int p;&#125;data[N];struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int n , m , t = 1 , num;int head[N] , d[N];int x[N] , y[N] , ans[N];bool flag[N]; inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline bool cmp ( Data x , Data y ) &#123; return x.v&lt;y.v;&#125;void lisanhua () &#123; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = x[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; x[data[i].p] = num; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = y[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; y[data[i].p] = num; &#125; return;&#125;void dfs ( int cur , bool last ) &#123; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; if ( flag[i &gt;&gt; 1] ) continue; int j = e[i].to; flag[i &gt;&gt; 1] = 1; d[cur]--; d[j]--; ans[i &gt;&gt; 1] = !last; dfs ( j , !last ); &#125; return;&#125; int main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; x[i] = read (); y[i] = read (); &#125; lisanhua(); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; d[x[i]]++; d[y[i]]++; add ( x[i] , y[i] ); add ( y[i] , x[i] ); &#125; for ( int i = 1 ; i &lt;= num ; i++ ) if ( d[i] &amp; 1 ) &#123; d[i]++; d[num + 1]++; add ( i , num + 1 ); add ( num + 1 , i ); &#125; num++; memset ( ans , -1 , sizeof ( ans ) ); for ( int i = 1 ; i &lt;= num ; i++ ) while ( d[i] ) dfs ( i , 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , ans[i] , i == n ? '\n' : ' ' ); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复赛冲刺Day1R1-Count题解]]></title>
    <url>%2F2018%2F11%2F01%2FqbxtD1T1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[其实我感觉这道数论题还是挺简单的（虽然我不会） 这道数论题，我初看的时候是挺一脸懵逼的，然后据$wucstdio$大爷提供的思路，我们可以发现：题意求的是$x$,$y$在$mod P$下的逆元，存在解的条件是$gcd(x,p)==1$，即x,p互质。所以由题解有设 1 到 P − 1 中与 P 互质的数有 s 个，考虑这 s 个数与它们的逆元组成的二元组，这些二元组一定符合条件，那么只要考虑去重的问题 所以我们只需要知道从$1$到$n$中和$n$互质的数的个数这个东西是什么呢？这个东西很明显是$phi$函数。所以我们只需要求出$\phi(p)$，再加上$x^2\equiv1\pmod{p}$的数，最后除$2$就好了。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e7 + 10;int n;int tot , prime[N] , phi[N];bool flag[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); flag[1] = 1; phi[1] = 1; for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; prime[++tot] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] *prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; long long ans = phi[n]; for ( long long i = 1 ; i &lt;= n ; i++ ) if ( i * i % n == 1 ) ans++; printf ( "%lld\n" , ( long long ) ( ans ) / 2 ); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A*学习笔记]]></title>
    <url>%2F2018%2F10%2F19%2FA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[例题：$LuoguP2324$:骑士精神 $A*$嘛，很早时候就听说过，貌似是一种很神奇的算法。听长者讲过一遍，一直都想自己打一遍。但是一直没机会。所以来自己写一遍就好啦。 $A*$的重点就是一个叫做估价函数的东西，但是这个叫估价函数的东西你必须要好好写，不然你会搜出来$WA$的好成绩对于这道题，我就是将现在的棋盘和目标棋盘不同棋子数的差当作估价函数（其实是正确的)。然后，我们就可以加一个类似于剪枝的东西：如果现在的步数$+$估价函数估计的值$&gt;$现在的$max$，直接$return$就好。剩下的东西就是个大爆搜了， 以下是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int goal[7][7] = &#123; &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;, &#123; 0 , 1 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 2 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;&#125;;char mp[6][6];int now[6][6];bool flag;int dx[] = &#123; 0 , 1 , 1 , -1 , -1 , 2 , 2 , -2 , -2 &#125;;int dy[] = &#123; 0 , 2 , -2 , 2 , -2 , 1 , -1 , 1 , -1 &#125;;inline int calcu () &#123; int tmp = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) &#123; if ( now[i][j] != goal[i][j] ) tmp++; &#125; return tmp;&#125;inline void swap ( int &amp;x , int &amp;y ) &#123; int t = x; x = y; y = t; return;&#125;void A_Star ( int x , int y , int dep , int MaxStep ) &#123; if ( flag ) return; if ( dep == MaxStep ) &#123; if ( calcu () == 0 ) &#123; flag = 1; printf ( "%d\n" , MaxStep ); return; &#125; return; &#125; for ( int i = 1 ; i &lt;= 8 ; i++ ) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if ( xx &gt; 5 || xx &lt; 1 || yy &gt; 5 || yy &lt; 1 ) continue; swap ( now[x][y] , now[xx][yy] ); if ( calcu () + dep &lt;= MaxStep ) A_Star ( xx , yy , dep + 1 , MaxStep ); swap ( now[x][y] , now[xx][yy] ); &#125; return;&#125;int main ( void ) &#123; int ttt; scanf ( "%d" , &amp;ttt ); while ( ttt-- ) &#123; flag = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) scanf ( "%s" , mp[i] + 1 ); int st_x , st_y; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) if ( mp[i][j] == '*' ) &#123; st_x = i; st_y = j; now[i][j] = 2; &#125; else now[i][j] = mp[i][j] - '0'; if ( calcu () == 0 ) &#123; puts ( "0" ); return 0; &#125; for ( int i = 1 ; i &lt;= 15 ; i++ ) if ( !flag ) A_Star ( st_x , st_y , 0 , i ); if ( !flag ) puts ( "-1" ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wucstdio的毒瘤模拟赛]]></title>
    <url>%2F2018%2F10%2F18%2Fwucstdio%E7%9A%84%E6%AF%92%E7%98%A4%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[$wucstdio$大爷的Flag还是没有倒…. T1: 反正我刚开始对这道题是完全没有什么信心的qaq（才不会告诉你我直接去看的$T2$） 考虑$50$分的情况：一条链。所以就是一个等差数列了qwq 考虑剩余的正解，我们可以把每一步的期望值当成这棵树的权值，然后因为从上向下和从下向上的期望值可能不太一样，所以我们需要两个函数来表示：（相当于两条边）。 我们设$f(x) g(x)$分别表示从下向上和从上向下的情况，所以我们考虑求出$f(x)$时，我们要考虑以下情况： 直接走到这个节点的父节点，所以这种情况下，对这个节点对答案的贡献就是$\frac {1}{d[x]}了$ 还有一种情况就是这个节点先跳到他的儿子，再跳回这个节点，再跳过去。这个时候，因为我们需要一步来跳过去，所以这种情况对答案的贡献就是:$\sum_{j=son} \frac {1}{d[x]}[1 + f(x) + f(j) ]$ 我们综合考虑一下这两种情况对答案的贡献值，将这两个式子加起来，我们就会得到下边的这个式子： f(x) = \frac{1}{d} + \sum_{j=son}\frac{1}{d}\times[1 +f(x) + f ( j )]我们安置我们做期望的一贯思路（好像我做过多少期望一样QwQ），因为$num[son]=p-1$，所以我们可以得到这样一个式子： d\times f(x)=1+d-1+(d-1)f(x)+\sum_{j}f(j)化简一下之后有： f(x)=d+\sum_{j}f(j)然后我们来考虑一下$g(x)$这个东西怎么求，当我们经过观察之后，我们可以发现这个式子有三种情况： 他的父亲直接跳到他这里，这种情况对答案的贡献就是$\frac{1}{d[father]}$ 他的父亲先跳到他的爷爷，然后再跳回来，这种情况下，对答案的贡献就是：$\frac{1}{d[father]}\times (1 + g(p) +g(x) )$ 他的父亲跳到他的兄弟然后再跳到他自己。 我们把这三种情况加起来，就会有： g(x)=\dfrac {1}{d[father]} \times(1+g(p)+g(x))+\dfrac {1}{d[father]}+\sum_{pa_j=pa_x\&\&j\not=x}\dfrac {1}{d[father]} (1+f(j)+g(x))继续化简有： g(x)=g(p)+f(p)-f(x)通过这种方式，我们就可以把$g(x) f(x)$算出来，相当于边长。 算出边长后，这个问题就转化成了：给你一颗树，求树的直径。我选择了DP求直径，就很简单了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;const int N = 2e5 + 10;int n , m , t;struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int head[N];int now_ans;int f[N] , g[N] , p[N];int LongDis[N][2] , SecondDis[N][2];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline int min ( int x , int y ) &#123; return x &lt; y ? x : y;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;void Find_f ( int root , int fa ) &#123; f[root] = p[root]; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Find_f ( j , root ); f[root] += f[j]; &#125; return;&#125;void Find_g ( int root , int fa ) &#123; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; g[j] = f[root] + g[root] - f[j]; Find_g ( j , root ); &#125; return;&#125;void Work ( int root , int fa ) &#123; int Frist = 0 , Second = 0; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Work ( j , root ); if ( LongDis[j][0] + g[j] &gt; LongDis[root][0] ) &#123; SecondDis[root][0] = LongDis[root][0]; LongDis[root][0] = LongDis[j][0] + g[j]; Frist = j; &#125; else if ( LongDis[j][0] + g[j] &gt; SecondDis[root][0] ) SecondDis[root][0] = LongDis[j][0] + g[j]; if ( LongDis[j][1] + f[j] &gt; LongDis[root][1] ) &#123; SecondDis[root][1] = LongDis[root][1]; LongDis[root][1] = LongDis[j][1] + f[j]; Second = j; &#125; else if ( LongDis[j][1] + f[j] &gt; SecondDis[root][1] ) SecondDis[root][1] = LongDis[j][1] + f[j]; &#125; if ( Frist != Second ) now_ans = max ( LongDis[root][0] + LongDis[root][1] , now_ans ); else if ( Frist == Second ) now_ans = max ( now_ans , max ( SecondDis[root][1] + LongDis[root][0] , SecondDis[root][0] + LongDis[root][1] ) ); return;&#125;int main ( void ) &#123; freopen ( "tree.in" , "r" , stdin ); freopen ( "tree.out" , "w" , stdout ); n = read (); for ( int i = 1 ; i &lt; n ; i++ ) &#123; int x = read () , y = read (); add ( x , y ); add ( y , x ); p[x]++; p[y]++; &#125; Find_f ( 1 , 0 ); Find_g ( 1 , 0 ); Work ( 1 , 0 ); printf ( "%d.00000\n" , now_ans ); return 0;&#125; T2:其实暴力还是挺显然的]]></content>
      <tags>
        <tag>模拟赛心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前排打出题人的一套题]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%89%8D%E6%8E%92%E6%89%93%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E4%B8%80%E5%A5%97%E9%A2%98%2F</url>
    <content type="text"><![CDATA[不管怎么样，先打死出题人再说qaq… T1:人贩子$LLFZ$ 题意很显然就是最优贸易啊…. 一眼看出来是缩点+DP….但是为什么我之前是SPFA过的啊QAQ…写SPFA比较稳….然后….就写了…. 上代码吧…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int N = 1e5 + 10;const int M = 1e6 + 10;const int INF = 2147483647;#define G(i,a,b,c) for ( int i = b[a] ; i ; i = c[i].next )int n , m , t , cnt;struct Edge &#123; int to; int data; int next;&#125;e[M] , e_[M];int head[N] , head_[N];int maxs[N] , mins[N];int dis[N] , value[N];bool inque[N];std :: queue &lt; int &gt; qu;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void add_ ( int x , int y , int z ) &#123; e_[++cnt].to = y; e_[cnt].data = z; e_[cnt].next = head_[x]; head_[x] = cnt; return;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;void Heap_Dijkstra () &#123; std :: memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[1] = 1 , dis[1] = value[1]; qu.push ( 1 ); while ( !qu.empty () ) &#123; int j = qu.front (); inque[j] = 0; qu.pop (); G ( i , j , head , e ) &#123; int k = e[i].to; if ( dis[k] &gt; min ( dis[j] , e[i].data ) ) &#123; dis[k] = min ( dis[j] , e[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) mins[i] = dis[i]; std :: memset ( dis , -0x3f3f3f3f , sizeof ( dis ) ); inque[n] = 1 , dis[n] = value[n]; qu.push ( n ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; G ( i , j , head_ , e_ ) &#123; int k = e_[i].to; if ( dis[k] &lt; max ( dis[j] , e_[i].data ) ) &#123; dis[k] = max ( dis[j] , e_[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) maxs[i] = dis[i]; return;&#125; int main ( void ) &#123; freopen ( "child.in" , "r" , stdin ); freopen ( "child.out" , "w" , stdout ); n = read (); m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) value[i] = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); if ( z == 1 ) &#123; add ( x , y , value[y] ); add_ ( y , x , value[x] ); &#125; else if ( z == 2 ) &#123; add ( x , y , value[y] ); add ( y , x , value[x] ); add_ ( y , x , value[x] ); add_ ( x , y , value[y] ); &#125; &#125; Heap_Dijkstra (); int ans = -INF; for ( int i = 1 ; i &lt;= n ; i++ ) ans = max ( ans , maxs[i] - mins[i] ); printf ( "%d\n" , ans ); return 0;&#125; T2 : food 再来拿出题人祭天祭一波… 话说我直接读题读错了然后写了个错误的DP然后还A了是什么鬼啊…. 话说我考虑了前缀和，那么我还过了，说明直接加起来然后除就可以? 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int N = 15;int n , ans = -1;int A , B , C;int p1 , p2 , p3;int MaxTime[N];int f[N][105][105][105];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;int main ( void ) &#123; freopen ( "food.in" , "r" , stdin ); freopen ( "food.out" , "w" , stdout ); A = read () , B = read () , C = read (); p1 = read () , p2 = read () , p3 = read (); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; MaxTime[i] = read (); MaxTime[i] = MaxTime[i - 1] + MaxTime[i]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = A ; j * p1 &lt;= MaxTime[i] &amp;&amp; j&lt;=100 ; j++ ) for ( int k = B; j * p1 + k * p2 &lt;= MaxTime[i] &amp;&amp; k &lt;= 100 ; k++ ) for ( int l = C ; j * p1 + k * p2 + l * p3 &lt;= MaxTime[i] &amp;&amp; l &lt;=100 ; l++ ) &#123; f[i][j][k][l] = max ( f[i][j][k][l] , max ( f[i - 1][j - A][k - B][l - C] + 1 , f[i][j - A][k - B][l - C] + 1 ) ); ans = max ( ans , f[i][j][k][l] ); &#125; printf ( "%d\n" , ans ); return 0;&#125; T3: Happy 再吐槽一波为什么Noip模拟赛会考离散对数（然而我并不会….） 其实应该是一道签到题吧。。。 暴力水过…. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int P , A , B;bool app[50005];int main ( void ) &#123; freopen ( "happy.in" , "r" , stdin ); freopen ( "happy.out" , "w" , stdout ); int T = read (); while ( T-- ) &#123; int now = 1; memset ( app , false , sizeof ( app ) ); P = read () , A = read () , B = read (); for ( int i = 1 ; ; i++ ) &#123; now = ( now * A ) % P; if ( now == B ) &#123; printf ( "%d\n" , i ); break; &#125; if ( app[now] ) &#123; puts ( "Couldn't Produce!" ); break; &#125; app[now] = 1; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模拟赛心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My_Code_Style]]></title>
    <url>%2F2018%2F10%2F13%2FMy_Code_Style%2F</url>
    <content type="text"><![CDATA[介绍下本蒟蒻的丑死的码风$qwq$…(码风大概是魔改了神犇$Menci$的) 在打CF时并不是这个码风 码风概述： 所有的#include后必须有一个空格,例如#include 无论什么样子的程序，都必须写cstdio cstring algorihtm iostream这四个头文件。 在主程序的int main()中要加void，即为int main(void) 一般不写using namespace std; 所有的变量必须定义在第一个自定义函数之前，且变量和第一个自定义函数，最后一个自定义函数和$main​$之间必须有一个换行 每个函数之后尽可能有$return$， 在一般情况下，在花括号内的内容不加逗号 缩进： 对于每个代码块，使用4空格或者等长的Tab缩进。 括号： 大括号不换行 空格： 个人感觉自己的空格比较的毒瘤。 1.在每个函数声明时，函数名后的括号与函数名之间必须有一个空格,而且括号内如果需要声明变量，则要先有一个空格，且逗号的前后都必须有一个空格。 2.在for循环的声明中，每一个字符（变量名除外），都要用空格隔开。 3.数组内一般不加空格，但是如果有运算符则运算符前后必须有空格。 4.每个可以前后匹配的括号前后必须有空格。 代码大概长这样… 1234567891011121314151617struct wqwqwqwqwq &#123; int qwwq; int qwq;&#125;wwq;void qweqweqweq ( wqwqwqwq x , qwqwqwqwqwq y ) &#123; qweqweqweqweqweqweqweqwe; if ( qweqweqweqweqwe ) &#123; qewqweqweqweqweq; qweqweqweqweq; &#125; else &#123; qweqweqweqweq; qweqweqwrreeqwqqwe; qweqewqweqweqewq; &#125; return;&#125; 变量： 1.基本所有变量都是全局变量，但有些ans,sum最后统计答案时使用的变量可以定义为局部变量。 2.所有的变量名称都必须与要存储的东西的中文意思有沾边，比如树直接定义为tree而不是T。（极度不能容忍变量名直接为a,b,c,d,e,f,g,的情况。 3.定义N,M等时一般只用N,M为名称而不是MAXN,MAXM. 4.定义的结构体类型在定义变量时必须紧接着声明完成结构体后，并且结构体中变量需要定义一个加一个换行。 5.在变量命名时较长的变量名可以用_来连接，并且大小写交替使用，如$Add_Tree_Val$ 把上边所有毒瘤的码风结合起来之后代码大概长这个样子qwq.. 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int N = 1005;const int M = 100005;int n , m , s , t;int l , r;struct Node &#123; int l; int r; int sum;&#125;tree[N &lt;&lt; 2];int main ( void ) &#123; std :: memset ( tree , 0 , sizeof ( tree ) ); scanf ( "%d%d" , &amp;n , &amp;m ); printf ( "%d\n" , n + m ); for ( int i = 1 ; i &lt;= n ; i++ ) m += i; if ( n + m &lt;= m + n ) &#123; puts ( "HA" ); return 0; &#125; else &#123; puts ( "AH" ); return 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>CodeStyle</tag>
      </tags>
  </entry>
</search>
