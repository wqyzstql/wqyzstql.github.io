<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[æ™®åŠäº”è”æµ‹é™„åŠ èµ›]]></title>
    <url>%2F2019%2F11%2F09%2F%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8B%E9%99%84%E5%8A%A0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[20191107æ¨¡æ‹Ÿèµ›é¢˜è§£]]></title>
    <url>%2F2019%2F11%2F08%2F20191107%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[å¾·å·žæ‰‘å…‹çœŸå¥½çŽ©.jpg å¾·å·žæ‰‘å…‹æ€è·¯æ¨¡æ‹Ÿæœ‰å•¥æ€è·¯å…¶å®žå¯ä»¥è€ƒè™‘æŠŠæ‰€æœ‰çš„æ‰‹ç‰Œçš„ç±»åž‹å¼€ä¸€ä¸ªæ¡¶å­˜èµ·æ¥,ç„¶åŽå†ä»Žå¤§é¡ºåˆ°å•ç‰ŒæŒ¨ä¸ªåˆ¤æ–­ç‰Œåž‹,åŒç‰Œåž‹æ¯”è¾ƒå¤§å°çš„æ—¶å€™å¯ä»¥è€ƒè™‘æŠŠè´¡çŒ®å¤§çš„ä¹˜ä»¥ä¸€ä¸ªæ¯”è¾ƒå¤§çš„æ•°,ç„¶åŽç›´æŽ¥æ¯”è¾ƒåˆ†æ•°å³å¯. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &lt;bits/stdc++.h&gt;using namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 1e5 + 10;int n;struct Player &#123; int id; int point; string name; char card[12]; int num[6]; int buck[14];&#125; player[N];inline void FindCard () &#123; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) printf ( "%d%c" , player[i].num[j] , j == 5 ? '\n' : ' ' ); return;&#125;inline void DefHandCard ( int now ) &#123; int len = strlen ( player[now].card + 1 ); int cnt = 0; for ( int i = 1 ; i &lt;= len ; i++ ) &#123; if ( player[now].card[i] == '0' ) continue; if ( player[now].card[i] == '1' &amp;&amp; player[now].card[i + 1] == '0' ) player[now].num[++cnt] = 10; else if ( player[now].card[i] == 'A' ) player[now].num[++cnt] = 1; else if ( player[now].card[i] &gt;= '2' &amp;&amp; player[now].card[i] &lt;= '9' ) player[now].num[++cnt] = player[now].card[i] - '0'; else if ( player[now].card[i] == 'J' ) player[now].num[++cnt] = 11; else if ( player[now].card[i] == 'Q' ) player[now].num[++cnt] = 12; else if ( player[now].card[i] == 'K' ) player[now].num[++cnt] = 13; &#125; return;&#125;inline void PreKind ( int now ) &#123; for ( int i = 1 ; i &lt;= 5 ; i++ ) player[now].buck[player[now].num[i]]++; return;&#125;#define NowPlayer player[now] inline int FindStraight ( int now ) &#123; int flag = 0; for ( int i = 1 ; i &lt;= 9 ; i++ ) if ( NowPlayer.buck[i] &amp;&amp; NowPlayer.buck[i + 1] &amp;&amp; NowPlayer.buck[i + 2] &amp;&amp; NowPlayer.buck[i + 3] &amp;&amp; NowPlayer.buck[i + 4] ) &#123; flag = i + i + 1 + i + 2 + i + 3 + i + 4; break; &#125; if ( flag ) return flag; else return false;&#125;inline int FindFour ( int now ) &#123; int flag = 0; Player tmp = NowPlayer; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 4 ) &#123; tmp.buck[i] = 0; flag = i; break; &#125; if ( !flag ) return 0; flag *= 10000; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] ) &#123; flag += i; break; &#125; return flag;&#125;inline int FindHouse ( int now ) &#123; int flag = 0; Player tmp = NowPlayer; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 3 ) &#123; tmp.buck[i] = 0; flag = i; break; &#125; if ( !flag ) return 0; int ff = 0; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 2 ) &#123; tmp.buck[i] = 0; ff = i; break; &#125; if ( !ff ) return 0; return flag * 10000 + ff;&#125;inline int FindThree ( int now ) &#123; int flag = 0; Player tmp = NowPlayer; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 3 ) &#123; tmp.buck[i] = 0; flag = i; break; &#125; if ( !flag ) return 0; flag *= 10000; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] ) flag += i; return flag;&#125;inline int FindTwo ( int now ) &#123; int flag[3] , num = 0; Player tmp = NowPlayer; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 2 ) &#123; tmp.buck[i] = 0; flag[++num] = i; &#125; if ( num != 2 ) return 0; int ans = max ( flag[1] , flag[2] ) * 50000 + min ( flag[1] , flag[2] ) * 200; int tdp = 0; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] ) &#123; tmp.buck[i] = 0; tdp = i; break; &#125; return ans + tdp;&#125;inline int FindPair ( int now ) &#123; int flag = 0; Player tmp = NowPlayer; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 2 ) &#123; flag = i; break; &#125; if ( !flag ) return 0; flag *= 10000; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] ) &#123; tmp.buck[i] = 0; flag += i; &#125; return flag;&#125;inline int FindOne ( int now ) &#123; int flag = 0; for ( int i = 1 ; i &lt;= 13 ; i++ ) while ( NowPlayer.buck[i] ) &#123; NowPlayer.buck[i]--; flag += i; &#125; return flag;&#125;inline bool cmp ( Player x , Player y ) &#123; if ( x.id != y.id ) return x.id &gt; y.id; if ( x.point != y.point ) return x.point &gt; y.point; return x.name &lt; y.name;&#125;int main ( void ) &#123; freopen ( "dezhou.in" , "r" , stdin ); freopen ( "dezhou.out" , "w" , stdout ); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; cin &gt;&gt; player[i].name; scanf ( "%s" , player[i].card + 1 ); DefHandCard ( i ); &#125; for ( int i = 1 ; i &lt;= n ; i++ ) PreKind ( i ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( player[i].buck[10] &amp;&amp; player[i].buck[11] &amp;&amp; player[i].buck[12] &amp;&amp; player[i].buck[13] &amp;&amp; player[i].buck[1] ) player[i].id = 8; else if ( FindStraight ( i ) ) player[i].point = FindStraight ( i ) , player[i].id = 7; else if ( FindFour ( i ) ) player[i].point = FindFour ( i ) , player[i].id = 6; else if ( FindHouse ( i ) ) player[i].point = FindHouse ( i ) , player[i].id = 5; else if ( FindThree ( i ) ) player[i].point = FindThree ( i ) , player[i].id = 4; else if ( FindTwo ( i ) ) player[i].point = FindTwo ( i ) , player[i].id = 3; else if ( FindPair ( i ) ) player[i].point = FindPair ( i ) , player[i].id = 2; else player[i].point = FindOne ( i ) , player[i].id = 1; &#125; sort ( player + 1 , player + 1 + n , cmp ); for ( int i = 1 ; i &lt;= n ; i++ ) cout &lt;&lt; player[i].name &lt;&lt; endl;; return 0;&#125; ä¸‰å…ƒç»„æ€è·¯é¦–å…ˆè€ƒè™‘$O(n^2)$æ€Žä¹ˆåš:æˆ‘ä»¬æžšä¸¾ä¸€ä¸‹æ¯ä¸ªä¸‰å…ƒç»„çš„ä¸­é—´å€¼,å¯¹äºŽæ¯ä¸ª$i$,æˆ‘ä»¬è€ƒè™‘æ‰€æœ‰çš„$j$å°äºŽ$i$ä¸­$val_j$å¤§äºŽ$val_i$çš„ä¸ªæ•°å’Œ$val_j$å°äºŽ$val_i$çš„ä¸ªæ•°.ç„¶åŽå¯¹äºŽæ‰€æœ‰çš„$j&gt;i$ä¹Ÿè€ƒè™‘ä¸€ä¸‹.å‘çŽ°åªè¦$val_k$å¤§äºŽ$val_j$,$val_j$å¤§äºŽ$val_i$é‚£ä¹ˆ$val_k$ä¸€å®šå¤§äºŽ$val_i$.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨$O(n^2)$çš„å¤æ‚åº¦æ¥ç»Ÿè®¡å‡ºå¯¹äºŽæ¯ä¸ª$i$ä¸­å‰è¾¹/åŽè¾¹çš„å¤§äºŽ/å°äºŽå®ƒçš„ä¸ªæ•°.è¿™æ ·å¯ä»¥å¾—åˆ°$50$åˆ†.ç„¶åŽæˆ‘ä»¬æƒ³ä¸€ä¸‹æ€Žä¹ˆä¼˜åŒ–è¿™ä¸ªè¿‡ç¨‹.æˆ‘ä»¬æ³¨æ„åˆ°å€’æ•°ç¬¬äºŒæ¡£éƒ¨åˆ†åˆ†,å®ƒçš„æƒå€¼éžå¸¸çš„å°.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘æ€Žä¹ˆåœ¨æƒå€¼ä¸Šè¿›è¡Œæ“ä½œ.ç„¶åŽå¯¹äºŽæ‰€æœ‰çš„æƒ…å†µ,æˆ‘ä»¬ç¦»æ•£åŒ–å³å¯.æˆ‘ä»¬å‘çŽ°,å¦‚æžœæˆ‘ä»¬æŠŠæƒå€¼çœ‹æˆä¸€ä¸ªåºåˆ—,é‚£ä¹ˆæˆ‘ä»¬åœ¨æŸä¸ª$val_i$,æŸ¥è¯¢å¤§äºŽå®ƒçš„æ•°æˆ–è€…å°äºŽå®ƒçš„æ•°,å°±ç›¸å½“äºŽè¿™ä¸ªæƒå€¼åºåˆ—æŸæ®µåŒºé—´çš„å’Œ.ç„¶åŽæ¯æ¬¡æ‰«è¿‡åŽ»æ—¶åœ¨è¿™æ®µåŒºé—´ä¸­$val_i$åŠ ä¸€.è¿™ä¸ªæ“ä½œéœ€è¦æˆ‘ä»¬åŠ¨æ€çš„å•ç‚¹ä¿®æ”¹åŒºé—´æ±‚å’Œ.æ˜¾ç„¶å¯ä»¥æ ‘çŠ¶æ•°ç»„(æˆ–è€…å…¶ä»–ä»€ä¹ˆæ•°æ®ç»“æž„).è€Œå› ä¸ºæˆ‘ä»¬è¿™ä¸ªæ ‘çŠ¶æ•°ç»„æ˜¯æƒå€¼æ ‘çŠ¶æ•°ç»„,æ‰€ä»¥è¿˜éœ€è¦ç¦»æ•£åŒ–ä¸€ä¸‹å³å¯é€šè¿‡è¯¥é¢˜. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int HA = 1e9 + 7;const int N = 200005;int n;int high[N] , tree[N];struct Lsh &#123; int val; int pos;&#125; lsh[N];inline bool cmp ( Lsh x , Lsh y ) &#123; return x.val &lt; y.val;&#125;inline void Pre () &#123; int cnt = 0; lsh[0].val = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( lsh[i].val != lsh[i - 1].val ) cnt++; high[lsh[i].pos] = cnt; &#125; return;&#125;inline int lowbit ( int x ) &#123; return x &amp; -x;&#125;inline void add ( int x , int pos ) &#123; while ( pos &lt;= n ) &#123; tree[pos] += x; pos += lowbit ( pos ); &#125; return;&#125;inline int query ( int pos ) &#123; int res = 0; while ( pos ) &#123; res += tree[pos]; pos -= lowbit ( pos ); &#125; return res;&#125;int fromin[N] , fromax[N] , behmin[N] , behmax[N];signed main ( void ) &#123; freopen ( "triple.in" , "r" , stdin ); freopen ( "triple.out" , "w" , stdout ); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; lsh[i].val = read (); lsh[i].pos = i; &#125; sort ( lsh + 1 , lsh + 1 + n , cmp ); Pre (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; fromin[i] = query ( high[i] - 1 ); fromax[i] = query ( n ) - query ( high[i] ); add ( 1 , high[i] ); &#125; memset ( tree , 0 , sizeof ( tree ) ); for ( int i = n ; i &gt;= 1 ; i-- ) &#123; behmin[i] = query ( high[i] - 1 ); behmax[i] = query ( n ) - query ( high[i] ); add ( 1 , high[i] ); &#125; int ans = 0; for ( int i = 1 ; i &lt;= n ; i++ ) ans = ( ans + ( behmin[i] * fromax[i] ) % HA + ( behmax[i] * fromin[i] ) % HA ) % HA; printf ( "%lld\n" , ans );// for ( int i = 1 ; i &lt;= n ; i++ ) // printf ( "%d %d %d %d\n" , fromin[i] , fromax[i] , behmin[i] , behmax[i] ); return 0;&#125; å¤šè¾¹å½¢æ€è·¯å¬è¯´æ˜¯åœ¨çŽ¯ä¸ŠDP,çœŸçš„ä¸ä¼šx å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ¨¡æ‹Ÿèµ›é¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191106æ¨¡æ‹Ÿèµ›]]></title>
    <url>%2F2019%2F11%2F07%2F20191106%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[ç»™æˆ‘ä¹Ÿæ•´ä¸€ä¸ªè¿™æ ·çš„è¯„æµ‹çŽ¯å¢ƒ Aæ€è·¯è€ƒè™‘ä¸¤ä¸ªäººçš„ç­”æ¡ˆ,å‘çŽ°å¦‚æžœè¿™å¯¹äºŽæŸä¸ªç‰¹å®šçš„é—®é¢˜,å¦‚æžœè¿™ä¸¤ä¸ªäººçš„ç­”æ¡ˆç›¸åŒçš„è¯,é‚£ä¹ˆä»–ä»¬å¯ä»¥å°†åˆ†æ•°åŒæ—¶$+1$æˆ–è€…æ— å˜åŒ–.è€Œè‹¥ä¸¤ä¸ªäººçš„ç­”æ¡ˆä¸åŒçš„è¯,æ˜¾ç„¶æˆ‘ä»¬é€‰æ‹©åˆ†æ•°ç›¸å¯¹è¾ƒå°‘çš„äººåŠ åˆ†æ›´ä¼˜.ä½†æ˜¯éœ€è¦æ³¨æ„ä¸€ä¸ªé—®é¢˜,æˆ‘ä»¬éœ€è¦å…ˆåˆ¤æ–­ä¸¤ä¸ªäººç­”æ¡ˆç›¸åŒçš„æƒ…å†µ,å› ä¸ºè‹¥å…ˆåˆ¤æ–­ç­”æ¡ˆä¸åŒçš„æƒ…å†µçš„è¯,å‘çŽ°å¯èƒ½ä¼šå‡ºçŽ°ä¸€ä¸ªäººå·²ç»åˆ°è¾¾äº†ç›®æ ‡åˆ†æ•°,è€Œå¦ä¸€ä¸ªäººæ²¡åˆ°,è¿™æ—¶å€™å†åˆ¤æ–­ç­”æ¡ˆä¸€æ ·çš„è¯æ˜¾ç„¶ä¸¤ä¸ªäººéƒ½ä¸èƒ½å†åŠ åˆ†äº†. ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;using namespace std; const int N = 1e5 + 10;int n , x , y;char A[N] , B[N]; int main ( void ) &#123; freopen ( "A.in" , "r" , stdin ); freopen ( "A.out" , "w" , stdout ); int T = read (); while ( T-- ) &#123; n = read () , x = read () , y = read (); scanf ( "%s%s" , A + 1 , B + 1 ); int tmp = 0; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( A[i] == B[i] ) tmp++; &#125; int NowScoreA = 0 , NowScoreB = 0; NowScoreA = min ( tmp , min ( x , y ) ); NowScoreB = min ( tmp , min ( x , y ) ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( NowScoreB == y &amp;&amp; NowScoreA == x ) break; if ( A[i] != B[i] ) &#123; if ( NowScoreB &lt; NowScoreA ) &#123; if ( NowScoreB &lt; y ) NowScoreB++; else if ( NowScoreA &lt; x ) NowScoreA++; &#125; else if ( NowScoreA &lt;= NowScoreB ) &#123; if ( NowScoreA &lt; x ) NowScoreA++; else if ( NowScoreB &lt; y ) NowScoreB++; &#125; &#125; &#125; //printf ( "%d %d %d %d\n" , x , y , NowScoreA , NowScoreB ); if ( NowScoreA == x &amp;&amp; NowScoreB == y ) puts ( "Yes" ); else puts ( "No" ); &#125; return 0; &#125; Bæ€è·¯é¦–å…ˆ,æˆ‘ä»¬å¯ä»¥å‘çŽ°,å¤§å¤šæ•°çš„æ•°å­—ä¸€å®šä¸º$1$.æˆ‘ä»¬å‡è®¾çŽ°åœ¨æ•°åˆ—é‡Œåªæœ‰$1,2$è¿™ä¸¤ç§æ•°å­—çš„è¯,é‚£ä¹ˆä¸ºäº†æ»¡è¶³é¢˜ç›®ä¸­è¦æ±‚çš„æ¡ä»¶,é‚£ä¹ˆéžä¸€çš„æ•°å­—çš„ä¸ªæ•°ä¸€å®šæ˜¯æœ€å¤šçš„.æˆ‘ä»¬è®¾ 2^k]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191105æ¨¡æ‹Ÿèµ›é¢˜è§£]]></title>
    <url>%2F2019%2F11%2F06%2F20191105%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ðŸ®ðŸ»ðŸ® Workæ€è·¯é¢˜ç›®ç­‰ä»·äºŽæ‰¾åˆ°ä¸€ä¸ªæ•°é‡æœ€å°çš„æŽ’åˆ—,ä½¿å¾—å¯¹äºŽè¿™ä¸ªæŽ’åˆ—é‡Œçš„ä»»ä½•ä¸€ä¸ª$k$éƒ½æœ‰$\sum_{i=1}^{size}work_i - work_k &gt;= sleep_k$.ç„¶åŽæˆ‘ä»¬ç§»é¡¹ä¹‹åŽæœ‰$\sum_{i=1}^{size}&gt;=work_k+sleep_k$.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä»¤$x_i=sleep_i+work_i$,ç„¶åŽå¯¹äºŽ$x_i$ä»Žå°åˆ°å¤§æŽ’åº.ç„¶åŽæˆ‘ä»¬æžšä¸¾æ¯ä¸€ä¸ª$x_i$,ç„¶åŽåŒæ—¶æŠŠæ‰€æœ‰éåŽ†è¿‡çš„$work_i$ä»Žå¤§åˆ°å°æŽ’åº,æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ä¸ªé•¿åº¦æœ€å°çš„åŒºé—´ä½¿å¾—$\sum work_j &gt;= sleep_i$.é¦–å…ˆæƒ³ä¸€ä¸‹æš´åŠ›æ€Žä¹ˆç»´æŠ¤è¿™ä¸ªä¸œè¥¿:æˆ‘ä»¬æ¯è¯»è¿›æ¥æŸä¸ª$w_i$,æˆ‘ä»¬æŠŠè¿™ä¸ªå…ƒç´ è¿žåŒä¹‹å‰çš„å…ƒç´ æŒ‰ç…§$work_i$ä¸ºå…³é”®å­—ä»Žå°åˆ°å¤§æŽ’åº,å¹¶ä¸”æˆ‘ä»¬æ¯æ¬¡éƒ½é‡æ–°è®°å½•ä¸€ä¸‹$work$æ•°ç»„çš„å‰ç¼€å’Œ,ä½¿ç”¨äºŒåˆ†çš„æ–¹æ³•æ‰¾åˆ°è¿™ä¸ªæœ€å°çš„åŒºé—´é•¿åº¦.ç„¶åŽæˆ‘ä»¬è€ƒè™‘æ€Žä¹ˆä¼˜åŒ–è¿™ä¸ªè¿‡ç¨‹,æˆ‘ä»¬å‘çŽ°æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå°æ ¹å †,ç„¶åŽåˆ¤æ–­æ—¶,æ¯æ¬¡éƒ½å¼¹å‡ºä¸€ä¸ªæœ€å°å€¼.ç„¶åŽåˆ¤æ–­çŽ°åœ¨çš„$sum$æ˜¯å¦è¿˜å¤§äºŽ$sleep$.è€Œä¸”å¦‚æžœçŽ°åœ¨çš„$sum$æœ¬æ¥å°±å°äºŽ$sleep$æ—¶,æˆ‘ä»¬ä¹Ÿæ²¡å¿…è¦å†å¾€å †é‡Œæ‰”ä¸œè¥¿,å› ä¸ºå¦‚æžœè¦æ‰”ä¸œè¥¿çš„è¯ç­”æ¡ˆä¸€å®šä¸ä¼šæ›´ä¼˜.æ‰€ä»¥ç›´æŽ¥å¿½ç•¥å³å¯. ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define int long long using namespace std; const int N = 5e5 + 10; int n;struct Worker &#123; int work; int sleep;&#125; w[N];int fro[N]; inline bool cmp1 ( Worker x , Worker y ) &#123; return x.sleep + x.work &lt; y.sleep + y.work;&#125;inline bool cmp2 ( Worker x , Worker y ) &#123; return x.work &lt; y.work;&#125; inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; priority_queue &lt; int , vector &lt; int &gt; , greater &lt; int &gt; &gt; qu; signed main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) w[i].work = read () , w[i].sleep = read (); sort ( w + 1 , w + 1 + n , cmp1 ); int ans = 2147483647 , sum = 0 , size = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( w[i].sleep &lt;= sum ) &#123; while ( sum - qu.top() &gt;= w[i].sleep ) &#123; sum -= qu.top(); qu.pop(); size--; &#125; ans = min ( ans , size ); &#125; qu.push ( w[i].work ); sum += w[i].work; size++; &#125; if ( ans == 2147483647 ) puts ( "-1" ); else cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Seqæ€è·¯æˆ‘ä»¬é¦–å…ˆè€ƒè™‘æš´åŠ›æ€Žä¹ˆ$DP$,æˆ‘ä»¬å¯ä»¥è®¾$f_{i,j,0/1}$è¡¨ç¤ºçŽ°åœ¨å¯¹äºŽä¸²$A$æˆ‘ä»¬è€ƒè™‘äº†å‰$i$ä½,å¯¹äºŽä¸²$B$æˆ‘ä»¬è€ƒè™‘äº†å‰$j$ä½,å…¶ä¸­çŽ°åœ¨æ¯”ä¸Šä¸€ä½å¤§/å°æ—¶,æœ€é•¿çš„å…¬å…±æ³¢æµªå­åºåˆ—çš„é•¿åº¦æ˜¯å¤šå°‘.é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥$O(n^2)$æžšä¸¾çŠ¶æ€åŽå†$O(n^2)$æžšä¸¾è½¬ç§»,è¿™æ ·å¤æ‚åº¦æ˜¯$O(n^4)$çš„,å¯ä»¥è¿‡$40$åˆ†(å…¶å®žå¯ä»¥è¿‡$60$).ç„¶åŽæˆ‘ä»¬å‘çŽ°,æˆ‘ä»¬å¯ä»¥æŠŠè½¬ç§»æ‹†åˆ†æˆ$(i,j)-&gt;(i,y)$,ç„¶åŽå†ç”±$(i,y)-&gt;(x,y)$.ç„¶åŽæˆ‘ä»¬å¯ä»¥å¯¹äºŽæ¯ä¸€ä½åˆ†åˆ«è½¬ç§»å³å¯. ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;queue&gt; #define N 5005#define M 8000005 #define ls (t&lt;&lt;1)#define rs ((t&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1) #define mk make_pair#define pb push_back#define fi first#define se second using namespace std; int i,j,m,n,p,k,A[N],B[N],ans,a[N],b[N]; int f[N][N][2],g[N][N][2]; int Work()&#123; memset(f,0,sizeof(f)); for (i=1;i&lt;=n;++i) for(j=1;j&lt;=m;++j)&#123; f[i][j][0]=max(f[i-1][j][0],f[i][j-1][0]); if(a[i]==b[j]) f[i][j][0]=max(f[i][j][0],f[i-1][j-1][0]+1); &#125; return f[n][m][0];&#125; int main()&#123; scanf("%d",&amp;n); for (i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); scanf("%d",&amp;m); for (i=1;i&lt;=m;++i) scanf("%d",&amp;b[i]); for (i=1;i&lt;=n;++i) for (j=1;j&lt;=m;++j) if (a[i]==b[j]) f[i+1][j][0]=f[i+1][j][1]=1; for (i=1;i&lt;=n;++i) for (j=1;j&lt;=m;++j)&#123; //k==0 if (a[i]&gt;b[j]) g[i][j+1][0]=max(g[i][j+1][0],f[i][j][0]); f[i+1][j][0]=max(f[i+1][j][0],f[i][j][0]); if (a[i]==b[j]&amp;&amp;g[i][j][0]) f[i+1][j][1]=max(f[i+1][j][1],g[i][j][0]+1); g[i][j+1][0]=max(g[i][j+1][0],g[i][j][0]); //k==1 if (a[i]&lt;b[j]) g[i][j+1][1]=max(g[i][j+1][1],f[i][j][1]); f[i+1][j][1]=max(f[i+1][j][1],f[i][j][1]); if (a[i]==b[j]&amp;&amp;g[i][j][1]) f[i+1][j][0]=max(f[i+1][j][0],g[i][j][1]+1); g[i][j+1][1]=max(g[i][j+1][1],g[i][j][1]); &#125; for (i=1;i&lt;=n+1;++i) for (j=1;j&lt;=m+1;++j) ans=max(ans,max(f[i][j][0],f[i][j][1])); printf("%d\n",max(min(2,Work()),ans));&#125; Jumpåªä¼š$60$æš´åŠ›,å’•å’•å’•äº†x å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ¨¡æ‹Ÿèµ›é¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191104æ¨¡æ‹Ÿèµ›é¢˜è§£]]></title>
    <url>%2F2019%2F11%2F05%2F20191104%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ä¸ºä»€ä¹ˆè€æ˜¯è€ƒåŽŸé¢˜å•ŠðŸ˜¥ å¿«ä¹ä¼ é€’æ”¿æ²»æ­£ç¡®ç‰ˆæ‰¾åˆ°ä¸€ä¸ªè§„å¾‹,å‘çŽ°å¯¹äºŽæ¯ä¸€ä¸ªäºº$i$,å®ƒèƒ½ä½¿æ‰€æœ‰å’Œå®ƒçš„ç¼–å·mod $gcd$ç›¸åŒçš„æ•°å­—å˜çš„å¿«ä¹.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŒ‰ç…§$gcd$åˆ†ç»„,å…ˆæ±‚å‡º$n,m,k$ä¸‰ä¸ªäººçš„$gcd$,ç„¶åŽå¯¹äºŽæ¯ä¸€ä¸ªå¿«ä¹çš„äºº,æ ‡è®°ä¸€ä¸‹å®ƒæ‰€åœ¨çš„åˆ†ç»„å³$i$ $mod$ $gcd$.æœ€åŽæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­ä¸€ä¸‹æ˜¯ä¸æ˜¯æ‰€æœ‰çš„åˆ†ç»„éƒ½è¢«æ ‡è®°äº†å³å¯.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int M = 1e6 + 10;int n , m , k , b , g , t;long long base;bool used[M];int main ( void ) &#123; freopen ( "happy2.in" , "r", stdin ); freopen ( "happy2.out" ,"w",stdout); int T; scanf ( "%d" , &amp;T ); while ( T-- ) &#123; memset ( used , 0 , sizeof ( used ) ); scanf ( "%d%d%d" , &amp;n , &amp;m, &amp;k); base = __gcd ( n * 1ll , __gcd ( m * 1ll , k * 1ll ) ); if ( base &gt;= 10 * N ) &#123; puts ( "No" ); continue; &#125; scanf ( "%d" , &amp;b ); for ( int i = 1 ; i &lt;= b ; i++ ) &#123; int x; scanf ( "%d" , &amp;x ); used[x % base] = 1; &#125; scanf ( "%d" , &amp;g ); for ( int i = 1 ; i &lt;= g ; i++ ) &#123; int x; scanf ( "%d" , &amp;x ); used[x % base] = 1; &#125; scanf ( "%d" , &amp;t ); for ( int i = 1 ; i &lt;= t ; i++ ) &#123; int x; scanf ( "%d" , &amp;x ); used[x % base] = 1; &#125; bool flag = 1; for ( int i = 0 ; i &lt; base ; i++ ) &#123; if ( !used[i] ) &#123; flag = 0; break; &#125; &#125; if ( flag ) puts ( "Yes" ); else puts ( "No" ); &#125; return 0;&#125; å«Œç–‘äººæˆ‘ä»¬å…ˆè€ƒè™‘ä¸€ä¸ªæ˜¾ç„¶é”™è¯¯çš„è´ªå¿ƒ:æˆ‘ä»¬å¯¹äºŽæ¯ä¸ªäººè¢«ç»Ÿè®¡äº†å¤šå°‘æ¬¡ç›´æŽ¥å¼€æ¡¶ç»Ÿè®¡,ç„¶åŽæŠŠç»Ÿè®¡çš„ä¸ªæ•°ä»Žå¤§åˆ°å°æŽ’åºä¹‹åŽå¯ä»¥äºŒåˆ†æ‰¾åˆ°æ¯ä¸€ä¸ªéœ€è¦è¢«è®¡å…¥ç­”æ¡ˆçš„æ•°é‡.è²Œä¼¼ä¸€çœ¼å‘çŽ°ä¸äº†ä»€ä¹ˆé”™è¯¯ä½†æ˜¯è¿™ä¸ªçœŸçš„é”™äº†.æˆ‘ä»¬å‘çŽ°å¯¹äºŽä¸€ä¸ªäºº$i$,å¦‚æžœå®ƒè¦æž$j,k$çš„è¯,é‚£ä¹ˆå‡è®¾æœ‰ä¸€ä¸ªæŠ•ç¥¨,è¦æŠ•ç¥¨çš„äººæ˜¯$j,k$,é‚£ä¹ˆ$i$è¿™ä¸ªäººå°±ä¼šå¯¹è¿™ä¸ªè®¡æ•°æ–¹æ¡ˆè´¡çŒ®$2$çš„åŒæ„æ•°.è€Œè¿™æ˜¾ç„¶ä¸Žä¸€ä¸ªäººåªèƒ½å¯¹ä¸€ä¸ªæ–¹æ¡ˆæœ‰$1$çš„è´¡çŒ®ä¸ç›¸ç¬¦.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘æŠŠå¤šç®—çš„è¿™ä¸€éƒ¨åˆ†ä»ŽåŽŸç­”æ¡ˆä¸­å‡åŽ»,æˆ‘ä»¬å‘çŽ°å¯¹äºŽä¸€ä¸ªäºº,å®ƒåªèƒ½å¯¹æŸä¸€ç»„ç‰¹å®šçš„æ–¹æ¡ˆæœ‰$2$çš„èµžåŒæ•°,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨$map$å¥—ä¸€ä¸ª$pair$æ¥å¯¹å¤šç»Ÿè®¡çš„ç»„æ•°çš„è´¡çŒ®,ç„¶åŽæˆ‘ä»¬éåŽ†æ‰€æœ‰æˆ‘ä»¬æ ‡è®°äº†çš„ç»„åˆ,å¦‚æžœæœ¬æ¥å®ƒçš„èµžåŒæ•°$&gt;=p$å¹¶ä¸”å®ƒçš„èµžåŒæ•°$-$å¤šç»Ÿè®¡çš„èµžåŒæ•°å°äºŽ$p$çš„è¯,æˆ‘ä»¬å°±éœ€è¦è®©ç­”æ¡ˆå‡å°‘$1$.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 3e5 + 10;int n , p;int cnt[N] , rc[N];long long xdd;map &lt; pair &lt; int , int &gt; , int &gt; mp;signed main ( void ) &#123; freopen ( "suspect.in" , "r", stdin ); freopen ( "suspect.out" ,"w",stdout); scanf ( "%lld%lld" , &amp;n , &amp;p ); if ( p == 0 ) &#123; printf ( "%lld\n" , 1ll * n * ( n - 1 ) / 2 ); return 0; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int x , y; scanf ( "%lld%lld" , &amp;x , &amp;y ); cnt[x]++; cnt[y]++; if ( x &gt; y ) swap ( x , y ); rc[x]++; rc[y]++; mp[make_pair ( x , y )]++; &#125; sort ( cnt + 1 , cnt + 1 + n ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int l = i + 1 , r = n , ans = -1; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( cnt[mid] + cnt[i] &gt;= p ) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; if ( ans != -1 ) xdd = xdd + n - ans + 1; &#125; for ( map &lt; pair &lt; int , int &gt; , int &gt; :: iterator it = mp.begin () ; it != mp.end () ; it++ ) if ( rc[it -&gt; first.first] + rc[it -&gt; first.second] &gt;= p &amp;&amp; rc[it -&gt; first.first] + rc[it -&gt; first.second] - it -&gt; second &lt; p ) xdd--; printf ( "%lld\n" , xdd ); return 0;&#125; Xorå‘çŽ°åœ¨æŸä¸ªåŒºé—´ä¸­å‡ºçŽ°è¿‡å¶æ•°æ¬¡æ•°å­—çš„å¼‚æˆ–å’Œ=åŒºé—´ä¸­å‡ºçŽ°è¿‡çš„æ•°å­—çš„å¼‚æˆ–å’Œå¼‚æˆ–åŒºé—´ä¸­å‡ºçŽ°äº†å¥‡æ•°æ¬¡æ•°å­—çš„å¼‚æˆ–å’Œ.è€ŒæŸä¸ªåŒºé—´ä¸­å‡ºçŽ°äº†å¥‡æ•°æ¬¡æ•°å­—çš„å¼‚æˆ–å’Œæ˜¾ç„¶ç­‰äºŽè¿™ä¸ªåŒºé—´çš„å¼‚æˆ–å’Œ(å› ä¸ºå‡ºçŽ°äº†å¶æ•°æ¬¡çš„æ•°å­—å¼‚æˆ–èµ·æ¥çš„å€¼ä¸º$0$).è€Œå¼‚æˆ–å€¼æ˜¯æœ‰å¯å‡æ€§çš„,æ‰€ä»¥æˆ‘ä»¬å¯¹äºŽè¿™ä¸€éƒ¨åˆ†åªéœ€è¦ä¸€ä¸ªå‰ç¼€å¼‚æˆ–å’Œå°±å¯ä»¥ç»Ÿè®¡äº†.é‚£ä¹ˆæˆ‘ä»¬å‰©ä¸‹çš„é—®é¢˜å°±åªæœ‰å¦‚ä½•æ±‚åœ¨ä¸€ä¸ªåŒºé—´å†…å‡ºçŽ°è¿‡çš„æ•°å­—çš„å¼‚æˆ–å’Œ.è€Œè¿™ä¸ªä¸œè¥¿æ˜¾ç„¶ä¸æ€Žä¹ˆå¯æ±‚.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ç¦»çº¿çš„åšæ³•.æˆ‘ä»¬å¯¹äºŽæ‰€æœ‰çš„è¯¢é—®,å°†è¯¢é—®æŒ‰ç…§å³ç«¯ç‚¹ä»Žå°åˆ°å¤§æŽ’åº,ç„¶åŽæˆ‘ä»¬å¯¹äºŽæ¯ä¸ªæ•°å­—,ç»´æŠ¤ä¸€ä¸ªè¿™ä¸ªæ•°å­—ä¸Šä¸€æ¬¡å‡ºçŽ°çš„ä½ç½®(å¯ä»¥ç¦»æ•£åŒ–æˆ–è€…ç›´æŽ¥å¼€æ¡¶ç»Ÿè®¡).ç„¶åŽæˆ‘ä»¬åœ¨å³ç§»å³æŒ‡é’ˆçš„è¿‡ç¨‹ä¸­,å¯¹äºŽæ¯ä¸ªæ•°,æˆ‘ä»¬å°±åƒæ™®é€šçš„æ ‘çŠ¶æ•°ç»„ä¸€æ ·å¼‚æˆ–æ‰€æœ‰çš„æ•°å­—,è¿™ç›¸å½“äºŽç»´æŠ¤äº†ä¸€ä¸ªæ™®é€šçš„å¼‚æˆ–å’Œ.ä½†æ˜¯æˆ‘ä»¬å¦‚æžœçŽ°åœ¨è¦å¼‚æˆ–çš„è¿™ä¸ªæ•°å­—ä¹‹å‰å‡ºçŽ°è¿‡,é‚£ä¹ˆæˆ‘ä»¬æŠŠè¿™ä¸ªæ•°å­—ä»Žä¸Šä¸€æ¬¡å‡ºçŽ°çš„ä½ç½®å†å¼‚æˆ–ä¸€æ¬¡è¿™ä¸ªæ•°(è¿™æ ·å¯ä»¥æŠŠå¤šæ¬¡å‡ºçŽ°çš„å€¼å¼‚æˆ–æŽ‰).12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w; &#125;const int N = 3e5 + 10;int n , m;int val[N] , tree[N] , fro[N];map &lt; int , int &gt; flag;struct Que &#123; int l , r; int id;&#125; query[N];int ans[N];inline bool cmp ( Que x , Que y ) &#123; return x.r &lt; y.r;&#125;inline int lowbit ( int x ) &#123; return x &amp; -x;&#125; inline void add ( int pos , int x ) &#123; while ( pos &lt;= n ) &#123; tree[pos] ^= x; pos += lowbit ( pos ); &#125; return;&#125;inline int check ( int pos ) &#123; int res = 0; while ( pos ) &#123; res ^= tree[pos]; pos -= lowbit ( pos ); &#125; return res;&#125;int main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; val[i] = read (); fro[i] = fro[i - 1] ^ val[i]; &#125; m = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; query[i].l = read () , query[i].r = read (); query[i].id = i; &#125; sort ( query + 1 , query + 1 + m , cmp ); int now = 0; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; while ( now &lt; query[i].r ) &#123; now++; if ( !flag[val[now]] ) flag[val[now]] = now; else &#123; add ( flag[val[now]] , val[now] ); flag[val[now]] = now; &#125; add ( now , val[now] ); &#125; ans[query[i].id] = check ( query[i].r ) ^ check ( query[i].l - 1 ) ^ fro[query[i].r] ^ fro[query[i].l - 1]; &#125; for ( int i = 1 ; i &lt;= m ; i++ ) printf ( "%d\n" , ans[i] ); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ¨¡æ‹Ÿèµ›é¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æé«˜å¤±è”æµ‹D9]]></title>
    <url>%2F2019%2F11%2F04%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E8%81%94%E6%B5%8BD9%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€ è”¡è€æ¿è¿™é“é¢˜é¢˜è§£é‡Œçš„äºŒåˆ†çš„$check$åˆ°åº•æ˜¯æ€Žä¹ˆæƒ³å‡ºæ¥çš„å•Šâ€¦.æˆ‘ä»¬è€ƒè™‘åˆ°å¯¹äºŽæŸä¸ªæ•°$i$,åœ¨å®ƒçš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸‹,å¯¹äºŽæŸä¸ªç¡®å®šçš„$2^i$çš„ç‰©å“,ä½ å–è¿˜æ˜¯ä¸å–æ˜¯ä¸å½±å“$2^j(j&lt;i)$çš„ç‰©å“æ‹¿è¿˜æ˜¯ä¸æ‹¿çš„.ç„¶åŽå‘çŽ°æ˜¾ç„¶é’±æ•°è¿™ä¸ªä¸œè¥¿æ˜¯æ»¡è¶³å•è°ƒæ€§çš„æ‰€ä»¥æ˜¾ç„¶å¯ä»¥çˆ¬å±±æ‰€ä»¥æˆ‘ä»¬å¯ä»¥äºŒåˆ†é’±æ•°ç„¶åŽ$check$.ä½†æ˜¯å‘çŽ°è¿™ä¸ªä¸œè¥¿è²Œä¼¼ä¸æ€Žä¹ˆå¥½$check$.æˆ‘ä»¬æƒ³ä¸€ä¸‹æˆ‘ä»¬ä¹‹å‰è¯´çš„æ€§è´¨,å¯ä»¥å‘çŽ°å¯¹äºŽæ¯ä¸€ä½,å¦‚æžœåœ¨äºŒè¿›åˆ¶è¡¨ç¤ºä¸‹æ˜¯$1$,é‚£ä¹ˆå¦‚æžœä¸æ‹¿å°±ä¸€å®šäºäº†(ç¡®ä¿¡).ä½†æ˜¯æ‹¿çš„è¯åªæ‹¿è¿™ä¸ªä»·æ ¼çš„ä¸œè¥¿æ˜¾ç„¶ä¸ä¼šæ›´ä¼˜.æˆ‘ä»¬æƒ³ä¸€ä¸‹,å¯¹äºŽè¿™ä¸€ä½ä¹‹å‰çš„æŸä¸€ç»´,æˆ‘ä»¬é€‰ä¹‹åŽ(æˆ–è€…æ ¹æœ¬æ²¡é€‰)å‰©ä¸‹çš„,å¦‚æžœç›´æŽ¥æ‰”æŽ‰æ˜¾ç„¶ä¼šæµªè´¹æŽ‰.ç„¶åŽæˆ‘ä»¬åˆä¼šå‘çŽ°,å› ä¸ºæ¯ä¸ªä¸œè¥¿çš„ä»·æ ¼éƒ½æ˜¯ç”¨äºŒçš„å¹‚æ¬¡æ–¹è¡¨ç¤ºçš„,è€Œä¸¤ä¸ªä»·æ ¼ä¸º$2^i$çš„ç‰©å“å¯ä»¥åˆå¹¶ä¸ºä¸€ä¸ª$2^{i+1}$çš„ç‰©å“.è€Œè¿™ä¸ªæ“ä½œæ˜¾ç„¶éœ€è¦æˆ‘ä»¬æŒ‰ç…§é’±æ•°ä»Žå°åˆ°å¤§è¿›è¡Œ.é‚£ä¹ˆæˆ‘ä»¬çš„è´ªå¿ƒæ€è·¯å°±æ¯”è¾ƒæ˜Žæ˜¾äº†,æˆ‘ä»¬å¯¹äºŽæ¯ä¸€ä¸ªäºŒåˆ†å‡ºæ¥çš„é’±æ•°$mid$,æˆ‘ä»¬ä»Žä½Žåˆ°é«˜è€ƒè™‘è¿™ä¸ªé’±æ•°çš„æ¯ä¸€ä½,å¦‚æžœæ˜¯$1$çš„è¯,é‚£ä¹ˆæˆ‘ä»¬å°±é€‰æ‹©å½“å‰ç»´æŠ¤çš„æœ€å¤§çš„ä¸€ä¸ªå€¼.ç„¶åŽæŠŠå…¶ä»–çš„ä»Žå¤§åˆ°å°ä¸¤ä¸¤åˆå¹¶æˆä¸€ä¸ªæ–°çš„.è€Œå¯¹äºŽäºŒè¿›åˆ¶è€ƒè™‘ä¸‹æ˜¯$0$çš„æƒ…å†µ,æˆ‘ä»¬ç›´æŽ¥åˆå¹¶å³å¯. å”¯ä¸€ç¿é…±æˆ‘ä»¬è®¾$f_{l,r}$è¡¨ç¤º$l,r$è¿™æ®µåŒºé—´ä¸€å…±æœ‰å¤šå°‘ç§æ–¹æ¡ˆ,è€Œä¸”$l-1,r+1$æ˜¯è¾¹ç•Œæˆ–è€…å¤§äºŽå…¶ä¸­çš„æ‰€æœ‰æ•°å­—.é‚£ä¹ˆè½¬ç§»çš„è¯,æˆ‘ä»¬å¯ä»¥è€ƒè™‘åœ¨$l,r$ä¸­æžšä¸¾ä¸€ä¸ª$k$,ä½¿å¾—$l+r_k=k$æˆ–è€…$k+r_k=r$,ç„¶åŽè½¬ç§»å°±å¥½äº†.ä½†æ˜¯è¿™æ ·è½¬ç§»çš„è¯å‘çŽ°æ—¶é—´å¤æ‚åº¦æ˜¯$O(n^3)$çš„,æˆ‘ä»¬è¿˜å¾—è€ƒè™‘æ€Žä¹ˆä¼˜åŒ–:æˆ‘ä»¬å‘çŽ°,å¯¹äºŽæŸä¸ªç¡®å®šçš„$k$,å®ƒåªèƒ½è½¬ç§»åˆ°$l=k-r_k$æˆ–è€…$r=k+r_k$çš„åŒºé—´.æ‰€ä»¥æˆ‘ä»¬ä¸å†æžšä¸¾$k$,è€Œæ˜¯å¯¹äºŽæ¯ä¸€ä¸ª$k$,æˆ‘ä»¬éƒ½é€‰æ‹©æžšä¸¾å®ƒèƒ½è½¬ç§»åˆ°å“ªé‡Œ.æ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$. æ³¢æ³¢ðŸ®è”¡è€æ¿ç‰›é€¼! å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®è½¬ææ’’èŠ±]]></title>
    <url>%2F2019%2F11%2F03%2F%E6%99%AE%E8%BD%AC%E6%8F%90%E6%92%92%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€(ä½†æ˜¯æˆ‘è¿˜æ˜¯è¦è¯´ä¸€å¥å‘¨é˜ŸðŸ®ðŸº!) å®Œç»“æ’’èŠ±qwqâ€¦. å˜´å¼ºçŽ‹è€…é¦–å…ˆå¯ä»¥è®¾ä¸€ä¸ª$k=\frac{n}{m}$è¡¨ç¤ºæ¯ä¸€ç»„çš„äººæ•°.ç„¶åŽæˆ‘ä»¬æŠŠæ‰€æœ‰é˜Ÿä¼æŒ‰ç…§é˜Ÿé•¿çš„èƒ½åŠ›å€¼ä»Žå°åˆ°å¤§æŽ’åº(å³æ ¹æ®é˜Ÿé•¿çš„æŽ’åä»Žå¤§åˆ°å°æŽ’åº).ç„¶åŽæˆ‘ä»¬è€ƒè™‘èƒ½åŠ›å€¼æŽ’åæœ€å¤§çš„é˜Ÿé•¿æ€Žä¹ˆå–.å‘çŽ°æ˜¾ç„¶åªèƒ½åŽ»å–æŽ’åæ¯”$a_i$é åŽçš„,æ–¹æ¡ˆä¸º $\dbinom{n-a_i}{k-1}$ç„¶åŽæˆ‘ä»¬å†åŽ»è€ƒè™‘èƒ½åŠ›å€¼æŽ’åç¬¬äºŒå¤§çš„é˜Ÿä¼,å‘çŽ°ä¸ä»…åªèƒ½åŽ»å–æŽ’åæ¯”$a_i$é åŽçš„,è€Œä¸”ä¹Ÿä¸èƒ½åŽ»å–å·²ç»è¢«æŽ’åç¬¬ä¸€å¤§çš„é˜Ÿä¼å–è¿‡çš„äºº,é‚£ä¹ˆæ–¹æ¡ˆä¸º$\dbinom{n-a_i-k}{k-1}$åŒæ ·çš„,ä»¥æ­¤ç±»æŽ¨,æœ€åŽçš„ç­”æ¡ˆå°±æ˜¯$\prod\limits_{i=1}^n\dbinom{n-a_i-k \times (i - 1) }{k-1}$ æ•°ç»„å‘çŽ°é¢˜ç›®ä¸­æœ‰ä¸€ä¸ªçªç ´ç‚¹å°±æ˜¯åªæœ‰$1$å’Œ$2$ä¸¤ç§æ•°å­—.ç„¶åŽæˆ‘ä»¬å‘çŽ°å¦‚ä¸‹ä¸€ä¸ªç»“è®º:æˆ‘ä»¬æ‰¾åˆ°æŸä¸€ä¸ª$1$,ç„¶åŽè®¾å®ƒçš„ä½ç½®ä¸º$i$,é‚£ä¹ˆ$[1,sum_n-sum_{i-1}]$èŒƒå›´å†…çš„æ•°å­—éƒ½ä¸€å®šå¯ä»¥è¢«å–åˆ°.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä»Žå·¦åˆ°å³å†ä»Žå³åˆ°å·¦åˆ†åˆ«æ‰¾åˆ°ç¬¬ä¸€ä¸ª$1$,ç„¶åŽæŠŠå¯ä»¥åˆ°è¾¾çš„æ•°æ ‡è®°èµ·æ¥.ç„¶åŽæˆ‘ä»¬å†æ‰¾åˆ°ä¹‹å‰æ²¡æœ‰è¢«$1$ä¹‹åŽçš„æ•°å­—æ ‡è®°è¿‡çš„$2$çš„æ•°é‡$num$,é‚£ä¹ˆæ‰€æœ‰èƒ½åˆ°è¾¾çš„æ•°çš„å¹¶é›†å°±æ˜¯ [1,max(sum_n-sum_{i-1})(a_i=1)]âˆªmax(sum_n-sum_{i-1})(a_i=1)+2 \times k (k]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2019]Elaxiaçš„è·¯çº¿]]></title>
    <url>%2F2019%2F11%2F01%2FSDOI2019-Elaxia%E7%9A%84%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[ä¼ é€é—¨ é¦–å…ˆæˆ‘ä»¬å¯ä»¥çŸ¥é“å¦‚æžœæŠŠæ‰€æœ‰æœ€çŸ­è·¯ä¸Šçš„è¾¹æŒ‘å‡ºæ¥ï¼Œå†æŒ‰ç…§æœ€çŸ­è·¯ä¸­$dis$æ•°ç»„çš„é€’æŽ¨å…³ç³»ç»™å®ƒåŠ ä¸Šæ–¹å‘çš„è¯è¿™å°±æ˜¯ä¸€ä¸ªæœ‰å‘æ— çŽ¯å›¾ã€‚è€Œå¦‚æžœæŠŠæ‰€æœ‰ä¸¤ä¸ªæœ€çŸ­è·¯çš„å…¬å…±è¾¹æŒ‘å‡ºæ¥çš„è¯ï¼Œè¿™ä¸ªæœ‰å‘æ— çŽ¯å›¾ä¸­çš„æœ€é•¿é“¾å°±æ˜¯ç­”æ¡ˆã€‚å¹¶ä¸”åˆ¤æ–­ä¸€æ¡è¾¹åœ¨æœ€çŸ­è·¯ä¸Šçš„æ–¹å¼å°±æ˜¯$dis[sâ†’u]+w(u,v)+dis[uâ†’t]=dis[sâ†’t]dis[sâ†’u]+w(u,v)+dis[uâ†’t]=dis[sâ†’t]$ã€‚å¹¶ä¸”å› ä¸ºè¿™æ˜¯æ— å‘å›¾ï¼Œæ‰€ä»¥æ±‚ä»»æ„ä¸€ä¸ªç‚¹åˆ°ç»ˆç‚¹çš„è·ç¦»åªéœ€è¦ä»¥ç»ˆç‚¹ä¸ºèµ·ç‚¹å†è·‘ä¸€éæœ€çŸ­è·¯å°±å¯ä»¥äº†ã€‚éœ€è¦æ³¨æ„çš„é—®é¢˜å°±æ˜¯å…¬å…±è·¯å¾„ä»Žä¸åŒçš„æ–¹å‘ç»è¿‡ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œæ‰€ä»¥éœ€è¦æŠŠä¸€å¯¹èµ·ç‚¹å’Œç»ˆç‚¹å€’è¿‡æ¥å†åšä¸€éã€‚ å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ ¡å†…ACMèµ›é¢˜è§£é€‰è®²]]></title>
    <url>%2F2019%2F10%2F30%2F%E6%A0%A1%E5%86%85ACM%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[æ ¡å†…é¢˜ç›®å°±ä¸å…¬å¼€é¢˜é¢å•¦x æ•°å­¦é¦–å…ˆæˆ‘ä»¬ç”¨äºŒé¡¹å¼å®šç†å±•å¼€ä¸€ä¸‹å¼å­. E((x-E(x))^k)=\sum_{i=0}^k[\dbinom{k}{i} \times (-1)^{k-i} \times E(x^i) \times E^{k-i}(x)]æœ‰å› ä¸º$x$æ˜¯ä¸€ä¸ªå¸¸æ•°,åˆ™$E(x)=x$,é‚£ä¹ˆæ˜¾ç„¶$E^{k-i}(x)={(\dfrac{1}{2})}^{k-i}$,é‚£ä¹ˆé—®é¢˜å°±åªå‰©ä¸‹äº†$E(x^i)$æ€Žä¹ˆæ±‚äº†.è€Œå¯¹äºŽ$E(x^i)$,æˆ‘ä»¬å¯ä»¥è®¾å‡½æ•°$f(x)=x^i$,ç„¶åŽè€ƒè™‘å®ƒçš„å›¾åƒ.å› ä¸º$x^i$çš„æœŸæœ›å¯¹åº”çš„å°±æ˜¯å›¾åƒä¸­çš„$y$,æ‰€ä»¥æœ‰$1 \times E(x^i) = S$.æ‰€ä»¥æˆ‘ä»¬è¦è®¡ç®—çš„å°±åªå‰©ä¸‹å‡½æ•°$f(x)=x^i$åœ¨$[0,1]$ä¸Šçš„å›¾åƒçš„é¢ç§¯äº†.ç„¶åŽè¿™ä¸ªä¸œè¥¿â€¦.å¯ä»¥ç”¨ç§¯åˆ†åŽ»æ±‚å¾—: \int_{0}^{1}x^i\,dx = \dfrac{1^{i+1}}{i+1} - \dfrac{0^{i+1}}{i+1} = \frac{1}{i+1}è®¡ç®—å‡º$E(x^i)$åŽ,å°†è¡¨è¾¾å¼å¸¦å›žåŽŸå¼åŽå¾—åˆ° ans=\sum_{i=0}^k[\dbinom{k}{i} \times (-1)^{k-i} \times \frac{1}{i+1} \times {(\dfrac{1}{2})}^{k-i}]è‹±è¯­å‘çŽ°ç›´æŽ¥åšçš„è¯è²Œä¼¼æ²¡ä»€ä¹ˆæ€è·¯â€¦.æ˜¾ç„¶è¿™é“é¢˜å¯ä»¥å…ˆæŠŠè¯¢é—®ç¦»çº¿å‡ºæ¥,ç„¶åŽæœ‰ä¸€ä¸ªæ˜¾ç„¶é”™è¯¯çš„è´ªå¿ƒå°±æ˜¯æ¯æ¬¡é€‰ä¸€ä¸ªå¶å­èŠ‚ç‚¹çš„å€¼(æŒ‡ä»Žæ ¹èŠ‚ç‚¹åˆ°æŸä¸ªå¶å­çš„å‰ç¼€å’Œ)æœ€å¤§çš„.è¿™æ ·åšæ˜¾ç„¶é”™è¯¯,å› ä¸ºæ¯ä¸ªç‚¹å¯¹ç­”æ¡ˆçš„è´¡çŒ®åªèƒ½è¢«ç»Ÿè®¡ä¸€æ¬¡,æ‰€ä»¥æˆ‘ä»¬è¦è€ƒè™‘æ€Žä¹ˆè°ƒæ•´è¿™ä¸ªè´ªå¿ƒçš„æ€è·¯.é€šè¿‡è§‚å¯Ÿå‘çŽ°,å¯¹äºŽæŸä¸€ä¸ªç‚¹$i$,å®ƒçš„å€¼åªèƒ½è¢«è®¡ç®—åˆ°å®ƒæ‰€æœ‰çš„å„¿å­ä¸­è¾¹æƒæƒé‡æ±‚å¤§çš„é‚£ä¸ªå„¿å­,è€Œå¯¹äºŽå®ƒå…¶ä»–çš„å„¿å­,å®ƒçš„è´¡çŒ®ä¸º$0$.æ‰€ä»¥æˆ‘ä»¬çš„æ€è·¯ç±»ä¼¼é‡é“¾å‰–åˆ†ä¸­çš„å¯»æ‰¾é‡å„¿å­,æˆ‘ä»¬å¯¹äºŽæ¯ä¸ªéžå¶èŠ‚ç‚¹$p$,éƒ½åœ¨å®ƒçš„å­æ ‘ä¸­æ‰¾åˆ°ä¸€ä¸ªæƒé‡æœ€å¤§çš„å­æ ‘,ç„¶åŽæŠŠå®ƒçš„è¾¹æƒåŠ å…¥åˆ°å®ƒçš„é‡å„¿å­ä¸­å³å¯.å¬è¯´è¿™ä¸œè¥¿å«åšé•¿é“¾å‰–åˆ† æ”¿æ²»çœ‹å®Œé¢˜ä¹‹åŽé¦–å…ˆæƒ³åˆ°çš„å°±æ˜¯å¯¹äºŽæ¯ä¸ªçŠ¯ç½ªå›¢ä¼™ä¸¤ä¸¤è€ƒè™‘åŒ…å«å…³ç³»ç„¶åŽå†ç»Ÿè®¡ç­”æ¡ˆ,ä½†æ˜¯è¿™æ ·çš„è¯æ—¶é—´å¤æ‚åº¦ä¸Šç•Œæ˜¯$O(2^{40})$,æ— æ³•é€šè¿‡æœ¬é¢˜.ç„¶åŽæˆ‘ä»¬å‘çŽ°æ‘åº„çš„æ•°é‡åªæœ‰$20$ä¸ª,è€Œä¸”æ˜¾ç„¶å¦‚æžœæœ‰ä¸¤ä¸ªå›¢ä¼™,ä»–ä»¬çš„æŽ§åˆ¶çš„æ‘åº„çš„çŠ¶æ€ä¸€æ ·,é‚£ä¹ˆè¿™ä¸¤ä¸ªå›¢ä¼™çš„æ”¶å…¥å’Œæ”¯å‡ºä¹Ÿä¸€å®šæ˜¯ä¸€æ ·çš„.é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è€ƒè™‘æ ¹æ®æ¯ä¸ªå›¢ä¼™çš„æŽ§åˆ¶æ‘åº„çš„äºŒè¿›åˆ¶å¼€æ¡¶,ç„¶åŽæ ¹æ®$S_i$ç»Ÿè®¡æ¯ä¸ªå›¢ä¼™çš„ç­”æ¡ˆ.ä¸éš¾å‘çŽ°,å¯¹äºŽæŸä¸‰ä¸ªå›¢ä¼™(æˆ‘ä»¬è®¾ä»–ä»¬æŽ§åˆ¶çš„æ‘åº„çš„äºŒè¿›åˆ¶è¡¨ç¤ºåˆ†åˆ«ä¸º$i,j,k$),é‚£ä¹ˆå¦‚æžœæœ‰$i \subsetneqq j , j \subsetneqq k$,é‚£ä¹ˆä¸€å®šæœ‰$i \subsetneqq k$.è€Œå¦‚æžœä¸€ä¸ªé›†åˆ$i$æ˜¯$j$çš„å­é›†çš„è¯,é‚£ä¹ˆå¿…è¦æ¡ä»¶å³åœ¨äºŒè¿›åˆ¶è¡¨ç¤ºä¸‹$i$ä¸­$1$çš„ä¸ªæ•°å°äºŽç­‰äºŽäºŒè¿›åˆ¶è¡¨ç¤ºä¸‹$j$ä¸­$1$çš„ä¸ªæ•°.é‚£ä¹ˆæˆ‘ä»¬å¦‚æžœè€ƒè™‘æŒ‰ç…§äºŒè¿›åˆ¶è¡¨ç¤ºä¸‹$1$çš„ä¸ªæ•°æ¥åˆ’åˆ†é›†åˆçš„$rank$çš„è¯,é‚£ä¹ˆæ˜¾ç„¶æŸä¸€ä¸ªçŠ¶æ€$i$ä¸€å®šä¼šè¢«æ‰€æœ‰çš„äºŒè¿›åˆ¶ä¸‹$1$çš„ä¸ªæ•°å°äºŽå®ƒçš„å­é›†è½¬ç§»åˆ°,ä½†æ˜¯è¿™æ ·ç›´æŽ¥æžšä¸¾çš„è¯æ˜¯$3^n$çš„.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘åˆ°å¯ä»¥ç”¨$FMT$ä¼˜åŒ–.å› ä¸º$FMT$ä¸ºé«˜ç»´å‰ç¼€å’Œ,æˆ‘ä»¬æ¯ä¸€æ¬¡å¯¹äºŽæŸä¸€ä¸ªçŠ¶æ€$j$,æ˜¾ç„¶$inn_j=inn_j+=inn_{j xor ( 1 &lt;&lt; i )} ((1&lt;&lt;i) and j==1)$.è€Œå¯¹äºŽæ”¯å‡ºçš„æƒ…å†µ.å¯ä»¥å‘çŽ°,å¯¹äºŽæŸä¸ªçŠ¶æ€$i$,å®ƒçš„æ”¯å‡ºæ¬¡æ•°å³ä¸ºåŒ…å«å®ƒçš„é›†åˆçš„ä¸ªæ•°,è€ŒåŒ…å«å®ƒçš„é›†åˆçš„ä¸ªæ•°æ˜¾ç„¶ä¹Ÿå¯ä»¥ç”¨$FMT$åŽ»æ±‚è§£(ä½†æ˜¯æ³¨æ„è½¬ç§»çš„æ—¶å€™æ˜¯ç”±å®ƒè½¬ç§»åˆ°å®ƒçš„å­é›†)å³åœ¨è¿›è¡Œ$FMT$æ—¶è¦ç”¨å¼‚æˆ–ä¹‹åŽçš„çŠ¶æ€åŽ»æ›´æ–°ä¹‹å‰çš„çŠ¶æ€. éŸ³ä¹é¦–å…ˆå‘çŽ°ç›´æŽ¥ä½¿ç”¨åŒºé—´çš„æœ€å¤§å€¼åŽ»å‡åŽ»åŒºé—´çš„æœ€å°å€¼åŽ»æ›´æ–°ç­”æ¡ˆçš„è¯æ˜¾ç„¶æ˜¯ä¸å¯¹çš„,è€ƒè™‘æ€Žä¹ˆåŽ»è°ƒæ•´.å‘çŽ°å¦‚æžœæˆ‘ä»¬ä½¿ç”¨çº¿æ®µæ ‘çš„è¯,é‚£ä¹ˆå¯¹äºŽæŸä¸ªéžå¶èŠ‚ç‚¹,é‚£ä¹ˆå®ƒçš„ç­”æ¡ˆå¯èƒ½æ˜¯å®ƒå·¦å­æ ‘çš„ç­”æ¡ˆ,ä¹Ÿæœ‰å¯èƒ½æ˜¯å®ƒå³å­æ ‘çš„ç­”æ¡ˆ.ä½†æ˜¯å¯¹äºŽåˆå¹¶çš„è¯è²Œä¼¼ç›´æŽ¥ä¸èƒ½ä¸¤è¾¹çš„ç­”æ¡ˆå–ä¸€ä¸ª$max$.æˆ‘ä»¬å‘çŽ°,å¯¹äºŽè¿™ä¸ªèŠ‚ç‚¹å·¦å­æ ‘ä¸­çš„æ¯ä¸€ä¸ªå€¼,é‚£ä¹ˆå³å­æ ‘ä¸­çš„ä»»ä½•ä¸€ä¸ªæ¯”å·¦å­æ ‘ä¸­æŸä¸€ä¸ªå€¼å¤§çš„èŠ‚ç‚¹éƒ½å¯ä»¥åŽ»æ›´æ–°è¿™ä¸€ä¸ªèŠ‚ç‚¹.æ‰€ä»¥,æˆ‘ä»¬ç›´æŽ¥åŽ»ç”¨å³å­æ ‘ä¸­çš„ä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹,åŽ»æ›´æ–°å·¦å­æ ‘ä¸­çš„ä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹æ˜¯æ²¡æœ‰é—®é¢˜çš„.é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥åˆ†åˆ«ä½¿ç”¨å·¦å­æ ‘ä¸­çš„æœ€å°å€¼å’Œå³å­æ ‘ä¸­çš„æœ€å¤§å€¼åŽ»ç»´æŠ¤è¿™ä¸ªä¸¤é¢—å­æ ‘åˆå¹¶æ—¶çš„ç­”æ¡ˆ.è€Œå¯¹äºŽå·¦å­æ ‘çš„ç­”æ¡ˆæˆ–è€…å³å­æ ‘çš„ç­”æ¡ˆå¯èƒ½ä¼šå¤§äºŽå·¦å³ä¸¤é¢—å­æ ‘åˆå¹¶æ—¶çš„ç­”æ¡ˆçš„æƒ…å†µ,æˆ‘ä»¬å¯ä»¥å¯¹äºŽå·¦å­æ ‘çš„ç­”æ¡ˆ,å³å­æ ‘çš„ç­”æ¡ˆå’Œå³å­æ ‘çš„æœ€å¤§å€¼-å·¦å­æ ‘çš„æœ€å°å€¼åŽ»å–ä¸€ä¸ª$max$å³ä¸ºè¿™ä¸ªèŠ‚ç‚¹çš„$ans$å€¼.æ‰€ä»¥æˆ‘ä»¬éœ€è¦ç»´æŠ¤ä¸€é¢—çº¿æ®µæ ‘,åˆ†åˆ«ç»´æŠ¤åŒºé—´æœ€å¤§/æœ€å°å€¼ä»¥åŠæˆ‘ä»¬è¦æ±‚çš„ç­”æ¡ˆå³å¯ç®€å•çº¿æ®µæ ‘ç»ƒä¹ é¢˜. ä½“è‚²æˆ‘ä»¬å‘çŽ°æ— è§£çš„æƒ…å†µåªå­˜åœ¨äºŽèµ·ç‚¹ä¼šé‡å¤çš„æƒ…å†µ,ä½†æ˜¯é¢˜ç›®ä¸­æ˜Žç¡®ç»™å‡ºäº†èµ·ç‚¹å’Œç»ˆç‚¹çš„åæ ‡ä¸ä¼šé‡å¤,æ‰€ä»¥æ²¡æœ‰æ— è§£çš„æƒ…å†µ.è€Œä¸”ACMä½ åªåˆ¤æ— è§£ä¹Ÿæ²¡åˆ†ç„¶åŽæˆ‘ä»¬å‘çŽ°,å¦‚æžœæˆ‘ä»¬æŠŠèµ·ç‚¹å’Œç»ˆç‚¹éƒ½æŒ‰ç…§åæ ‡ä»Žå°åˆ°å¤§æŽ’åºä¹‹åŽ,æˆ‘ä»¬ç”¨æœ€å°çš„èµ·ç‚¹åŽ»å¯¹åº”æœ€å°çš„ç»ˆç‚¹çš„è¯,å‘çŽ°è¿™ä¸ªèµ·ç‚¹æ˜¯æœ€å°çš„,é‚£ä¹ˆåæ ‡æ¯”å®ƒå¤§çš„ç‚¹åˆ°è¿™äº›ç‚¹çš„ç»ˆç‚¹çš„è·¯å¾„ä¸­ä¸€å®šæœ‰ä¸€æ®µè·¯ç¨‹ä¸ä¼šè¢«åŒ…å«,å¯¹äºŽç»ˆç‚¹æ¥è¯´åŒç†(å¦‚ä¸‹å›¾) æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æŽ¥æŽ’å®Œåºä¹‹åŽæ‰¾ç­”æ¡ˆå³å¯. ç¾Žæœ¯æ˜¾ç„¶,æˆ‘ä»¬å¯ä»¥è®¾$f_{i,j,01}$è¡¨ç¤ºçŽ°åœ¨ä»¥åŠè€ƒè™‘äº†$i$ä¸ªæ ¼å­,å…¶ä¸­æœ‰$j$ä¸ªæ ¼å­çš„é¢œè‰²å’Œè¿™ä¸ªæ ¼å­çš„ä¸Šä¸€ä¸ªçš„é¢œè‰²ä¸ä¸€æ ·,å¹¶ä¸”è¿™ä¸ªæ ¼å­çš„é¢œè‰²å’Œå®ƒçš„ä¸Šä¸€ä¸ªçš„é¢œè‰²ä¸€ä¸ä¸€æ ·.é‚£ä¹ˆå¦‚æžœè¿™ä¸ªæ ¼å­çš„é¢œè‰²å’Œä¹‹å‰çš„ä¸€æ ·çš„è¯,å°±åªèƒ½ç»§æ‰¿å‰$i-1$ä¸ªæ ¼å­çš„ç­”æ¡ˆ,è€Œå¦‚æžœè¿™ä¸ªæ ¼å­å’Œè¿™ä¸ªæ ¼å­çš„å‰ä¸€ä¸ªæ ¼å­çš„é¢œè‰²ä¸ä¸€æ ·çš„è¯,é‚£ä¹ˆè¿™ä¸ªæ ¼å­å°±æœ‰$m-1$ç§æ¶‚è‰²æ–¹æ¡ˆ.æ ¹æ®ä¸Šè¾¹æ‰€è¯´çš„,çŠ¶æ€è½¬ç§»æ–¹ç¨‹å°±å¾ˆæ˜Žæ˜¾äº†: \begin{cases}f_{i,j,0}=f_{i-1,j,0}+f_{i-1,j,1}\\f_{i,j,1}=(f_{i-1,j-1,0}+f_{i-1,j-1,1}) \times (m-1)\end{cases}å¬è¯´è¿˜æœ‰ç»„åˆæ•°å­¦çš„åšæ³•,ä½†æ˜¯æˆ‘ä¸ä¼š ç”Ÿç‰©é¦–å…ˆå‘çŽ°è¿™é“é¢˜çš„æ•°æ®èŒƒå›´éžå¸¸çš„è¿·æƒ‘,å› ä¸º$n$åªæœ‰$26$è€Œä¸”$a,b,c$åªæœ‰$9$,æ‰€ä»¥åªè¦$v$å¤§äºŽ$26 \times 9$,æˆ‘ä»¬å°±ä¸å¦¨é’¦å®š$v=26 \times 9$.è¿™æ ·ä¹‹åŽå‘çŽ°æ··ä¹±åº¦å¯ä»¥ç›´æŽ¥ç”¨ä¸€ç»´è¡¨ç¤ºå‡ºæ¥,æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹$DP$.ç›´è§‰$DP$çš„è¯å¯ä»¥è®¾$f_{i,j}$è¡¨ç¤ºå·²ç»è€ƒè™‘äº†å‰$i$ç§ç›¸å¯¹æ€§çŠ¶,æ­¤æ—¶çš„æ··ä¹±åº¦æ˜¯$j$çš„æ—¶å€™çš„æ–¹æ¡ˆæ•°.ä½†æ˜¯è¿™æ ·çš„è¯æˆ‘ä»¬ä¼šå‘çŽ°ä¸€ä¸ªé—®é¢˜,å°±æ˜¯æˆ‘ä»¬å¯èƒ½ä¼šæŠŠåŒä¸€ç§åŸºå› åž‹åœ¨çˆ¶æœ¬çš„è´¡çŒ®å’Œåœ¨æ¯æœ¬çš„è´¡çŒ®ç®—é‡,è€Œä¸”ä¹Ÿä¸å¥½åŽ»é‡.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘åŠ ä¸€ç»´çŠ¶æ€:æˆ‘ä»¬è®¾$f_{i,j,k}$è¡¨ç¤ºå·²ç»è€ƒè™‘äº†å‰$i$ç§ç›¸å¯¹æ€§çŠ¶,å…¶ä¸­çˆ¶æœ¬è´¡çŒ®çš„æ··ä¹±åº¦ä¸º$j$,æ¯æœ¬è´¡çŒ®çš„æ··ä¹±åº¦ä¸º$k$æ—¶çš„æ–¹æ¡ˆæ•°,åœ¨è½¬ç§»çš„æ—¶å€™ç›´æŽ¥è€ƒè™‘çˆ¶æœ¬çš„æ€§çŠ¶å·²ç»æ¯æœ¬çš„æ€§çŠ¶å³å¯. ä¿¡æ¯çœ‹ä¸ŠåŽ»ä¸å¥½å†™å®žé™…ä¸Šè¿˜æŒºç®€å•çš„æ¨¡æ‹Ÿæˆ‘ä¸ç®¡è¿™é“é¢˜æˆ‘ä¸€å®šè¦æ”¾ä»£ç (å…¶å®žæ˜¯ä¸ºäº†å‡‘å­—æ•°) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pii std::pair&lt;int,int&gt;#define pll std::pair&lt;ll,ll&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125;template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125;/**********************************************************************************************************************************************************************************************************************************************************************/const int N = 1005;int n , m , sx , sy;int indeque[N][N];char mp[N][N] , operation[N];inline void init () &#123; read ( n , m ); F ( i , 1 , n ) scanf ( "%s" , mp[i] + 1 ); F ( i , 1 , n ) F ( j , 1 , m ) if ( mp[i][j] == '@' ) &#123; mp[i][j] = '.'; sx = i , sy = j; break; &#125; scanf ( "%s" , operation + 1 ); return;&#125;inline void FindDir ( int &amp;dx , int &amp;dy , char op ) &#123; if ( op == 'W' ) dx = -1 , dy = 0; else if ( op == 'A' ) dx = 0 , dy = -1; else if ( op == 'S' ) dx = 1 , dy = 0; else if ( op == 'D' ) dx = 0 , dy = 1; return;&#125;struct Node &#123; int x , y;&#125;qu[ ( N * N )*6];int hea = N * N , tail = ( N * N ) - 1;void Debug () &#123; F ( i , 1 , n ) &#123; F ( j , 1 , m ) if ( indeque[i][j] )&#123; if(indeque[i][j] == hea ) printf("%c",'@'); else printf("%c",'X'); &#125; else printf ( "%c",mp[i][j] ); puts ( "" ); &#125; puts ( "" ); return;&#125;inline void work () &#123; qu[++tail] = ( Node ) &#123; sx , sy &#125;; indeque[sx][sy] = tail; int len = strlen ( operation + 1 ); F ( T , 1 , len ) &#123; char op = operation[T]; int dx , dy; FindDir ( dx , dy , op ); int nx = qu[hea].x , ny = qu[hea].y; int tx = qu[tail].x , ty = qu[tail].y; if ( mp[nx + dx][ny + dy] == '.' &amp;&amp; !indeque[nx + dx][ny + dy] ) &#123; qu[--hea] = ( Node ) &#123; nx + dx , ny + dy &#125;; indeque[nx + dx][ny + dy] = hea; indeque[tx][ty] = 0; tail--; &#125; else if ( mp[nx + dx][ny + dy] == 'o' ) &#123; qu[--hea] = ( Node ) &#123; nx + dx , ny + dy &#125;; indeque[nx + dx][ny + dy] = hea; mp[nx + dx][ny + dy] = '.'; &#125; else if ( indeque[nx + dx][ny + dy] ) &#123; int start = indeque[nx + dx][ny + dy]; for ( int i = start ; i &lt;= tail ; i++ ) &#123; int xx = qu[i].x , yy = qu[i].y; indeque[xx][yy] = 0; &#125; while ( tail &gt;= start ) tail--; qu[--hea] = ( Node ) &#123; nx + dx , ny + dy &#125;; indeque[nx + dx][ny + dy] = hea; &#125; else if ( nx + dx &gt; m || ny + dy &gt; n || nx + dx &lt;= 0 || ny + dy &lt;= 0 || mp[nx + dx][ny + dy] == '#' ) &#123; puts ( "-1" ); exit ( 0 ); &#125; //Debug (); &#125; return;&#125;inline void print () &#123; F ( i , 1 , n ) F ( j , 1 , m ) if ( mp[i][j] == '#' || mp[i][j] == 'o' ) continue; else mp[i][j] = '.'; int xx = qu[hea].x , yy = qu[hea].y; mp[xx][yy] = '@'; hea++; while ( hea &lt;= tail ) &#123; xx = qu[hea].x , yy = qu[hea].y; mp[xx][yy] = 'X'; hea++; &#125; F ( i , 1 , n ) &#123; F ( j , 1 , m ) printf ( "%c" , mp[i][j] ); puts ( "" ); &#125; return;&#125;int main ( void ) &#123; init (); work (); print (); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ¨¡æ‹Ÿèµ›é¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POJ2284]That Nice Euler Circuit]]></title>
    <url>%2F2019%2F10%2F28%2FPOJ2284-ThatNiceEulerCircuit%2F</url>
    <content type="text"><![CDATA[ä¼ é€é—¨ æ€è·¯é¦–å…ˆæˆ‘ä»¬æƒ³åˆ°çš„å°±æ˜¯ç›´æŽ¥å¼€äºŒç»´æ•°ç»„æ¨¡æ‹Ÿç„¶åŽ$bfs$ç»Ÿè®¡ç­”æ¡ˆ.ä½†æ˜¯è¿™æ ·çš„è¯æ—¶é—´å¤æ‚åº¦æ˜¯ä¸è¡Œçš„,æ‰€ä»¥æˆ‘ä»¬éœ€è¦è€ƒè™‘å…¶ä»–æ–¹æ³•.æˆ‘ä»¬è€ƒè™‘åˆ°æ¬§æ‹‰å…¬å¼,å³$E=V+F-2$.åœ¨è¿™é‡Œ$E$ä¸ºè¾¹æ•°,$V$ä¸ºç‚¹æ•°,$F$ä¸ºé¢çš„ä¸ªæ•°.æœ¬æ¥è¿™ä¸ªæ¬§æ‹‰å…¬å¼æ˜¯æ±‚ä¸‰ç»´çš„æƒ…å†µçš„,ä½†æ˜¯å‘çŽ°äºŒç»´çš„æƒ…å†µä¹Ÿé€‚ç”¨,æ‰€ä»¥æˆ‘æŠŠå®ƒç§°ä¸ºæœ¨å¤§å…¬å¼.å¯ä»¥ç›´æŽ¥å¼€$map$ç»Ÿè®¡ç‚¹å’Œè¾¹çš„ä¸ªæ•°,ç„¶åŽè¯•ç”¨æ¬§æ‹‰å…¬å¼è¿›è¡Œè®¡ç®—å³å¯. (æ³¨æ„ç‰¹åˆ¤åˆšå¼€å§‹$0$çš„æƒ…å†µ) ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 10;int NodeNum , EdgeNum;char s[N];struct kuai &#123; int x , y;&#125;;bool operator &lt; ( kuai x , kuai y ) &#123; if ( x.x == y.x ) return x.y &lt; y.y; return x.x &lt; y.x;&#125;;map &lt; kuai , bool &gt; Node;map &lt; pair &lt; kuai , kuai &gt; , bool &gt; Edge; int main ( void ) &#123; scanf ( "%s" , s + 1 ); int n = strlen ( s + 1 ); int xx = 0 , yy = 0; Node[ kuai &#123; 0 , 0 &#125; ] = 1; NodeNum = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int lx = xx , ly = yy; if ( s[i] == 'L' ) xx--; else if ( s[i] == 'R' ) xx++; else if ( s[i] == 'U' ) yy++; else if ( s[i] == 'D' ) yy--; if ( !Node[ kuai &#123; xx , yy &#125; ] ) &#123; Node[ kuai &#123; xx , yy &#125; ] = 1; NodeNum++; &#125; if ( !Edge[ make_pair ( kuai &#123; lx , ly &#125; , kuai &#123; xx , yy &#125; ) ] &amp;&amp; !Edge[ make_pair ( kuai &#123; xx , yy &#125; , kuai &#123; lx , ly &#125; ) ] ) &#123; Edge[ make_pair ( kuai &#123; xx , yy &#125; , kuai &#123; lx , ly &#125; ) ] = 1; Edge[ make_pair ( kuai &#123; lx , ly &#125; , kuai &#123; xx , yy &#125; ) ] = 1; EdgeNum++; &#125; // printf ( "step:%d , from(%d,%d) -&gt; to(%d,%d)\n" , i , lx , ly , xx , yy ); &#125; // printf ( "%d %d\n" , EdgeNum , NodeNum ); printf ( "%d\n" , EdgeNum - NodeNum + 2 ); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>è®¡ç®—å‡ ä½•</tag>
        <tag>æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Beginner Contest 144]é¢˜è§£]]></title>
    <url>%2F2019%2F10%2F28%2FAtcoderABC144%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[æˆ‘èœçˆ†äº†ðŸ˜¢ 9x9æ€è·¯ç­¾åˆ°é¢˜,ç›´æŽ¥åˆ¤æ–­ä¸€ä¸‹ä¸¤ä¸ªæ•°çš„å¤§å°å³å¯. ä»£ç 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main ( void ) &#123; int a , b; cin &gt;&gt; a &gt;&gt; b; if ( a &gt;= 1 &amp;&amp; a &lt;= 9 &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= 9 ) cout &lt;&lt; a * b &lt;&lt; endl; else cout &lt;&lt; "-1" &lt;&lt; endl; return 0;&#125; 81æ€è·¯ä»Ž$2$æžšä¸¾åˆ°$9$ç„¶åŽåˆ¤æ–­ä¸€ä¸‹å¦ä¸€åŠæ˜¯å¦å°äºŽ$10$å³å¯,æ³¨æ„$1$çš„æƒ…å†µ. ä»£ç 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main ( void ) &#123; int a , b; cin &gt;&gt; a; if ( a == 1 ) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; return 0; &#125; for ( int i = 2 ; i &lt;= 9 ; i++ ) if ( a % i == 0 ) &#123; if ( a / i &lt;= 9 &amp;&amp; a / i &gt;= 1 ) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; "No" &lt;&lt; endl; return 0;&#125; Walk on Multiplication Tableæ€è·¯æˆ‘ä»¬å¯ä»¥åœ¨$\sqrt{n}$çš„æ—¶é—´å†…æžšä¸¾å‡ºæ¯ä¸ªæ•°çš„å› æ•°,ç„¶åŽå¯¹äºŽæ¯ä¸ªå› å­åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦å¯ä»¥æ›´æ–°ç­”æ¡ˆå³å¯. ä»£ç 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main ( void ) &#123; long long a; cin &gt;&gt; a; if ( a == 1 ) &#123; cout &lt;&lt; "0" &lt;&lt; endl; return 0; &#125; long long ans = 1e16; for ( int i = 1 ; i &lt;= sqrt ( a ) ; i++ ) &#123; if ( a % i == 0 ) ans = min ( ans , ( i - 1 ) + ( a / i ) - 1 ); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Water Bottleæ€è·¯æ ¹æ®ç”Ÿæ´»å¸¸è¯†,æˆ‘ä»¬å‘çŽ°å¦‚æžœæŠŠæ¯å­å€¾æ–œ,æ°´èƒ½æ´’å‡ºæ¥çš„è¯,ä»Žè¿™ä¸ªæ¯å­çš„å‰–é¢åŽ»çœ‹,ä¸€å…±ä¼šæœ‰ä¸¤ç§æƒ…å†µ:å‰–é¢æ˜¯ä¸ªæ¢¯å½¢ä¸Žå‰–é¢æ˜¯ä¸ªä¸‰è§’å½¢.è€Œåˆå› ä¸ºå½“åªæœ‰æœ¬æ¥æ¯å­å†…æ°´çš„ä½“ç§¯å ç”¨äº†åŽŸæ¥æ¯å­çš„ä½“ç§¯çš„ä¸€åŠä»¥ä¸Šæ—¶å‰–é¢æ‰ä¼šæ˜¯ä¸ªæ¢¯å½¢,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ†ä¸¤ç§æƒ…å†µåˆ†åˆ«è®¨è®º.æˆ‘ä»¬å°†å‰–é¢ç”»å‡ºæ¥,ç„¶åŽå‘çŽ°è¿™ä¸ªå›¾å½¢çš„é¢ç§¯$S \times a$å³ä¸ºæ°´çš„ä½“ç§¯$x$,æ‰€ä»¥æˆ‘ä»¬å°±å¯ä»¥ç®—å‡ºæ¥å¯å˜è¾¹çš„é•¿åº¦,å†æ ¹æ®åä¸‰è§’å‡½æ•°è®¡ç®—å‡ºæœ¬æ¥çš„è§£æ˜¯å¤šå°‘. å¼§åº¦è½¬è§’åº¦: è§’åº¦=å¼§åº¦$ \times 180 / Î $ ä»£ç 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;double a,b,x;double Rad_to_deg = 45.0 / atan(1.0);int main ( void ) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;x; if ( x &gt;= ( a * a * b ) / 2 ) &#123; double C = 2.0 * b - ( 2.0 * x / ( a * a ) ); double hu = atan ( a / C ); hu = hu * Rad_to_deg * 1.0; printf ( "%.10lf\n" , 90.0000000 - hu ); &#125; else &#123; double A = ( 2.0 * x ) / ( a * b ); double hu = atan ( A / b ); hu = hu * Rad_to_deg * 1.0; printf ( "%.10lf\n" , 90.0000000 - hu ); &#125; return 0;&#125; Gluttonyæ€è·¯æ ¹æ®æˆ‘ä»¬çš„ç›´è§‰,æˆ‘ä»¬æŠŠ$A$æ•°ç»„ä»Žå°åˆ°å¤§æŽ’åº,ç„¶åŽæŠŠ$F$æ•°ç»„ä»Žå¤§åˆ°å°æŽ’åº,è¿™æ ·çš„è¯ç­”æ¡ˆä¸€å®šæ˜¯æœ€ä¼˜çš„è¯·è‡ªè¡Œè¯æ˜Ž.ç„¶åŽæˆ‘ä»¬è€ƒè™‘æ€Žä¹ˆç»Ÿè®¡ç­”æ¡ˆ,æ˜¾ç„¶,é¢˜ç›®ä¸­è¦æ±‚æœ€å¤§å€¼æœ€å°,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥äºŒåˆ†è¿™ä¸ªæœ€å¤§å€¼$mid$,ç„¶åŽå¯¹äºŽæ¯ä¸€ç»„$A_i$ä¸Ž$F_i$,æˆ‘ä»¬è®¾$cnt_i$ä¸ºä½¿è¿™ç»„$A_i \times B_i &lt;= mid$æ—¶éœ€è¦çš„é”»ç‚¼æ¬¡æ•°.ç„¶åŽæˆ‘ä»¬å°±å¯ä»¥åˆ—å‡º$F_i \times ( A_i - cnt_i ) &lt;= mid $ , å³$cnt_i = max ( 0 , A_i - mid / F_i )$. ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 2e5 + 10;int n , k;int A[N] , F[N];inline bool cmp ( int x , int y ) &#123; return x &gt; y;&#125;inline bool check ( int mid ) &#123; int cnt = 0; for ( int i = 1 ; i &lt;= n ; i++ ) cnt += max ( 0ll , A[i] - mid / F[i] ); if ( cnt &lt;= k ) return true; else return false;&#125;signed main ( void ) &#123; n = read () , k = read (); for ( int i = 1 ; i &lt;= n ; i++ ) A[i] = read (); for ( int i = 1 ; i &lt;= n ; i++ ) F[i] = read (); sort ( A + 1 , A + 1 + n ); sort ( F + 1 , F + 1 + n , cmp ); int l = 0 , r = 1e16; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( check ( mid ) ) r = mid - 1; else l = mid + 1; &#125; printf ( "%lld\n" , l ); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Atcoderé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®è½¬æD6]]></title>
    <url>%2F2019%2F10%2F28%2F%E6%99%AE%E8%BD%AC%E6%8F%90D6%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€ çŸ³å¤´æ€è·¯æˆ‘ä»¬è®¾$f_i$è¡¨ç¤ºå‰$i$ä¸ªåºåˆ—ä¸­èƒ½æŽ’å‡ºå¤šå°‘åºåˆ—.é‚£ä¹ˆæ˜¾ç„¶æœ‰$f_i=\sum f_j([\sum_{k=1}^{j+1}a_k]æ˜¯ç´ æ•°)$ ä»£ç 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define int long long #define ha 987654321const int N=1e6+10;using namespace std ;int n , f[N] , s[N] , vis[N] , num , prime[N] ;void pre() &#123; for(int i = 2 ; i &lt; N ; i ++) &#123; if(!vis[i]) prime[++num] = i ; for(int j = 1 ; j &lt;N &amp;&amp; i*prime[j] &lt;N ; j ++) &#123; vis[i*prime[j]] = 1 ; if(i % prime[j] == 0) break ; &#125; &#125; vis[1] = 1 ;&#125; int a[2000] ;signed main () &#123; pre() ; scanf("%lld",&amp;n) ; for(int i = 1 ; i &lt;= n ; i ++) &#123; int x ; scanf("%lld",&amp;x) ; a[i] = x ; s[i] = s[i-1] + a[i] ; &#125; f[0] = 1 ; for(int i = 1 ; i &lt;= n ; i ++ ) &#123; for(int j = 0 ; j &lt; i ; j ++) &#123; if(!vis[s[i]-s[j]]) f[i] = (f[i] + f[j])%ha ; &#125; &#125;cout &lt;&lt; f[n]%ha &lt;&lt; endl ; return 0 ;&#125; è½½é‡æ€è·¯å…ˆé¢„å¤„ç†å‡ºä¸€ä¸ªæœ€å¤§ç”Ÿæˆæ ‘,ç„¶åŽ$check$ä¸¤ç‚¹ä¹‹é—´çš„æœ€å¤§ç“¶é¢ˆè·¯ä¸Žç»™å®šçš„å€¼çš„å¤§å°å…³ç³»å³å¯. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 1e5 + 10;const int M = 3e5 + 10;int n , m , q , t;int head[N];struct Edge &#123; int from; int to; int date; int next;&#125;e[M &lt;&lt; 1] , G[M &lt;&lt; 1];int father[N];inline bool cmp ( Edge x , Edge y ) &#123; return x.date &gt; y.date;&#125;int find ( int cur ) &#123; if ( father[cur] != cur ) father[cur] = find ( father[cur] ); return father[cur];&#125;inline void Union ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; return;&#125;inline bool Judge ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); if ( x == y ) return true; else return false;&#125;inline void add ( int x , int y , int z ) &#123; G[++t].to = y; G[t].from = x; G[t].date = z; G[t].next = head[x]; head[x] = t; return;&#125;int p[N][22] , mins[N][22];int deep[N];void Creat ( int root , int fa ) &#123; p[root][0] = fa; deep[root] = deep[fa] + 1; for ( int i = head[root] ; i ; i = G[i].next ) &#123; int j = G[i].to; if ( j == fa ) continue; mins[j][0] = G[i].date; Creat ( j , root ); &#125; return;&#125;inline int LCA ( int x , int y ) &#123; int minn = 2147483647; if ( deep[x] &gt; deep[y] ) std :: swap ( x , y ); for ( int i = 21 ; i &gt;= 0 ; i-- ) if ( deep[x] &lt;= deep[y] - ( 1 &lt;&lt; i ) ) &#123; minn = std :: min ( minn , mins[y][i] ); y = p[y][i]; &#125; if ( x == y ) return minn; for ( int i = 21 ; i &gt;= 0 ; i-- ) &#123; if ( p[x][i] == p[y][i] ) continue; minn = std :: min ( minn , std :: min ( mins[x][i] , mins[y][i] ) ); x = p[x][i]; y = p[y][i]; &#125; return std :: min ( minn , std :: min ( mins[x][0] , mins[y][0] ) );&#125;int main ( void ) &#123; n = read () , m = read () , q = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); e[i].from = x; e[i].to = y; e[i].date = z; &#125; for ( register int i = 1 ; i &lt;= n ; i++ ) father[i] = i; memset ( mins , 0x3f3f3f3f , sizeof ( mins ) ); std :: sort ( e + 1 , e + 1 + m , cmp ); int NowEdge = 0; for ( int i = 1 ; i &lt;= m &amp;&amp; NowEdge != n - 1 ; i++ ) &#123; int l = e[i].from , r = e[i].to; if ( !Judge ( l , r ) ) &#123; Union ( l , r ); NowEdge++; add ( l , r , e[i].date ); add ( r , l , e[i].date ); &#125; if ( NowEdge == n - 1 ) break; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) if ( deep[i] == 0 ) &#123; deep[i] = 1; p[i][0] = 0; Creat ( i , 0 ); &#125; for ( int j = 1 ; j &lt;= 21 ; j++ ) for ( int i = 1 ; i &lt;= n ; i++ ) &#123; p[i][j] = p[p[i][j - 1]][j - 1]; mins[i][j] = std :: min ( mins[i][j - 1] , mins[p[i][j - 1]][j - 1] ); &#125; for ( ; q-- ; ) &#123; int l = read () , r = read () , vv = read (); if ( !Judge ( l , r ) ) puts ( "No" ); else &#123; int res = LCA ( l , r ); if ( res &gt;= vv ) puts ( "Yes" ); else puts ( "No" ); &#125; &#125; return 0;&#125; åˆ†æ•°æ€è·¯æˆ‘ä»¬æ¨¡æ‹Ÿä¸€ä¸‹çŽ°å®žä¸­çš„è¿‡ç¨‹,å‘çŽ°æˆ‘ä»¬éœ€è¦æ‰¾å‡ºåˆ†æ¯æ‰€æœ‰çš„è´¨å› å­å¹¶ä¸”æŠŠä»–ä»¬ä¹˜èµ·æ¥å°±æ˜¯ç­”æ¡ˆ,ä½†æ˜¯éœ€è¦å†™é«˜ç²¾åº¦. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int MO = 15;struct Big&#123; int len, data[10005]; void clear() &#123; memset ( this , 0 , sizeof ( *this ) ); &#125; int &amp; operator [] ( int k ) &#123; return data[k]; &#125; Big &amp; operator = ( int k ) &#123; clear(); len = 0; while ( k ) &#123; ++len; data[len] = k &amp; MO; k &gt;&gt;= 4; &#125; if ( len == 0 ) ++len; return *this; &#125; Big operator * ( Big &amp; A ) &#123; Big temp; temp.clear(); temp.len = len + A.len - 1; for ( int i = 1 ; i &lt;= len ; i++ ) for ( int j = 1 ; j &lt;= A.len ; j++ ) &#123; temp[i + j - 1] += A[j] * data[i]; temp[i + j] += ( temp[i + j - 1] &gt;&gt; 4 ); temp[i + j - 1] &amp;= MO; &#125; while(temp[temp.len + 1]) ++temp.len; return temp; &#125; void print()&#123; for (int i = len; i &gt;= 1; i--) printf("%X", data[i]); putchar('\n'); &#125;&#125; temp , ans;const int N = 1000005;int pnum , p[N];bool f[N];map &lt; int , bool &gt; M;void work ( int num ) &#123; for ( int i = 1 ; i &lt;= pnum ; i++ ) &#123; if ( num % p[i] == 0 ) if ( M[p[i]] == 0 ) &#123; M[p[i]] = true; temp = p[i]; ans = ans * temp; &#125; while ( num % p[i] == 0 ) num /= p[i]; &#125; if ( num != 1 ) if ( M[num] == 0 ) &#123; M[num] = true; temp = num; ans = ans * temp; &#125; return;&#125; int main ( void ) &#123; ans = 1; int T; T = read (); memset ( f , true , sizeof ( f ) ); f[0] = f[1] = false; p[pnum = 1] = 2; for ( int now = 2 ; now &lt; N ; ) &#123; for ( int j = 2 * now ; j &lt;= N ; j += now ) f[j] = false; now++; while ( now &lt; N &amp;&amp; !f[now] ) now++; if ( f[now] ) p[++pnum] = now; &#125; while ( T-- ) &#123; int x = read () , y = read (); int d = __gcd ( x , y ); x /= d; y /= d; work ( y ); &#125; ans.print(); return 0;&#125; é¼å°”å¾·æ€è·¯è§£ï¼šè®¾$d_{i,j}$è¡¨ç¤ºèµ°åˆ°ç»“ç‚¹$i$ï¼Œè¢«æ”¶äº†$j$æ¬¡è·¯è´¹ï¼Œæœ€å°‘èŠ±äº†å¤šå°‘é’±ã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šè€ƒè™‘ä¸Šä¸€ä¸ªç»“ç‚¹ï¼Œä¸å¦¨è®¾ä¸º$k$ã€‚$d_{i,j} = min[max(d_{k,j-1} + iåˆ°kçš„è·¯è´¹, d_{k,j})]$è¾¹ç•Œï¼š$d_{1,j} = 0$æœ€ç»ˆè§£ï¼š$d_{n,k}$. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;#define N 3010#define INF 1000000000000000000#define LL long longstruct edge &#123; LL to, cost, next;&#125;;queue&lt;LL&gt; q;edge e[N &lt;&lt; 1];bool exist[N];LL d[N][N], head[N], n, m, K, nedge;inline LL max(LL x, LL y) &#123; return x &gt; y ? x : y;&#125;inline void link(LL u, LL v, LL w) &#123; e[++nedge].to = v; e[nedge].cost = w; e[nedge].next = head[u]; head[u] = nedge;&#125;int main() &#123; scanf("%lld %lld %lld", &amp;n, &amp;m, &amp;K); for(LL i = 1; i &lt;= m; i++) &#123; LL u, v, w; scanf("%lld %lld %lld", &amp;u, &amp;v, &amp;w); link(u, v, w); link(v, u, w); &#125; for(LL i = 2; i &lt;= n; i++) fill(&amp;d[i][0], &amp;d[i][N], INF); q.push(1); exist[1] = true; while(!q.empty()) &#123; LL u = q.front(); q.pop(); exist[u] = false; for(LL i = head[u]; i; i = e[i].next) &#123; LL v = e[i].to, w = e[i].cost; bool flag = false; for(LL j = 0; j &lt;= K; j++) &#123; LL t = d[u][j]; if(j) t = max(t, d[u][j - 1] + w); if(d[v][j] &gt; t) &#123;d[v][j] = t; flag = true;&#125; &#125; if(flag &amp;&amp; !exist[v]) &#123; exist[v] = true; q.push(v); &#125; &#125; &#125; printf("%lld", d[n][K]); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®åŠäº”è”æµ‹D4]]></title>
    <url>%2F2019%2F10%2F26%2F%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8BD4%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€. åˆ·é¢˜çŽ‹è€…æ€è·¯ç›´æŽ¥å¼€$map$ç»Ÿè®¡å³å¯. ä»£ç 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int n;bool mp[10005];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int num; scanf ( "%d" , &amp;num ); while ( num-- ) &#123; int x; scanf ( "%d" , &amp;x ); mp[x] = 1; &#125; &#125; int ans = 0; for ( int i = 1000 ; i &lt;= 9999 ; i++ ) if ( mp[i] ) ans++; printf ( "%d\n" , ans ); return 0;&#125; å›žåˆ°åŽŸç‚¹æ€è·¯è€ƒè™‘æˆ‘ä»¬æŒ‰ç…§åŽŸæ¥çš„å­—ç¬¦ä¸²è¿›è¡Œç§»åŠ¨ä¹‹åŽçš„ä½ç½®$(x,y)$.å‘çŽ°å¯¹åŽŸæ¥å­—ç¬¦ä¸²è¿›è¡Œæ“ä½œçš„è¯,å¦‚æžœæˆ‘ä»¬æŠŠæŸä¸ªå‘ä¸Šçš„å’Œå‘ä¸‹çš„æ“ä½œå˜æˆå‘å·¦æˆ–å‘å³çš„,é‚£ä¹ˆæ¯æ¬¡å¯ä»¥ä»Ž$(x,y)$å‘å·¦ä¸Š/ä¸‹,å³ä¸Š/ä¸‹ç§»åŠ¨.æ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡å¯ä»¥å¯¹äºŽ$x$å’Œ$y$çš„ç»å¯¹å€¼$+1$æˆ–è€…$-1$.æ‰€ä»¥ç­”æ¡ˆå°±æ˜¯$min(abs(x),abs(y)) + max ( abs ( x ) - min ( abs ( x ) , abs ( y ) ) , abs ( y ) - min ( abs ( x ) , abs ( y ) ) ) / 2$. ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1005;int len , x , y;char s[N];int main ( void ) &#123; scanf ( "%s" , s + 1 ); len = strlen ( s + 1 ); if ( len &amp; 1 ) &#123; puts ( "-1" ); return 0; &#125; for ( int i = 1 ; i &lt;= len ; i++ ) &#123; if ( s[i] == 'U' ) y++; if ( s[i] == 'D' ) y--; if ( s[i] == 'L' ) x--; if ( s[i] == 'R' ) x++; &#125; int ans = 0; ans += min ( abs ( x ) , abs ( y ) ); if ( x &gt;= 0 ) x -= ans; else if ( x &lt; 0 ) x += ans; if ( y &gt;= 0 ) y -= ans; else if ( y &lt; 0 ) y += ans; if ( x != 0 ) ans += abs ( x / 2 ); else if ( y != 0 ) ans += abs ( y / 2 ); printf ( "%d\n" , ans ); return 0;&#125; å¿«ä¹çŸ©é˜µæ€è·¯å‘çŽ°åŽŸæ¥æŸäº›ç‚¹çš„è´¡çŒ®å¯ä»¥åŽ‹ç¼©åˆ°ä¸€ä¸ªç‚¹,æ‰€ä»¥æˆ‘ä»¬å¯¹æ¯ä¸€è¡Œæ±‚ä¸€ä¸ªå‰ç¼€å·®,ç„¶åŽå†å¯¹è¿™æœ€åŽä¸€åˆ—çš„å‰ç¼€å·®æ±‚ä¸€ä¸ªå‰ç¼€å·®,åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦ä¸º$0$å³å¯. ä»£ç 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int mp[505][505];int n , m;int num[505];signed main ( void ) &#123;// freopen ( "C.in" , "r" , stdin ); ios :: sync_with_stdio ( false ); cin.tie ( 0 ) , cout.tie ( 0 ); cin &gt;&gt; n &gt;&gt; m; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 1 ; j &lt;= m ; j++ ) cin &gt;&gt; mp[i][j]; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int sum = 0; for ( int j = 1 ; j &lt; m ; j++ ) mp[i][j + 1] -= mp[i][j]; num[i] = mp[i][m]; // cout &lt;&lt; num[i] &lt;&lt; endl; &#125; int now = 0; for ( int i = 1 ; i &lt; n ; i++ ) num[i + 1] -= num[i]; now = num[n]; if ( abs ( now ) == 0 ) puts ( "Yes" ); else puts ( "No" ); return 0;&#125; æ¢¦ä¸­çš„ä½è¿ç®—æ€è·¯å‘çŽ°è¿›è¡Œæ“ä½œä¸€å®šæ¯”ä¸æ“ä½œæ›´ä¼˜ç§€,æ‰€ä»¥æˆ‘ä»¬è¦æ±‚çš„å°±æ˜¯æ“ä½œåˆ°ä¸èƒ½å†æ“ä½œäº†çš„æ—¶å€™è¿™ä¸ªåºåˆ—çš„å¹³æ–¹å’Œ.åˆå› ä¸ºè¿™ä¸ªæ“ä½œçš„æœ¬è´¨å°±æ˜¯æŠŠ$1$éƒ½æ”¾åˆ°æŸä¸€ä¸ªæ•°å­—ä¸Š,æ‰€ä»¥æˆ‘ä»¬ç›´æŽ¥ç»Ÿè®¡ä¸€ä¸‹äºŒè¿›åˆ¶ä¸‹æŸä¸€ä½å‡ºçŽ°äº†å¤šå°‘æ¬¡ç„¶åŽè´ªå¿ƒç»Ÿè®¡å³å¯. ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w; &#125;inline void print ( __int128 x ) &#123; if ( !x ) return ; print ( x / 10 ); putchar ( x % 10 + '0' ); return;&#125;int n;int num[35];__int128 ans;int main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int x = read (); for ( int j = 0 ; j &lt;= 30 ; j++ ) if ( x &amp; ( 1 &lt;&lt; j ) ) num[j]++; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; __int128 re = 0; for ( int j = 0 ; j &lt;= 30 ; j++ ) if ( num[j] &gt;= i ) re |= (1ll &lt;&lt; j); ans += re * re; &#125; print ( ans ); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 75é¢˜è§£]]></title>
    <url>%2F2019%2F10%2F25%2FEdu75%2F</url>
    <content type="text"><![CDATA[æ„å¤–æ„Ÿè§‰è¿˜æŒºå‹å–„çš„? Broken Keyboardæ€è·¯è€ƒè™‘ä¸€æ®µå­—ç¬¦è¿žç»­å‡ºçŽ°çš„æ¬¡æ•°æ˜¯å¥‡æ•°æ¬¡è¿˜æ˜¯å¶æ•°æ¬¡,å¦‚æžœæœ‰æŸç§å­—ç¬¦è¿žç»­å‡ºçŽ°äº†å¥‡æ•°æ¬¡é‚£ä¹ˆå°±æ˜¯ä¸€å®šå­˜åœ¨çš„. ä»£ç 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while ( T-- ) &#123; string s; cin &gt;&gt; s; int len = s.size (); map &lt; char , bool &gt; ans; char las = '.'; int num = 0; for ( int i = 0 ; i &lt;= len ; i++ )&#123; if ( las != s[i] ) &#123; if ( num % 2 == 1 ) ans[las] = 1; las = s[i]; num = 1; &#125; else num++; &#125; for ( int i = ( int ) 'a' ; i &lt;= ( int ) 'z' ; i++ ) if ( ans[(char)i] == 1 ) cout &lt;&lt; ( char ) i; cout &lt;&lt; endl; &#125; return 0;&#125;// Binary Palindromesæ€è·¯å‘çŽ°å¦‚æžœå¯ä»¥æ ¹æ®é¢˜ç›®ä¸­ç»™çš„æ¡ä»¶æ¥äº¤æ¢çš„è¯,é‚£ä¹ˆåŽŸé—®é¢˜å¯ä»¥ç­‰ä»·ä¸ºç»™ä½ è‹¥å¹²ä¸ª$1$å’Œ$0$,ç„¶åŽèƒ½å¯¹äºŽæŸäº›ç»™å®šçš„é•¿åº¦,æœ€å¤šèƒ½æ‹¼å‡ºå¤šå°‘å›žæ–‡ä¸².å‘çŽ°å¦‚æžœæˆ‘ä»¬è¦æž„é€ ä¸²çš„è¯,é‚£ä¹ˆåœ¨å‰$len/i$(å‘ä¸‹å–æ•´)ä¸ªä½ç½®,æˆ‘ä»¬ä¸ç”¨è€ƒè™‘ä»€ä¹ˆå…¶ä»–çš„æ¡ä»¶,åªéœ€è¦æ¯æ¬¡é€‰æ‹©ä¸€ä¸ªå‰©ä½™æ•°é‡å¤§çš„ç„¶åŽ$-2$å³å¯.ç„¶åŽæˆ‘ä»¬å‘çŽ°å¦‚æžœæˆ‘ä»¬è¦æž„é€ çš„ä¸²çš„é•¿åº¦ä¸ºå¥‡æ•°çš„è¯,ä¸­é—´çš„é‚£ä¸ªç”¨ä»€ä¹ˆæ˜¯ä¸ªé—®é¢˜,æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹,å› ä¸ºæˆ‘ä»¬åœ¨æž„é€ è¿‡ç¨‹çš„ç¬¬ä¸€æ­¥ä¸­è¦æ‹¿å‡ºä¸¤ä¸ªæ¥æž„é€ ,é‚£ä¹ˆå¦‚æžœå‰©ä½™æ•°é‡æ˜¯å¥‡æ•°ä¸€å®šä¼šæ¯”å‰©ä½™æ•°é‡æ˜¯å¶æ•°æ›´åŠ£.è€Œå¥‡æ•°$-1=$å¶æ•°,æ‰€ä»¥å¦‚æžœæœ‰å‰©ä½™ä¸ªæ•°æ˜¯å¥‡æ•°çš„è¯,æˆ‘ä»¬æ‹¿å‡ºä¸€ä¸ªå¥‡æ•°çš„æ¥$-1$,å¦åˆ™é€‰æ‹©ä¸€ä¸ªå‰©ä½™æ•°é‡å¤šçš„æž„é€ . ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int len[55];int main()&#123; ios :: sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while ( T-- ) &#123; memset ( len , 0 , sizeof ( len ) ); int NumZ = 0 , NumO = 0; int n; cin &gt;&gt; n; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; string s; cin&gt;&gt;s; len[i] = s.size(); for ( int j = 0 ; j &lt; len[i] ; j++ ) if ( s[j] == '0' ) NumZ++; else NumO++; &#125; sort ( len + 1 , len + 1 + n ); int ans = 0; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= len[i] / 2 ; j++ ) &#123; if ( NumO &gt; NumZ ) NumO -= 2; else NumZ -= 2; &#125; if ( len[i] % 2 == 1 ) if ( NumO &gt;= 1 &amp;&amp; NumO % 2 == 1 ) NumO--; else if ( NumZ &gt;= 1 &amp;&amp; NumZ % 2 == 1 ) NumZ--; else &#123; if ( NumO &gt; NumZ ) NumO -= 1; else NumZ -= 1; &#125; if ( NumZ &gt;= 0 &amp;&amp; NumO &gt;= 0 ) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Minimize The Integeræ€è·¯å‘çŽ°è¿™æ ·ä¸€ä¸ªç»“è®º,å¦‚æžœå¯ä»¥äº¤æ¢ä»»æ„ä¸åŒç›¸é‚»å¥‡å¶æ•°çš„è¯,é‚£ä¹ˆåŽŸæ¥å¥‡æ•°å’Œå¶æ•°ç›¸å¯¹äºŽè‡ªå·±çš„å¥‡å¶æ€§çš„æ•°çš„ç›¸å¯¹ä½ç½®æ˜¯ä¸ä¼šæ”¹å˜çš„.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ†åˆ«æŠŠå¥‡æ•°å’Œå¶æ•°å­˜å‚¨èµ·æ¥.ç„¶åŽå¼€ä¸¤ä¸ªé˜Ÿåˆ—,åˆ†åˆ«å¯¹æ¯”å¥‡æ•°å’Œå¶æ•°é˜Ÿåˆ—çš„é˜Ÿå¤´å¤§å°å¹¶ä¸”è´ªå¿ƒçš„é€‰æ‹©ä¸€ä¸ªå°çš„è¾“å‡ºå³å¯. ä»£ç 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;string s;int main ( void ) &#123; ios :: sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while ( T-- ) &#123; cin &gt;&gt; s; int len = s.size (); queue &lt; int &gt; qu[2]; for ( int i = 0 ; i &lt; len ; i++ ) if ( ( ( int ) s[i] - '0' ) % 2 == 0 ) qu[0].push ( ( int ) s[i] - '0' ); else qu[1].push ( ( int ) s[i] - '0' ); qu[0].push ( 11 ); qu[1].push ( 11 ); for ( int i = 1 ; i &lt;= len ; i++ ) &#123; if ( qu[0].front () &lt; qu[1].front () ) &#123; cout &lt;&lt; qu[0].front (); qu[0].pop (); &#125; else if ( qu[0].front () &gt; qu[1].front () ) &#123; cout &lt;&lt; qu[1].front (); qu[1].pop (); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Salary Changingæ€è·¯å‘çŽ°å¯ä»¥äºŒåˆ†è¿™ä¸ª$mid$,ç„¶åŽæˆ‘ä»¬è€ƒè™‘æ€Žä¹ˆ$check$.å¯¹äºŽæŸä¸ªåŒºé—´$[l,r]$,å¦‚æžœ$r&gt;=mid$,é‚£ä¹ˆè¯´æ˜Žåœ¨è¿™ä¸ªåŒºé—´ä¸­æˆ‘ä»¬å¯ä»¥å–åˆ°$mid$.ç„¶åŽæˆ‘ä»¬æŠŠèƒ½å–åˆ°$mid$çš„åŒºé—´å…¨éƒ¨å–åˆ°$mid$,å‘çŽ°å¦‚æžœå¤§äºŽ$mid$çš„åŒºé—´åˆšå¥½ä¸º$(n+1)/2$ä¸ª,é‚£ä¹ˆè¯´æ˜Žè¿™ä¸ªå–å€¼æ˜¯å¯è¡Œçš„. ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; const int INF = 1e9 + 5; struct Node &#123; int L, R; bool operator&lt;(const Node &amp;other) const &#123; return L &lt; other.L; &#125;&#125;; int N, H;long long S;vector&lt;Node&gt; v; bool possible(int median) &#123; long long sum = 0; for (Node &amp;s : v) sum += s.L; int count = 0; for (int i = N - 1; i &gt;= 0 &amp;&amp; count &lt; H; i--) if (v[i].R &gt;= median) &#123; sum += max(median - v[i].L, 0); count++; &#125; return count == H &amp;&amp; sum &lt;= S;&#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N &gt;&gt; S; H = (N + 1) / 2; v.resize(N); for ( Node &amp;s : v ) cin &gt;&gt; s.L &gt;&gt; s.R; sort ( v.begin() , v.end () ); int l = 0, r = INF , ans; while ( l &lt;= r ) &#123; int mid = ( l + r ) / 2; if ( possible ( mid ) ) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[51NodP1682] ä¸­ä½æ•°è®¡æ•°]]></title>
    <url>%2F2019%2F10%2F24%2F51Nod-P1682%E4%B8%AD%E4%BD%8D%E6%95%B0%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ä¼ é€é—¨ å‘çŽ°é¢˜ç›®ä¸­çš„æ•°æ®èŒƒå›´è¯´æ˜Žæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$çš„ç®—æ³•.å‘çŽ°æˆ‘ä»¬å¯ä»¥è€ƒè™‘æ¯ä¸ªæ•°å­—çš„è´¡çŒ®,æˆ‘ä»¬å‘çŽ°,å¯¹äºŽæŸä¸ªä½ç½®ä¸Šçš„æ•°å­—è€Œè¨€,åŒ…å«è¿™ä¸ªä½ç½®çš„åŒºé—´çš„æ•°é‡æ˜¯$n$çº§åˆ«çš„.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°è¯•å¯¹äºŽæ¯ä¸ªä½ç½®çš„æ•°å­—,æžšä¸¾åŒ…å«è¿™ä¸ªä½ç½®çš„åŒºé—´ç„¶åŽç»Ÿè®¡ç­”æ¡ˆ.æ‰€ä»¥é—®é¢˜å°±è½¬åŒ–æˆäº†æ€Žä¹ˆç»Ÿè®¡ç­”æ¡ˆ.ç”±äºŽæƒå€¼çš„èŒƒå›´å¾ˆå¤§,æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘è®¾$sum_{n+j}$è¡¨ç¤ºæŽ’åºåŽ,ä¸Ž$i$è¿™ä¸ªä½ç½®çš„æ•°å­—è¿˜éœ€è¦ç§»åŠ¨æ­£è´Ÿ$j$ä¸ªå•ä½æ‰èƒ½åˆ°ä¸­ä½æ•°çš„ä½ç½®.ç„¶åŽæˆ‘ä»¬æžšä¸¾å®Œæ‰€æœ‰åŒºé—´ä¹‹åŽç›´æŽ¥ç»Ÿè®¡å°±å¥½äº†. 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 8e3 + 5;const int INF = 0x3f3f3f3f;int n;int num[N], sum[N &lt;&lt; 1], ans[N];int main ( void ) &#123; ios :: sync_with_stdio ( false ); cin.tie ( 0 ) , cout.tie ( 0 ); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; num[i]; for (int i = 0; i &lt; n; i++)&#123; memset(sum, 0, sizeof(sum)); int cnt = 0; for (int j = i; j &gt;= 0; j--)&#123; if (num[j] &gt; num[i]) cnt++; if (num[j] &lt; num[i]) cnt--; sum[8000+cnt]++; &#125; cnt = 0; for (int j = i; j &lt; n; j++)&#123; if (num[j] &gt; num[i]) cnt++; if (num[j] &lt; num[i]) cnt--; ans[i] += sum[8000-cnt]; &#125; &#125; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; ans[i]; if (i != n-1) cout &lt;&lt; " "; else cout &lt;&lt; endl; &#125; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ€ç»´</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JZOJ]å¹³å‡æ•°]]></title>
    <url>%2F2019%2F10%2F24%2FJZOJ-%E5%B9%B3%E5%9D%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[èŽ«å¾—ä¼ é€é—¨qwq,,, è€ƒè™‘äºŒåˆ†å¹³å‡å€¼midï¼Œè®¾å½“å‰å¹³å‡å€¼å°äºŽç­‰äºŽmidçš„ä¸ªæ•°ä¸º$f(mid)$ã€‚å½“$f(mid)&gt;k$ï¼Œåˆ™ç¼©å°$mid$ã€‚ç„¶åŽå‰©ä¸‹çš„é—®é¢˜å°±å˜æˆäº†æ€Žä¹ˆæ±‚å‡ºè¿™ä¸ª$f$äº†.æˆ‘ä»¬è®¾ð‘Žæ•°ç»„å‰ç¼€å’Œä¸º$sum_i$,é‚£ä¹ˆåŒºé—´$[ð‘—+1,ð‘–]$çš„å¹³å‡å€¼ä¸º$\frac{ð‘ ð‘¢ð‘š[ð‘–]âˆ’ð‘ ð‘¢ð‘š[ð‘—]}{ð‘–âˆ’ð‘—}$.ç„¶åŽè§‚å¯Ÿå¯¹äºŽä¸€å¯¹$(ð‘–,ð‘—)$ï¼š \frac{ð‘ ð‘¢ð‘š_iâˆ’ð‘ ð‘¢ð‘š_j}{ð‘–âˆ’ð‘—}â‰¤ð‘šð‘–ð‘‘â‡”ð‘ ð‘¢ð‘š_iâˆ’ð‘ ð‘¢ð‘š_jâ‰¤ð‘šð‘–ð‘‘âˆ—(ð‘–âˆ’ð‘—)â‡”ð‘ ð‘¢ð‘š_iâˆ’ð‘šð‘–ð‘‘âˆ—ð‘–â‰¤ð‘ ð‘¢ð‘š_jâˆ’ð‘šð‘–ð‘‘âˆ—ð‘—æ˜¾ç„¶,å¦‚æžœæˆ‘ä»¬å®šä¹‰$v_i$è¡¨ç¤º$sum_i-mid \times i$çš„è¯,é‚£ä¹ˆ$f(mid)$å³ä¸º$v$æ•°ç»„çš„é€†åºå¯¹.æ‰€ä»¥æˆ‘ä»¬è¦åšçš„å°±æ˜¯æ±‚å‡ºé€†åºå¯¹çš„ä¸ªæ•°å³å¯,å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„æˆ–è€…å½’å¹¶æŽ’åºè½»æ¾è§£å†³. å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>äºŒåˆ†</tag>
        <tag>åˆ†æ²»</tag>
        <tag>æ ‘çŠ¶æ•°ç»„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[51Nod]P1686 ç¬¬Kå¤§åŒºé—´]]></title>
    <url>%2F2019%2F10%2F24%2F51NodP1686-%E7%AC%ACK%E5%A4%A7%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[ä¼ é€é—¨æ³¨æ„åˆ°å¦‚æžœæˆ‘ä»¬è®¾$f_i$è¡¨ç¤ºå€¼å¤§äºŽ$i$çš„åŒºé—´æœ‰å¤šå°‘ä¸ªçš„è¯,é‚£ä¹ˆæ˜¾ç„¶$i$è¶Šå¤§,åŒºé—´çš„ä¸ªæ•°è¶Šå°,å…·æœ‰å•è°ƒæ€§,æ‰€ä»¥æ˜¾ç„¶å¯ä»¥äºŒåˆ†è§£å†³.åˆå› ä¸ºé¢˜ç›®ä¸­çš„é™åˆ¶å¯ä»¥è½¬åŒ–ä¸º$f_i&gt;=k$å¹¶ä¸”$i$æœ€å¤§.é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åŽ»äºŒåˆ†è¿™ä¸ª$i$ç„¶åŽç»Ÿè®¡ä¸€ä¸‹$f_i$æœ‰å¤šå°‘ä¸ª.é‚£ä¹ˆçŽ°åœ¨çš„é—®é¢˜å°±æ˜¯æ€Žä¹ˆåŽ»ç»Ÿè®¡è¿™ä¸ª$f_i$åˆ°åº•æœ‰å¤šå°‘.æˆ‘ä»¬å…ˆå¯¹åŽŸæ•°ç»„è¿›è¡Œç¦»æ•£åŒ–å¤„ç†(å› ä¸ºåŽŸæ¥çš„æƒå€¼èŒƒå›´å®žåœ¨æ˜¯å¤ªå¤§äº†),ç„¶åŽå¼€ä¸€ä¸ª$buck_i$è¡¨ç¤º$i$è¿™ä¸ªæ•°å­—å‡ºçŽ°äº†å¤šå°‘æ¬¡.é‚£ä¹ˆå‘çŽ°å¦‚æžœæˆ‘ä»¬ä½¿ç”¨$two$_$pointers$ç»Ÿè®¡ç­”æ¡ˆçš„è¯,é‚£ä¹ˆæ¯æ¬¡ä¼šæ›´æ–°ä¼—æ•°çš„é‚£ä¸ªå€¼ä¸€å®šåªèƒ½æ˜¯æ–°åŠ è¿›æ¥çš„é‚£ä¸ªå€¼.æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦åˆ¤æ–­ä¸€ä¸‹æ˜¯ä¸æ˜¯$buck_r&gt;=mid$å³å¯. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e5 + 10;int n , k;struct Node &#123; int id; int v;&#125;ls[N];int num[N] , idx;int buck[N];inline bool cmp ( Node x , Node y ) &#123; return x.v &lt; y.v;&#125;int pos[N];vector &lt; int &gt; G[N];inline int check ( int x ) &#123; if ( x == 1 ) return n * ( n - 1 ) / 2; int ans = 0 , L = 0; for ( int i = 1 ; i &lt;= n ; i++ ) G[i].clear(); memset ( buck , 0 , sizeof ( buck ) ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( buck[num[i]] &gt;= x - 1 ) pos[i] = G[num[i]][buck[num[i]] + 1 - x]; else pos[i] = 0; L = max ( L , pos[i] ); ans += L; buck[num[i]]++; int tmp = buck[num[i]]; G[num[i]].push_back( i ); &#125; return ans;&#125;signed main ( void ) &#123; ios :: sync_with_stdio ( false ); cin.tie ( 0 ) , cout.tie ( 0 ); cin &gt;&gt; n &gt;&gt; k; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; ls[i].id = i; cin &gt;&gt; ls[i].v; &#125; sort ( ls + 1 , ls + 1 + n , cmp ); ls[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( ls[i].v != ls[i - 1].v ) idx++; num[ls[i].id] = idx; &#125; int l = 1 , r = n , ans = 1; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( check ( mid ) &gt;= k ) &#123; l = mid + 1; ans = mid; &#125; else r = mid - 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>äºŒåˆ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #595 (Div. 3)]]></title>
    <url>%2F2019%2F10%2F23%2FRound595%2F</url>
    <content type="text"><![CDATA[é™æ™ºé¢˜çœŸçš„å¯ä»¥ä¸ºæ‰€æ¬²ä¸º. Yet Another Dividing into Teamsæ€è·¯å› ä¸ºé¢˜ç›®ä¸­æœ‰ä¸ªæ¡ä»¶å«åšæ¯ä¸ª$a_i$äº’ä¸ç›¸åŒ,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆæŽ’åºä¹‹åŽçœ‹ä¸€ä¸‹$a_i$äºŽ$a_{i-1}$çš„å·®çš„ç»å¯¹å€¼æ˜¯å¦ä¸º$1$.å¦‚æžœæœ‰çš„è¯ç­”æ¡ˆå°±æ˜¯$2$,å¦åˆ™ç­”æ¡ˆæ˜¾ç„¶ä¸º$1$. ä»£ç 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int n , ans;int num[105];int main ( void ) &#123; int T; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; sort(num+1,num+1+n); ans=1; for(int i=2;i&lt;=n;i++) if(abs(num[i]-num[i-1])==1) ans=2; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Books Exchangeæ€è·¯$B1$å’Œ$B2$å°±ä¸€èµ·è¯´äº†â€¦.é¦–å…ˆå¦‚æžœ$i$å¯ä»¥æŠŠä»–çš„ä¿¡æ¯ä¼ ç»™$d_i$,é‚£ä¹ˆæˆ‘ä»¬ç”±ä¿¡æ¯ä¼ é€’é‚£é“é¢˜çš„æ€è·¯å¯çŸ¥æˆ‘ä»¬å¯ä»¥ä»Ž$i$åˆ°$d_i$è¿žä¸€æ¡è¾¹.è€Œæ¯ä¸ªç‚¹è¦çŸ¥é“è‡ªå·±çš„ä¿¡æ¯,å°±æ˜¯è¦åœ¨è‡ªå·±æ‰€åœ¨çš„å¼ºè¿žé€šåˆ†é‡ä¸­èµ°ä¸€åœˆ.å³æ¯ä¸ªç‚¹çš„ç­”æ¡ˆå°±æ˜¯æ¯ä¸ªç‚¹æ‰€åœ¨å¼ºè¿žé€šåˆ†é‡çš„å¤§å°.åˆå› ä¸ºé¢˜ç›®ä¿è¯ä¸€å®šæœ‰è§£,æ‰€ä»¥ç›´æŽ¥$Tarjan$ç¼©ç‚¹ç„¶åŽç›´æŽ¥ç»Ÿè®¡$size$å³å¯,å¤šæµ‹æ³¨æ„æ¸…ç©º. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;int n,t,idx,Bcnt;int head[N];struct Edge&#123; int to; int next;&#125;e[N&lt;&lt;1];int dfn[N],low[N];int Belong[N],siz[N];inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;stack &lt; int &gt; st;bool instack[N];void Tarjan ( int cur ) &#123; st.push ( cur ); dfn[cur] = low[cur] = ++idx; instack[cur] = 1; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( !dfn[j] ) &#123; Tarjan ( j ); low[cur] = min ( low[cur] , low[j] ); &#125; else if ( instack[j] ) low[cur] = min ( low[cur] , dfn[j] ); &#125; int k; if ( dfn[cur] == low[cur] ) &#123; Bcnt++; do &#123; k = st.top (); instack[k] = 0; st.pop (); Belong[k] = Bcnt; siz[Belong[k]]++; &#125; while ( k != cur ); &#125; return;&#125;int main ( void ) &#123; ios :: sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; t=0; memset(head,0,sizeof(head)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int to; cin&gt;&gt;to; add(i,to); &#125; for(int i=1;i&lt;=n;i++) if (!dfn[i] ) &#123; while(!st.empty()) st.pop(); Tarjan(i); &#125; //cout&lt;&lt;t&lt;&lt;endl; for(int i=1;i&lt;=n;i++) cout&lt;&lt;siz[Belong[i]]&lt;&lt;" "; cout&lt;&lt;endl; &#125; return 0;&#125; Good Numbers (easy version)æ€è·¯æˆ‘ä»¬å‘çŽ°åœ¨$3^i&lt;=10000$çš„æƒ…å†µä¸‹$i$æœ€å¤§åªåˆ°$10$,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥$2^{log_3n}$çš„æ—¶é—´å¤æ‚åº¦æžšä¸¾ä¸€ä¸‹æ‰€æœ‰çš„$good$æ•°,æ¯æ¬¡è¯¢é—®æ—¶$check$ä¸€ä¸‹å³å¯. ä»£ç 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int n,idx;int num[10004];inline int ksm(int x,int y)&#123; int res=1; while(y)&#123; if(y&amp;1) res*=x; x=x*x; y&gt;&gt;=1; &#125; return res;&#125;int main ( void ) &#123; ios :: sync_with_stdio(false); cin.tie(0),cout.tie(0); for(int i=1;i&lt;=(1&lt;&lt;10)-1;i++)&#123; int now=0; for(int j=0;j&lt;=10;j++) if(i&amp;(1&lt;&lt;j)) now=now+ksm(3,j); num[++idx]=now; &#125; sort(num+1,num+1+idx); int T; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=idx;i++) if(num[i]&gt;=n)&#123; cout&lt;&lt;num[i]&lt;&lt;endl; break; &#125; &#125; return 0;&#125; Good Numbers (hard version)æ€è·¯è€ƒè™‘$C1$ä¸­çš„æ€è·¯å‘çŽ°è¿™æ ·æžšä¸¾çš„è¯å¤ªè´¹äº‹äº†.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆæ‰¾åˆ°ä¸€ä¸ªå°äºŽ$n$çš„$good$æ•°,è€Œè¿™ä¸ªæ•°æ˜¾ç„¶å¯ä»¥è´ªå¿ƒçš„åœ¨$O(log_3n)$çš„å¤æ‚åº¦å†…æ±‚å‡ºæ¥.ç„¶åŽæˆ‘ä»¬è€ƒè™‘æ€Žä¹ˆè®©è¿™ä¸ªæ•°å­—å¢žåŠ .æˆ‘ä»¬ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºæ¯ä¸ª$3^i$æ˜¯å¦è¢«åŠ å…¥åˆ°è¿™ä¸ªæ•°å­—é‡Œ,é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å‘çŽ°æˆ‘ä»¬è¦åšçš„å°±æ˜¯æ‰¾åˆ°ä¸€ä¸ªäºŒè¿›åˆ¶ä¸‹æœ€å·¦è¾¹çš„å³è¾¹æ˜¯$0$çš„$1$,æŠŠ$0$å˜æˆ$1$,ç„¶åŽæŠŠå‰è¾¹çš„$1$éƒ½å˜æˆ$0$ç„¶åŽç»Ÿè®¡æ–°çš„æ•°å­—æ˜¯ä»€ä¹ˆå³å¯. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n;bool used[42];inline int ksm(int x,int y)&#123; int res=1; while(y)&#123; if(y&amp;1) res*=x; x=x*x; y&gt;&gt;=1; &#125; return res;&#125;signed main ( void ) &#123; ios :: sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; memset(used,0,sizeof(used)); cin&gt;&gt;n; int tmp=n,res=0; int MAX=40,MAXX=-1; while(tmp)&#123; int sign=0; if(MAX&lt;=0) break; for(int i=0;i&lt;MAX;i++)&#123; if(ksm(3,i)&gt;tmp)&#123; MAXX=max(MAXX,i); break; &#125; sign=i; &#125; used[sign]=1; tmp-=ksm(3,sign); res+=ksm(3,sign); MAX=sign; &#125; if(res==n) cout&lt;&lt;res&lt;&lt;endl; else&#123; int sign; for(int i=40;i&gt;=0;i--) if(used[i])&#123; sign=i; break; &#125; int css=0; for(int i=0;i&lt;=sign;i++)&#123; if(used[i]==1&amp;&amp;used[i+1]==0)&#123; css = ksm ( 3 , i + 1 ); for ( int j = i + 2 ; j &lt;= sign ; j++ ) if ( used[j] ) css = css + ksm ( 3 , j ); break; &#125; &#125; cout &lt;&lt;css &lt;&lt; endl; &#125; &#125; return 0;&#125; Too Many Segments (easy version)æ€è·¯å‘çŽ°æˆ‘ä»¬åªéœ€è¦æ¯æ¬¡æ‰¾åˆ°ä¸€ä¸ªè¢«è¦†ç›–æ¬¡æ•°å¤§äºŽ$k$çš„ç‚¹,ç„¶åŽå¯»æ‰¾ä¸€ä¸‹è¦†ç›–äº†è¿™ä¸ªç‚¹çš„åŒºé—´ä¸­å³ç«¯ç‚¹æœ€é å³çš„è´ªå¿ƒçš„åˆ åŽ»å³å¯.æ—¶é—´å¤æ‚åº¦$O(n^2)$. ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 205;int n , k;struct Sen &#123; int l,r,id; &#125; se[N];bool use[N];int num[N];int opt[N] , ans;int main ( void ) &#123; ios :: sync_with_stdio ( false ); cin.tie ( 0 ) , cout.tie ( 0 ); cin &gt;&gt; n &gt;&gt; k; int MinLim = 2147483647 , MaxLim = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; cin &gt;&gt; se[i].l &gt;&gt; se[i].r; se[i].id = i; MinLim = min ( MinLim , se[i].l ) , MaxLim = max ( MaxLim , se[i].r );&#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = se[i].l ; j &lt;= se[i].r ;j++ ) num[j]++; for ( int i = MinLim ; i &lt;= MaxLim ; i++ ) &#123; while ( num[i] &gt; k ) &#123; int MaxDisTanceR = -1 , MaxDisTanceSign = -1; for ( int j = 1 ; j &lt;= n ; j++ ) if ( se[j].l &lt;= i &amp;&amp; se[j].r &gt;= i &amp;&amp; !use[j] ) if ( MaxDisTanceR &lt; se[j].r ) &#123; MaxDisTanceR = se[j].r , MaxDisTanceSign = j;&#125; use[MaxDisTanceSign] = 1; opt[++ans] = MaxDisTanceSign; for ( int j = se[MaxDisTanceSign].l ; j &lt;= se[MaxDisTanceSign].r ; j++ ) num[j]--; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; for ( int i = 1 ; i &lt;= ans ; i++ ) cout &lt;&lt; opt[i] &lt;&lt; " "; return 0;&#125; Too Many Segments (hard version)æ€è·¯æˆ‘ä»¬å‘çŽ°æŒ‰ç…§å³ç«¯ç‚¹æŽ’åºä¹‹åŽ,å¯¹äºŽæ¯ä¸ªåŒºé—´,å¦‚æžœå®ƒå³å°†è¦è¦†ç›–çš„è¿™ä¸ªåŒºé—´çš„æœ€å¤§å€¼å°äºŽ$k$çš„è¯,é‚£ä¹ˆç›´æŽ¥è¦†ç›–æ˜¯æ²¡æœ‰é—®é¢˜çš„.å¦åˆ™è€ƒè™‘å¯¹åŽé¢çš„è´¡çŒ®çš„è¯,å¦‚æžœè¿™ä¸ªåŒºé—´ä¹‹å‰çš„åŒºé—´ä¸é€‰æ‹©çš„è¯,é‚£ä¹ˆå‰è¾¹çš„åŒºé—´ä¸é€‰ä¸€å®šæ¯”ä¸é€‰çŽ°åœ¨çš„è¿™ä¸ªåŒºé—´æ›´åŠ£.(å› ä¸ºåˆ é™¤æŽ’åºåŽå‰è¾¹çš„èŠ‚ç‚¹å¯¹åŽé¢çš„è´¡çŒ®æ›´å°).æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥ç»´æŠ¤åŒºé—´$MAX$å’ŒåŒºé—´åŠ çš„æ•°æ®ç»“æž„ç»´æŠ¤å³å¯.(çº¿æ®µæ ‘). ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=2e5+5;int n,k;struct node&#123; int x,y; int id;&#125;sg[MAXN];bool operator &lt;(node a,node b)&#123; return a.y&lt;b.y;&#125;#define lc k&lt;&lt;1#define rc k&lt;&lt;1|1#define ls lc,l,mid#define rs rc,mid+1,rint mx[MAXN&lt;&lt;2],tag[MAXN&lt;&lt;2];inline void add(int k,int v)&#123; mx[k]+=v; tag[k]+=v;&#125;inline void pushup(int k)&#123; mx[k]=max(mx[lc],mx[rc]);&#125;inline void pushdwn(int k)&#123; add(lc,tag[k]); add(rc,tag[k]); tag[k]=0;&#125;int Query(int k,int l,int r,int qx,int qy)&#123; if(qx&lt;=l&amp;&amp;r&lt;=qy) return mx[k]; pushdwn(k); int mid=l+r&gt;&gt;1,res=0; if(qx&lt;=mid) res=max(res,Query(ls,qx,qy)); if(mid&lt;qy) res=max(res,Query(rs,qx,qy)); return res;&#125;void Modify(int k,int l,int r,int qx,int qy)&#123; if(qx&lt;=l&amp;&amp;r&lt;=qy) return add(k,1); pushdwn(k); int mid=l+r&gt;&gt;1; if(qx&lt;=mid) Modify(ls,qx,qy); if(mid&lt;qy) Modify(rs,qx,qy); pushup(k); return ;&#125;int m;bool vis[MAXN];int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;sg[i].x,&amp;sg[i].y),sg[i].id=i; sort(sg+1,sg+n+1); m=n; for(int i=1;i&lt;=n;i++) if(Query(1,1,2e5,sg[i].x,sg[i].y)&lt;k) Modify(1,1,2e5,sg[i].x,sg[i].y),m--,vis[i]=1; printf("%d\n",m); for(int i=1;i&lt;=n;i++) if(!vis[i]) printf("%d ",sg[i].id); puts(""); return 0;&#125; By Elevator or Stairs?æ€è·¯å¯ä»¥å‘çŽ°åœ¨æ¯ä¸€å±‚æ—¶,ä½ æ˜¯åœ¨ç”µæ¢¯ä¸Šè¿˜æ˜¯åœ¨æ¥¼æ¢¯ä¸Šæ˜¯å½±å“ç»§ç»­å‘åŽè½¬ç§»çš„,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¼€$f_{i,j}$è¡¨ç¤ºçŽ°åœ¨ä½äºŽç¬¬$i$å±‚,åœ¨/ä¸åœ¨æ¥¼æ¢¯ä¸Šæ—¶æœ€å°çš„æ—¶é—´èŠ±è´¹.ç„¶åŽè½¬ç§»çš„è¯è€ƒè™‘æ˜¯ä»Žä¸Šä¸€å±‚èµ°æ¥¼æ¢¯æ¥è¿˜æ˜¯èµ°ç”µæ¢¯æ¥å³å¯. ä»£ç 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+10;int n,c;int A[N],B[N],f[N][2];int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; c; for(int i=2;i&lt;=n;i++) cin &gt;&gt; A[i]; for(int i=2;i&lt;=n;i++) cin &gt;&gt; B[i]; cout &lt;&lt; 0 &lt;&lt; " "; memset(f,0x3f3f3f3f,sizeof(f)); f[1][1] = c; f[1][0] = 0; for(int i=2;i&lt;=n;i++)&#123; f[i][0] = min(f[i-1][0]+A[i], f[i-1][1]+A[i]); f[i][1] = min(f[i-1][0]+B[i]+c, f[i-1][1]+B[i]); cout &lt;&lt; min(f[i][0], f[i][1]) &lt;&lt; " " ; &#125; return 0;&#125; Maximum Weight Subsetæ€è·¯update:(å®˜æ–¹é¢˜è§£.æˆ‘åæ­£è¿˜æ²¡æ‡‚)ðŸ˜‚æˆ‘ä»¬è®¾$f_{i,j}$è¡¨ç¤ºçŽ°åœ¨æ˜¯ä»¥$i$ä¸ºæ ¹çš„èŠ‚ç‚¹,é€‰ä¸­çš„ç‚¹æœ€æµ…æ·±åº¦æ˜¯$j$æ—¶åˆ’åˆ†å‡ºå­é›†çš„æœ€å¤§æƒå€¼.åˆå§‹åŒ–æ—¶æ˜¾ç„¶$f_{i,0}=a_i$.æ˜¾ç„¶è¿™ä¸ªæ˜¯åˆšå¼€å§‹æ—¶æ²¡æœ‰å­æ ‘çš„æƒ…å†µ,ç„¶åŽæˆ‘ä»¬ä¸€é¢—é¢—çš„æ·»åŠ å­æ ‘.è€ƒè™‘æ€Žä¹ˆè½¬ç§»:å› ä¸ºæˆ‘ä»¬ä¸€å®šæ˜¯ä»Žåº•å‘ä¸Šè½¬ç§»çš„,æ‰€ä»¥æˆ‘ä»¬å¯¹äºŽæ¯ä¸ªå­æ ‘çš„æ ¹èŠ‚ç‚¹$i$,æžšä¸¾ä¸€ä¸‹è¿™ä¸ªç‚¹æ˜¯ç»§æ‰¿çš„å“ªä¸€é¢—å­æ ‘çš„$f$,åŒæ—¶æˆ‘ä»¬è¿˜è¦è€ƒè™‘å…¶ä»–å­æ ‘å¯¹ç­”æ¡ˆçš„è´¡çŒ®å€¼,æ˜¾ç„¶,è·ç¦»å¯ä»¥ç›´æŽ¥è¿›è¡Œè½¬ç§»).æ€»çš„æ–¹ç¨‹ä¸º:$f_{v,dep}=max(f_{v,dep},(dep==0?a_v:f_{v,dep-1})+\sum_{son_v}f_{son,max(dep-1,k-dep-1)})$.æœ€ç»ˆç­”æ¡ˆå³ä¸º$f_{0,0}$ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 210; int n, k;vector&lt;int&gt; a;vector&lt;vector&lt;int&gt;&gt; g, dp; void dfs(int v, int p) &#123; dp[v][0] = a[v]; for (auto to : g[v]) if (to != p) \ dfs(to, v); for (int dep = 0; dep &lt; N; ++dep) &#123; if (dep == 0) &#123; for (auto to : g[v]) &#123; if (to == p) continue; dp[v][dep] += dp[to][max(0, k - dep - 1)]; &#125; &#125; else &#123; for (auto to : g[v]) &#123; if (to == p) continue; int cur = dp[to][dep - 1]; for (auto other : g[v]) &#123; if (other == p || other == to) continue; cur += dp[other][max(dep - 1, k - dep - 1)]; &#125; dp[v][dep] = max(dp[v][dep], cur); &#125; &#125; &#125; for (int dep = N - 1; dep &gt; 0; --dep) dp[v][dep - 1] = max(dp[v][dep - 1], dp[v][dep]); return;&#125; int main() &#123; cin &gt;&gt; n &gt;&gt; k; ++k; a = vector&lt;int&gt;(n); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; &#125; g = vector&lt;vector&lt;int&gt;&gt;(n); for (int i = 0; i &lt; n - 1; ++i) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; --x, --y; g[x].push_back(y); g[y].push_back(x); &#125; dp = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(N)); dfs(0, -1); cout &lt;&lt; dp[0][0] &lt;&lt; endl; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æé«˜å¤±è”æµ‹D7]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E8%81%94%E6%B5%8BD7%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€. dlsçš„ç”Ÿæ—¥ç¤¼ç‰©è¿˜æ˜¯é¦–å…ˆè€ƒè™‘æ— è§£çš„è¯ä¼šæ˜¯ä»€ä¹ˆæƒ…å†µ,æ— è§£çš„è¯,ä¸€å®šæ˜¯æŸä¸€æ®µé•¿åº¦å¤§äºŽ$1$çš„åŒºé—´è¢«è¦†ç›–äº†ä¸¤æ¬¡ä»¥ä¸Š,è¿™ä¸ªæ˜¾ç„¶å¯ä»¥ç¦»æ•£åŒ–æ¥ç»Ÿè®¡.ç„¶åŽæˆ‘ä»¬å†æ¥æƒ³æœ‰è§£çš„æƒ…å†µ,æˆ‘ä»¬è€ƒè™‘,è¿™é“é¢˜è®©ä½ æŠŠåŽŸæ¥çš„åŒºé—´åˆ†æˆä¸¤ä¸ªé›†åˆ,è€Œç›¸äº¤çš„åŒºé—´å¿…é¡»é¢œè‰²ä¸åŒ.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘åˆ°äºŒåˆ†å›¾æ¨¡åž‹.å¦‚æžœä¸¤ä¸ªåŒºé—´ç›¸äº¤çš„è¯,é‚£ä¹ˆè¿™ä¸¤ä¸ªåŒºé—´æ˜¯è¦æœ‰è¾¹ç›¸è¿žçš„.è€Œå› ä¸ºæˆ‘ä»¬å·²ç»æŽ’é™¤äº†æ— è§£çš„æƒ…å†µ,æ‰€ä»¥æœ‰è§£çš„æƒ…å†µä¸€å®šä¼šæ˜¯ä¸€å¼ äºŒåˆ†å›¾.å³æ‰€æœ‰çš„è¿žé€šå—éƒ½æ˜¯äºŒåˆ†å›¾.ä½†æ˜¯æˆ‘ä»¬å‘çŽ°,å¦‚æžœæš´åŠ›æžšä¸¾åŒºé—´è¿žè¾¹çš„è¯æ˜¯$O(n^2)$çš„,éœ€è¦è€ƒè™‘æ€Žä¹ˆä¼˜åŒ–.æˆ‘ä»¬åˆå‘çŽ°åœ¨æŸä¸ªè¿žé€šå—ä¸­,å› ä¸ºè¿žé€šå—ä¸­çš„ç‚¹éƒ½æ˜¯åŒºé—´çœ‹æˆçš„ç‚¹,æ‰€ä»¥ä¸€ä¸ªè¿žé€šå—ä¹Ÿå°±ä»£è¡¨äº†ä¸€ä¸ªåŒºé—´,æˆ‘ä»¬åªéœ€è¦è€ƒè™‘ä¸€ä¸‹äº’ä¸ç›¸äº¤çš„è¿žé€šå—çš„ä¸ªæ•°$x$ç„¶åŽç­”æ¡ˆå°±æ˜¯$2^x$. dlsçš„ç”Ÿæ—¥å®´ä¼šé¦–å…ˆæˆ‘ä»¬å‘çŽ°,å¦‚æžœæˆ‘ä»¬æŒ‰ç…§$k=\frac{n}{2} , \frac{n}{4} , \frac{n}{8}$ä¸æ–­é€‰å–$k$çš„å€¼çš„è¯,é‚£ä¹ˆè½®æ•°ä¸º$logn$è½®,å³è½®æ•°æœ€å¤šä¸º$logn$(å‘ä¸Šå–æ•´)è½®.æˆ‘ä»¬å‡è®¾æˆ‘ä»¬ä¸€å…±æ“ä½œäº†$m$è½®,ç¬¬$i$è½®æˆ‘ä»¬é€‰æ‹©çš„$k$çš„å€¼ä¸º$k_i$,é‚£ä¹ˆå¦‚æžœæ»¡è¶³èƒ½æ‰¾åˆ°$dls$çš„è¯,éœ€è¦æ»¡è¶³ m]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Global Round 5é¢˜è§£]]></title>
    <url>%2F2019%2F10%2F21%2FGrobalRound5%2F</url>
    <content type="text"><![CDATA[ä¼ è¯´ä¸­é›†é½äº†äº”é¢—æ— é™å®çŸ³çš„$tourist$ä¸€ä¸ªå“æŒ‡èƒ½è®©æ‰€æœ‰äººçš„$rating$æ¶ˆå¤±ä¸€åŠ Balanced Rating Changeså‘çŽ°åœ¨ç­”æ¡ˆä¸€å®šå­˜åœ¨çš„æƒ…å†µä¸‹,å¯¹äºŽæ¯ä¸ªå¶æ•°,ä¸€å®šæ˜¯ç›´æŽ¥æŠŠ$i$å˜æˆ$\frac{i}{2}$.æˆ‘ä»¬è¦è€ƒè™‘çš„å°±åªæœ‰å¥‡æ•°çš„æƒ…å†µ.æ˜¾ç„¶,å¯¹äºŽæ¯ä¸ªæ­£æ•°å¥‡æ•°å’Œæ¯ä¸ªè´Ÿæ•°å¥‡æ•°,ä»–ä»¬åˆ†åˆ«å‘ä¸Šå–æ•´å’Œå‘ä¸‹å–æ•´çš„æ¬¡æ•°åº”è¯¥æ˜¯ä¸€æ ·å¤šçš„.æ‰€ä»¥æˆ‘ä»¬ä¸å¦‚é’¦å®šåˆšå¼€å§‹æ— è®ºæ­£çš„å¥‡æ•°å‘ä¸‹å–æ•´,è´Ÿçš„å¥‡æ•°å‘ä¸Šå–æ•´,ç„¶åŽæ‰«ä¸€é$check$å³å¯.12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int change;int num[20000],ans[20000];int main()&#123; int T; scanf("%d",&amp;T); for(int i=1;i&lt;=T;i++)&#123; scanf("%d",&amp;num[i]); ans[i]=num[i]/2; change+=ans[i]; &#125; if(change==0) for(int i=1;i&lt;=T;i++) printf("%d\n",ans[i]); else&#123; if(change&gt;0)&#123; for(int i=1;i&lt;=T&amp;&amp;change!=0;i++)&#123; if(num[i]&lt;0&amp;&amp;num[i]%2==-1)&#123; change--; ans[i]--; &#125; &#125; &#125; else for(int i=1;i&lt;=T&amp;&amp;change!=0;i++) if(num[i]%2==1&amp;&amp;num[i]&gt;0)&#123; ans[i]++; change++; &#125; for(int i=1;i&lt;=T;i++) printf("%d\n",ans[i]); &#125; return 0;&#125; Balanced Tunnelè€ƒè™‘å¦‚æžœæœ‰ä¸€è¾†è½¦åœ¨è¿›å…¥éš§é“è¡Œä½¿çš„è¿‡ç¨‹ä¸­æ²¡æœ‰è¢«å…¶ä»–è½¦è¶…è½¦çš„è¯,é‚£ä¹ˆæœ¬æ¥åœ¨å®ƒå‰è¾¹çš„è½¦å‡ºåŽ»ä¹‹åŽåº”è¯¥è¿˜åœ¨å®ƒå‰è¾¹(åºŸè¯).è€ƒè™‘æ€Žä¹ˆåˆ¤æ–­è¿™ä¸ªä¸œè¥¿,æˆ‘ä»¬å¯¹äºŽåˆå§‹ä½ç½®çš„è½¦è¾†,æˆ‘ä»¬è®°å½•ä¸€ä¸ª$id_i$,å³åˆå§‹åœ¨$i$è¿™ä¸ªä½ç½®çš„è½¦è¾†,å®ƒçš„$id$ä¸º$i$.ç„¶åŽæˆ‘ä»¬å‘çŽ°åœ¨$id$è¿™ä¸ªä¸œè¥¿,å¦‚æžœæœ‰ä¸€è¾†è½¦$j$åœ¨è½¦$i$çš„å‰æ–¹,é‚£ä¹ˆ$id_j$ä¸€å®šå¤§äºŽ$id_i$.è€Œå¦‚æžœæœ¬æ¥æœ‰ä¸€è¾†è½¦åœ¨å®ƒåŽè¾¹è¶…è¿‡äº†å®ƒ,é‚£ä¹ˆåœ¨æ–°çš„è½¦è¾†ä¸­ä¸€å®šæœ‰ä¸€ä¸ª$max(id_{i+1}â€¦id_{n})&gt;id_i$(æ³¨æ„è¿™é‡Œçš„æ ‡å·ä¸ºé‡æŽ’ä¹‹åŽçš„æ ‡å·.)é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦è®°å½•ä¸€ä¸ªé‡æŽ’ä¹‹åŽçš„è½¦çš„$id$çš„åŽç¼€æœ€å¤§å€¼,ç„¶åŽå¯¹äºŽæ¯è¾†è½¦$i$,æˆ‘ä»¬$check$ä¸€ä¸‹å‰ç¼€æœ€å¤§å€¼æ˜¯ä¸æ˜¯æœ‰æ¯”å®ƒå°çš„ä»Žè€Œå¯ä»¥ä¸é‡ä¸æ¼çš„$check$å®ƒæœ‰æ²¡æœ‰è¶…è½¦,ç„¶åŽç»Ÿè®¡ç­”æ¡ˆå³å¯.123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+10;int n;int pos[N],fin[N];int mins[N];int main()&#123; memset(mins,0x3f,sizeof(mins)); ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; pos[x]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; fin[i]=pos[x]; &#125; for(int i=n;i&gt;=1;i--) mins[i]=min(mins[i+1],fin[i]); int ans=0; for(int i=1;i&lt;n;i++) if(mins[i+1]&lt;fin[i]) ans++; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Balanced Removals (Easier)å‘çŽ°æˆ‘ä»¬éœ€è¦ä¸€ä¸ª$O(n^2)$çš„ç®—æ³•.æˆ‘ä»¬å‘çŽ°å¯¹äºŽæŸä¸ªç‚¹$i$,é‚£ä¹ˆè·ç¦»å®ƒæœ€è¿‘çš„ç‚¹ä¸€å®šæ˜¯æœ€ä¼˜çš„(å› ä¸ºä¸­é—´ä¸å¯èƒ½æœ‰å…¶ä»–çš„ç‚¹).æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å¯¹äºŽæ¯ä¸ªç‚¹æžšä¸¾ä¸€ä¸‹ç›®å‰æ²¡æœ‰ç”¨è¿‡çš„ç‚¹ä¸­è·ç¦»å®ƒæœ€è¿‘çš„ç‚¹å³å¯.1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=2005;int n;struct Node&#123; int x,y,z;&#125; node[N];bool rem[N];inline int calc(int x,int y)&#123; return abs(node[x].x-node[y].x)+abs(node[x].y-node[y].y)+abs(node[x].z-node[y].z);&#125;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;node[i].x&gt;&gt;node[i].y&gt;&gt;node[i].z; for(int i=1;i&lt;=n;i++)&#123; if(rem[i]) continue; int mins=1e16,sign; for(int j=i+1;j&lt;=n;j++)&#123; if(rem[j]) continue; int val=calc(i,j); if(val&lt;mins)&#123; mins=val; sign=j; &#125; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;sign&lt;&lt;endl; rem[i]=1; rem[sign]=1; &#125; return 0;&#125; Balanced Removals (Harder)å‘çŽ°æˆ‘ä»¬éœ€è¦ä¸€ä¸ª$O(nlogn)$çš„ç®—æ³•.è€Œç›´æŽ¥ä¼˜åŒ–$Eazy$éš¾åº¦çš„ç®—æ³•è²Œä¼¼ä¸æ€Žä¹ˆå¯èƒ½,æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘æ¢æ–¹æ³•.æˆ‘ä»¬é¦–å…ˆæƒ³æ€Žä¹ˆé™ç»´,æˆ‘ä»¬å¯¹äºŽ$x$å’Œ$y$ç›¸ç­‰çš„å…ˆç”¨è´ªå¿ƒå–æœ€çŸ­çš„å¤„ç†çš„è¯,é‚£ä¹ˆå‘çŽ°$z$è¿™ä¸€ç»´å°±æ²¡å•¥ç”¨äº†.é‚£ä¹ˆè¿™ä¸ªé—®é¢˜å°±è½¬åŒ–æˆäº†äºŒç»´çš„é—®é¢˜,ç„¶åŽæˆ‘ä»¬å†å¯¹äºŽæ‰€æœ‰$x$ç›¸ç­‰çš„é‡å¤è´ªå¿ƒå–æœ€çŸ­å¤„ç†,è¿™æ ·çš„è¯æˆ‘ä»¬åªéœ€è¦æŽ’ä¸¤æ¬¡åºå³å¯. å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æŸ¯å­¦ä¸Šç½‘æ•™ç¨‹]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%9F%AF%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[æ„Ÿè§‰æˆ‘äººè¦æ²¡.jpg â€œæ¬¸,ä½ ä¸ºå•¥èƒ½ä¸ŠGoogleå•Š?â€è¿™éƒ½$9102$å¹´äº†,å¦‚æžœä½ è¿˜è¯´ä½ æ˜¯ç”¨çš„æŸè™šæ‹Ÿä¸“çº¿ç½‘ç»œçš„è¯é‚£ä½ å°±8å¤ªå½³äºäº†.æ¯•ç«Ÿâ€¦å›½å¤–ç”¨ç€é è°±çš„é‚£äº›ä¸œè¥¿,ä»–ä»¬çš„ä»·æ ¼æ˜¯è¿™æ ·çš„:è¿™æ ·çš„è¿˜æœ‰è¿™æ ·çš„ emmmmmâ€¦å¦‚æžœä½ å®¶é‡Œæœ‰çŸ¿çš„è¯ä½ çŽ°åœ¨å¯ä»¥ä¸è¦å¾€ä¸‹é˜…è¯»äº†. æ˜¾ç„¶å¯¹äºŽä¸€èˆ¬çš„å®¶é‡Œæ²¡çŸ¿çš„æ™®é€šäººæ¥è¯´,è¿™ä¸œè¥¿çš„ä»·æ ¼æ˜¾ç„¶ä¸çŽ°å®žå¯¹è¶´.æ‰€ä»¥æ€Žä¹ˆåŠžå‘¢? æ²¡é’±,æ²¡åŠžæ³•,æ²¡é’±ä½ æƒ³ä»€ä¹ˆæŸ¯å­¦ä¸Šç½‘å…¶å®žç™¾åº¦ä¹ŸæŒºå¥½ç”¨çš„,ä¸è¦æƒ³ç€ç”¨$Google$äº†,å¥½å¥½çš„åšä¸€ä¸ªç¤¾ä¼šä¸»ä¹‰å¥½é’å¹´è¶´(doge).]]></content>
      <categories>
        <category>å¹æ°´</category>
      </categories>
      <tags>
        <tag>æŸ¯å­¦ä¸Šç½‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å››å¤§å›¾åºŠç¨³å®šæ€§æµ‹è¯•]]></title>
    <url>%2F2019%2F10%2F21%2F%E5%9B%9B%E5%A4%A7%E5%9B%BE%E5%BA%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%B5%8B%E8%AF%95x%2F</url>
    <content type="text"><![CDATA[ä¼—æ‰€å‘¨çŸ¥çš„360,æ–°æµª,ç™¾åº¦,æœç‹—å›¾åºŠ,åˆ°åº•è°æœ€å®¹æ˜“æŒ‚ç¨³å®šå‘¢ ç»Ÿä¸€ä¸Šä¼ ä¸€å¼ å›¾,çœ‹çœ‹å“ªä¸€ä¸ªå›¾åºŠæœ€åŽæŒ‚æŽ‰(æˆ‘æ„Ÿè§‰é€€å½¹ä¹‹å‰æ˜¯æŒ‚ä¸å®Œäº†) æ–°æµªå›¾åºŠ: æœç‹—å›¾åºŠ:update: 2019-10-23,å®ƒ404äº†(æ–°æµªå›¾åºŠèŽ·èƒœ). ç™¾åº¦å›¾åºŠ:æ‰“å‡èµ›çš„ç™¾åº¦å›¾åºŠé€‰æ‰‹æå‰å€’ä¸‹(doge) 360å›¾åºŠ:æ‰“å‡èµ›çš„360å›¾åºŠé€‰æ‰‹æå‰å€’ä¸‹(doge) æ„Ÿè§‰ç«žäº‰å¹¶ä¸ä¼šå¤ªæ¿€çƒˆ.jpgå•¥çŽ©æ„æœ‰ç«žäº‰å—? æˆ‘è‡ªå·±çš„githubå›¾åºŠ: åšä¸ªå¯¹æ¯”å§ä¸‡ä¸€githubæ²¡äº†å°±å°´å°¬äº† update:æ€»ç»“ä¸€ä¸‹,å› ä¸ºç™¾åº¦å›¾åºŠå’Œ360å›¾åºŠç›´æŽ¥ä¸Šä¼ å¤±è´¥,æ‰€ä»¥åªæœ‰æœç‹—å’Œæ–°æµªå›¾åºŠçš„ç«žäº‰.æœç‹—å›¾åºŠåªå­˜æ´»äº†ä¸¤å¤©â€¦.æ‰€ä»¥è¦æ˜¯æƒ³è¦å­˜å›¾çš„è¯â€¦.è¿˜æ˜¯ç”¨githubçš„å›¾åºŠå§]]></content>
      <categories>
        <category>å¹æ°´</category>
      </categories>
      <tags>
        <tag>æ— èŠ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®è½¬æD5é¢˜è§£]]></title>
    <url>%2F2019%2F10%2F20%2F%E6%99%AE%E8%BD%AC%E6%8F%90D5%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€ Zbox loves keyboardé¦–å…ˆè€ƒè™‘ç›´æŽ¥é€’æŽ¨,ä½†æ˜¯ç”±äºŽ$Backspace$æ“ä½œçš„å­˜åœ¨,ä½¿å¾—å‡ºçŽ°äº†åŽæ•ˆæ€§,æ‰€ä»¥è²Œä¼¼æ— æ³•ç›´æŽ¥é€’æŽ¨.ç„¶åŽæˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹å…ˆä¸è€ƒè™‘$Backspace$æ€Žä¹ˆåš.æˆ‘ä»¬å¼•å…¥å›¾è®ºæ¨¡åž‹,æŠŠ$[1,10^6]$ä¸­çš„æ¯ä¸ªå€¼éƒ½çœ‹åšä¸€ä¸ªç‚¹.ç„¶åŽæˆ‘ä»¬è€ƒè™‘å‰å‡ ä¸ªæ“ä½œ,é‚£ä¹ˆ å¯¹äºŽæ¯ä¸ªç‚¹$x$,ç”±$x$å‘$x+1$è¿žæŽ¥ä¸€æ¡è¾¹. å¯¹äºŽæ¯ä¸ªç‚¹$x$,æˆ‘ä»¬ä»Žå°åˆ°å¤§æžšä¸¾$k$ä½¿å¾—ä»Ž$x$åˆ°$x \times k &lt;= n$è¿žæŽ¥ä¸€æ¡è¾¹. ç„¶åŽæˆ‘ä»¬åªéœ€è¦ä»Ž$x$å‘$n$è·‘ä¸€éæœ€çŸ­è·¯å³å¯(ç›®æµ‹ä¼šå¡æŸæ­»æŽ‰çš„ç®—æ³•).ç„¶åŽæˆ‘ä»¬å†æ¥è€ƒè™‘ä¸€ä¸‹æœ‰$Backspace$æ€Žä¹ˆåš.æˆ‘ä»¬å‘çŽ°,å¦‚æžœæˆ‘ä»¬ä»ŽæŸä¸ªç‚¹$i$è¶…çº§åŠ å€åˆ°äº†$2 \times i$,è€Œ$2 \times i$æ¯”$n$å¤§å¥½å¤šå¥½å¤š,é‚£ä¹ˆæˆ‘ä»¬åœ¨ä¸€ä¸ªä¸€ä¸ª$Backspace$çš„æ—¶å€™ä¸€å®šä¼šé‡åˆ°ä¸€ä¸ª$j (n&lt;j&lt;i)$å¯ä»¥ä»Ž$x$è½¬ç§»åˆ°.æ‰€ä»¥æˆ‘ä»¬çžŽçŒœçœ‹é¢˜è§£çœ‹å‡ºæ¥äº†$Backspace$æ“ä½œçš„ä¸Šç•Œ$100$,ç„¶åŽæˆ‘ä»¬å¯¹äºŽæ¯ä¸ª$i$,éƒ½å‘$[max(1,i-100),i-1]$çš„åŒºé—´çš„ç‚¹è¿žè¾¹å°±å¥½äº†. è¿™æ ·çš„è¯æˆ‘ä»¬è®¡ç®—ä¸€ä¸‹æ—¶é—´å¤æ‚åº¦å‘çŽ°è¾¹çš„æ•°é‡ä¸ºè°ƒå’Œçº§æ•°ä¸º$nInn$çš„å¤æ‚åº¦,è€Œæˆ‘ä»¬è·‘ä¸€é$Heap$_$Dijkstra$æ˜¯$O(nlog_2m)$çš„.æ‰€ä»¥æ€»å¤æ‚åº¦ä¸º$O(n{log^2_2n})$.æ³¨æ„åˆ°$n$å…¶å®žæŒºå¤§çš„,æ‰€ä»¥éœ€è¦å¡å¡å¸¸æ•°(æ¯”å¦‚ç”¨æ–æ³¢é‚£å¥‘å †è·‘$Heap$_$Dijkstra$ä»€ä¹ˆçš„) Zbox loves graphè¿™é“é¢˜æ­£è§£å¥½åƒçœŸçš„æ˜¯æš´åŠ›(é¦–å…ˆå‘çŽ°å¦‚æžœæˆ‘ä»¬ç¼©ç‚¹ç¼©å‡ºæ¥ä¸€ä¸ª$DAG$ä¹‹åŽ,å¯¹äºŽæ¯ä¸€ä¸ªå¼ºè¿žé€šåˆ†é‡æˆ‘ä»¬å¯ä»¥å¼€ä¸€ä¸ª$bitset$æ¥ç»Ÿè®¡.ä½†æ˜¯å¦‚æžœå¼ºè¿žé€šåˆ†é‡å¾ˆå¤šçš„è¯ä¸è¡Œ?å‘çŽ°ä¸€ä¸ªé¢˜ç›®ä¸­ç»™å®šçš„ä¸€ä¸ªé‡è¦çš„æ¡ä»¶:å› ä¸ºè¿™æ˜¯ä¸€å¼ éšæœºå›¾,æ‰€ä»¥å¼ºè¿žé€šåˆ†é‡çš„ä¸ªæ•°ä¸€å®šä¸ä¼šå¤ªå¤š,è€Œä¸”å¼±è”é€šåˆ†é‡ä¹Ÿä¸ä¼šå¤ªå¤š.æ—¢ç„¶æ˜¯æš´åŠ›,é‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹æ€Žä¹ˆå¡å¸¸.é¦–å…ˆ$bitset$çš„å¸¸æ•°å°çš„ä¸€æ‰¹.ä½†æ˜¯è²Œä¼¼ç›´æŽ¥åšè¿˜æ˜¯æœ‰ç‚¹å›°éš¾.æˆ‘ä»¬è€ƒè™‘æŠŠæ‰€æœ‰çš„å¼±è”é€šåˆ†é‡åˆ†åˆ«æ‹¿å‡ºæ¥å¯¹é‡Œè¾¹çš„ç‚¹è¿›è¡Œé‡æ ‡å·ä¹‹åŽå†åˆ†åˆ«åšå‡ºæ¥,ç„¶åŽç›´æŽ¥å¯¹$bitset$è¿›è¡Œä¸€æ¬¡$or$æ“ä½œè¿™æ ·å¯ä»¥çœåŽ»å¾ˆå¤šæ—¶é—´.å‰©ä¸‹çš„â€¦.ä¸è¯´äº†æˆ‘ç»§ç»­åŽ»å¡å¸¸äº† Zbox loves memoryè¿™ä¸ªçœŸçš„è¿žæ­£è§£æ˜¯å•¥éƒ½ä¸çŸ¥é“å—çŠ¶é“¾è¡¨å¥—$tire$,å—¯è¿™å¾ˆSCP. ISNè¿™é“é¢˜å¬è¯´æ ‘çŠ¶æ•°ç»„ä¼˜åŒ–ä¸‹$DP$å°±è¿‡äº†,å’±ä¹Ÿä¸æ•¢é—®. å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å–çŸ³å­(æ¦‚çŽ‡æœŸæœ›)]]></title>
    <url>%2F2019%2F10%2F16%2F%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%85%A5%E9%97%A8%E5%8F%96%E7%9F%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[æˆ‘çœ‹æˆ‘æ˜¯å®Œå…¨ä¸æ‡‚å“¦ é¢˜é¢:å…¶ä¸­$1&lt;=n&lt;=10^5$,$1&lt;=a_i&lt;=10^9$ é¦–å…ˆæˆ‘ä»¬æŽ¨å¹¿ä¸€ä¸‹,æ¦‚çŽ‡å…·æœ‰å¯åŠ æ€§(ä¹Ÿå«çº¿æ€§æ€§).ç”¨å…¬å¼è§£é‡Šå°±æ˜¯$E(XY)=E(X)+E(Y)$.ç„¶åŽå…·ä½“æŽ¨å¹¿åˆ°è¿™é“é¢˜çš„è¯,æˆ‘ä»¬è®¾$E(t)$è¡¨ç¤ºç­”æ¡ˆ,é‚£ä¹ˆ$E(t)=[\sum_{i=2}^{n}P_i]+1$.å…¶ä¸­$P_i$è¡¨ç¤º$i$è¿™å †åœ¨$1$å·å †ä¹‹å‰è¢«æ‹¿çš„æœŸæœ›.ç„¶åŽå‡è®¾æˆ‘ä»¬æ¯æ¬¡åœ¨$1$å·å †å’Œ$x$å·å †ä¹‹é—´é€‰æ‹©ä¸€å †çš„è¯,é‚£ä¹ˆé€‰æ‹©$x$å·å †è¿˜æ˜¯é€‰æ‹©$1$å·å †ä¹‹é—´çš„ç›¸å¯¹æ¦‚çŽ‡æ˜¯ä¸å—å…¶ä»–å †çŸ³å­å½±å“çš„.å³$P_i=\frac{a_i}{a_i+a_1}$.é‚£ä¹ˆç­”æ¡ˆå¾ˆæ˜¾ç„¶å°±æ˜¯$ans=[\sum_{i=2}^{n}\frac{a_i}{a_1+a_i}]+ 1$æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=1e5+10;int n;double a[N];signed main(void)&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; double ans=1.0; for(int i=2;i&lt;=n;i++) ans=ans+(a[i]/(a[1]+a[i])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ¦‚çŽ‡æœŸæœ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Karen And SpuerMarketé¢˜è§£]]></title>
    <url>%2F2019%2F10%2F16%2FSuperMarket%2F</url>
    <content type="text"><![CDATA[ä¹æ¡å¯æ€œæ˜¯ä¸ªå¯çˆ±çš„å¥³å­©å­é¦–å…ˆå‘çŽ°,é¢˜ç›®ä¸­çš„å¯¹äºŽä½¿ç”¨ä¼˜æƒ åŠµçš„æ¡ä»¶çš„çº¦æŸ,å¦‚æžœå»ºä¸€å¼ å›¾å‡ºæ¥,é‚£ä¹ˆå¾ˆå®¹æ˜“å°±å¯ä»¥å‘çŽ°æ»¡è¶³è¿™æ˜¯ä¸€æ£µæ ‘.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ä½¿ç”¨æ ‘å½¢$DP$æ¥è§£å†³é—®é¢˜.æˆ‘ä»¬è®¾$f_{i,j,0/1}$æ¥è¡¨ç¤ºåœ¨ä»¥$i$ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘ä¸­,é€‰æ‹©$j$ä¸ªä½¿ç”¨ä¼˜æƒ å·,å½“å‰çš„è¿™ä¸ªé€‰/ä¸é€‰æ‹©ä¼˜æƒ å·æ—¶èƒ½å¾—åˆ°çš„æœ€å°èŠ±è´¹.ç„¶åŽè½¬ç§»çš„æ—¶å€™æžšä¸¾ä¸€ä¸‹å­æ ‘,å› ä¸ºä½“ç§¯éƒ½ä¸º$1$,æ‰€ä»¥å¯ä»¥æ ¹æ®ç»å…¸çš„æ ‘ä¸ŠèƒŒåŒ…çš„ä¼˜åŒ–æŠŠè¿™é“é¢˜ä¼˜åŒ–åˆ°$O(n^2)$.è€ƒè™‘ä¸€ä¸‹æ€Žä¹ˆè½¬ç§»,æ˜¾ç„¶,å½“æˆ‘ä»¬å½“å‰åˆ°è¾¾çš„$i$è¿™ä¸ªèŠ‚ç‚¹ä½¿ç”¨ä¼˜æƒ åˆ¸çš„è¯,é‚£ä¹ˆå®ƒå¯ä»¥ä»Žå®ƒçš„å­æ ‘ä¸­ä½¿ç”¨æˆ–è€…ä¸ç”¨ä¼˜æƒ å·çš„çŠ¶æ€è½¬ç§»è¿‡æ¥,å¦‚æžœå½“å‰çš„è¿™ä¸ªèŠ‚ç‚¹ä¸é€‚ç”¨ä¼˜æƒ åˆ¸çš„è¯,é‚£ä¹ˆå®ƒå°±åªèƒ½ä»Žå®ƒå­æ ‘çš„ä¸ä½¿ç”¨ä¼˜æƒ åˆ¸çš„çŠ¶æ€è½¬ç§»è¿‡æ¥. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define sz(x) ((int) (x).size())#define forn(i,n) for (int i = 0; i &lt; int(n); ++i)#define all(x) (x).begin(), (x).end()typedef long long ll;typedef long long i64;typedef long double ld;const int inf = int(1e9) + int(1e5);const ll infl = ll(2e18) + ll(1e10); const int maxn = 5005;int B;int c[maxn];int d[maxn];vector&lt;int&gt; g[maxn];int n; int kc[maxn][maxn];int kd[maxn][maxn];int cnt[maxn];int buf[2][maxn]; void merge(int *a, int *b, int *to, int c1, int c2) &#123; forn (i, c1 + c2 + 1) to[i] = inf; forn (i, c1 + 1) forn (j, c2 + 1) to[i + j] = min(to[i + j], a[i] + b[j]);&#125; void dfs(int u) &#123; for (int v: g[u]) dfs(v); int q = 0; forn (i, n + 1) buf[q][i] = inf; cnt[u] = 1; buf[q][0] = 0; buf[q][1] = c[u]; for (int v: g[u]) &#123; merge(buf[q], kc[v], buf[q ^ 1], cnt[u], cnt[v]); q ^= 1; cnt[u] += cnt[v]; &#125; forn (i, n + 1) kc[u][i] = buf[q][i]; q = 0; forn (i, n + 1) buf[q][i] = inf; cnt[u] = 1; buf[q][1] = c[u] - d[u]; for (int v: g[u]) &#123; merge(buf[q], kd[v], buf[q ^ 1], cnt[u], cnt[v]); q ^= 1; cnt[u] += cnt[v]; &#125; forn (i, n + 1) kd[u][i] = min(buf[q][i], kc[u][i]);&#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; B; forn (i, n) &#123; cin &gt;&gt; c[i] &gt;&gt; d[i]; if (i) &#123; int x; cin &gt;&gt; x; --x; g[x].push_back(i); &#125; &#125; dfs(0); int p = n; while (kd[0][p] &gt; B) --p; cout &lt;&lt; p &lt;&lt; '\n';&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>æ ‘å½¢DP</tag>
        <tag>èƒŒåŒ…</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces Round #592]]></title>
    <url>%2F2019%2F10%2F15%2FRound-592%2F</url>
    <content type="text"><![CDATA[æˆ‘å¥½èœå•Š Pens and Pencilså‘çŽ°ç›´æŽ¥é™¤ä¸€ä¸‹,ç®—å‡ºæ¥åˆ†åˆ«éœ€è¦å¤šå°‘é“…ç¬”å’Œé’¢ç¬”,æœ€åŽçœ‹ä¸€ä¸‹åŠ èµ·æ¥æ˜¯ä¸æ˜¯å¤§äºŽ$k$å³å¯.æ³¨æ„ä¸€ä¸ªç»†èŠ‚,å‡å¦‚æˆ‘ä»¬æœ‰$8$ä¸ªå·¥ä½œéœ€æ±‚,ç„¶åŽä¸€æ”¯é“…ç¬”å¯ä»¥è§£å†³$3$ä¸ªçš„è¯,é‚£ä¹ˆæˆ‘ä»¬éœ€è¦$3$æ”¯é“…ç¬”.æ‰€ä»¥æˆ‘ä»¬ä¸èƒ½ç›´æŽ¥ç®—$a/x$,è€Œæ˜¯è¦ç®—$(a+(x-1))/x$.1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int T; cin&gt;&gt;T; while(T--)&#123; int a,b,c,d,k; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;k; int ll=(a+(c-1))/c; int rr=(b+(d-1))/d; if(ll+rr&gt;k) puts("-1"); else cout&lt;&lt;ll&lt;&lt; " "&lt;&lt;rr&lt;&lt;endl; &#125; return 0;&#125; Rooms and Staircasesé¦–å…ˆè€ƒè™‘ä¸€ä¸‹èµ°æ¥¼æ¢¯å¯¹ç­”æ¡ˆæœ‰ä»€ä¹ˆå¥½å¤„.å¦‚æžœä¸èµ°æ¥¼æ¢¯çš„è¯,é‚£ä¹ˆç­”æ¡ˆä¸€å®šå°±æ˜¯$n$.æˆ‘ä»¬è®¾ä¸€ä¸ªæ¥¼æ¢¯åœ¨æˆ¿é—´$i$çš„ä½ç½®,é‚£ä¹ˆæˆ‘ä»¬ä»Ž$1$èµ°åˆ°$i$æ—¶,å¦‚æžœé€‰æ‹©ä»Ž$i$è¿™ä¸ªç‚¹èµ°ä¸‹åŽ»çš„è¯.é‚£ä¹ˆå¦‚æžœæˆ‘ä»¬å‘å³èµ°,æ˜¾ç„¶å’Œç›´æŽ¥ä¸èµ°æ¥¼æ¢¯æ²¡åŒºåˆ«.è€Œä¸”æ ¹æ®é¢˜ç›®ä¸­çš„é™å®š,æˆ‘ä»¬å‘åˆå§‹èµ°çš„ä½ç½®çš„åæ–¹å‘èµ°çš„æ—¶å€™å°±ä¸€å®šä¸èƒ½å†å›žæ¥äº†,æ‰€ä»¥æˆ‘ä»¬çš„å†³ç­–å°±æ˜¯åœ¨æ¯ä¸ªæ¥¼æ¢¯çš„åœ°æ–¹,åˆ¤æ–­ä¸€ä¸‹æ˜¯ç»§ç»­èµ°çš„ç­”æ¡ˆæ›´ä¼˜ç§€,è¿˜æ˜¯èµ°å›žåŽ»çš„ç­”æ¡ˆæ›´ä¼˜ç§€,å–æœ€å¤§å€¼å³å¯.123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int n;string s;int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while (T--)&#123; cin&gt;&gt;n&gt;&gt;s; int ans=-1; for(int i=0;i&lt;n;i++) if(s[i]=='1') ans=max(ans,2*(i+1)); int now=1; for(int i=n-1;i&gt;=0;i--)&#123; if(s[i]=='1') ans=max(ans,2*(now)); now++; &#125; if(ans==-1) ans=n; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; The Football SeasonçŽ°åœ¨ä¸ä¼šx. Paint the Treeé¦–å…ˆè€ƒè™‘åˆ¤æ–­ä¸€ä¸‹æ— è§£çš„æƒ…å†µ,ç”±äºŽæ¯ç›¸é‚»çš„ä¸‰ä¸ªç‚¹éƒ½ä¸èƒ½åŒè‰²,è€Œæˆ‘ä»¬åªèƒ½æŠŠè¿™äº›ç‚¹æŸ“æˆä¸‰ç§é¢œè‰².é‚£ä¹ˆè€ƒè™‘æŸä¸ªèŠ‚ç‚¹$i$,å¦‚æžœå’Œ$i$ç›´æŽ¥ç›¸é‚»çš„ç‚¹å¤šäºŽ$2$ä¸ª,é‚£ä¹ˆæ— è®ºå¦‚ä½•éƒ½ä¼šæœ‰ä¸¤ä¸ªèŠ‚ç‚¹åŒè‰²çš„.å‘çŽ°åœ¨ä¸Šå›¾(æ ·ä¾‹äºŒ)ä¸­,å› ä¸ºä¸ŽèŠ‚ç‚¹$3$ç›´æŽ¥ç›¸é‚»çš„ç‚¹ä¸º$3$ä¸ª.æ‰€ä»¥è¿™ä¸ªæƒ…å†µæ˜¯æ— è§£çš„.æ‰€ä»¥å‘çŽ°æœ‰è§£çš„æƒ…å†µåªæœ‰æ˜¯é“¾çš„æƒ…å†µ.è€Œåœ¨ä¸€æ¡é“¾çš„æƒ…å†µä¸‹,å¦‚æžœæˆ‘ä»¬ç¡®å®šäº†å‰ä¸¤ä¸ªèŠ‚ç‚¹çš„é¢œè‰²çš„è¯,é‚£ä¹ˆè¿™æ¡é“¾çš„é¢œè‰²ä¹Ÿæ˜¯ä¸€å®šå¯ä»¥è¢«ç¡®å®šä¸‹æ¥çš„.åˆå› ä¸ºå‰ä¸¤ä¸ªç‚¹çš„é¢œè‰²åªæœ‰$3 \times 2=6$ç§æƒ…å†µ,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æŽ¥æš´åŠ›ç»Ÿè®¡ç­”æ¡ˆå³å¯.æ—¶é—´å¤æ‚åº¦ä¸º$O(6 \times n)$.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 5;int n, tot, rt, len, ansx, ansy;ll f[N][5][5], ans;int fr[N][5][5];int c[5][N];int head[N], deg[N], sen[N], res[N];struct Edge &#123; int u; int v; int next;&#125; e[N &lt;&lt; 1]; inline void addedge(int u, int v) &#123; e[++tot] = (Edge) &#123;u, v, head[u]&#125;; head[u] = tot; e[++tot] = (Edge) &#123;v, u, head[v]&#125;; head[v] = tot; return; &#125; void dfs1(int u, int fa) &#123; sen[++len] = u; for(register int i = head[u]; i; i = e[i].next) &#123; int v = e[i].v; if(v == fa) continue; dfs1(v, u); &#125; return; &#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=4;j++) for(int k=0;k&lt;=4;k++) f[i][j][k]=1e16; for(int i = 1; i &lt;= 3; i++) for(int j = 1; j &lt;= n; j++) cin&gt;&gt;c[i][j]; for(int i = 1; i &lt; n; i++) &#123; int u, v; cin&gt;&gt;u&gt;&gt;v; deg[u]++; deg[v]++; addedge(u, v); &#125; for(int i = 1; i &lt;= n; i++) if(deg[i] &gt;= 3) &#123; puts("-1"); return 0; &#125; for(int i = 1; i &lt;= n; i++) if(deg[i] == 1) &#123; rt = i; break; &#125; dfs1(rt, 0); for(int i = 1; i &lt;= 3; i++) for(int j = 1; j &lt;= 3; j++) &#123; if(i == j) continue; f[2][i][j] = min(f[2][i][j], (ll)c[i][sen[1]] + c[j][sen[2]]); &#125; for(int i = 3; i &lt;= n; i++) for(int j = 1; j &lt;= 3; j++) for(int k = 1; k &lt;= 3; k++) for(int t = 1; t &lt;= 3; t++) &#123; if(j == k || j == t || k == t) continue; if(f[i][k][t] &gt; f[i - 1][j][k] + c[t][sen[i]]) &#123; f[i][k][t] = f[i - 1][j][k] + c[t][sen[i]]; fr[i][k][t] = j; &#125; &#125; ans = f[0][0][0]; for(int i = 1; i &lt;= 3; i++) for(int j = 1; j &lt;= 3; j++) if(f[n][i][j] &lt; ans) &#123; ans = f[n][i][j]; ansx = i; ansy = j; &#125; res[sen[n - 1]] = ansx; res[sen[n]] = ansy; for(int i = n; i &gt;= 3; i--) &#123; int go = fr[i][ansx][ansy]; ansy = ansx; ansx = go; res[sen[i - 2]] = go; &#125; cout&lt;&lt;ans&lt;&lt;endl; for(int i = 1; i &lt;= n; i++) cout&lt;&lt;res[i]&lt;&lt;" "; return 0;&#125; Minimizing Differenceè¿™ä¸æ˜¯ä¸€çœ¼é¢˜å—ä¸ºä»€ä¹ˆè¦æ”¾åˆ°Eä¸Š,æ”¾åˆ°Cä¸Šä¸è¡Œå—å‘çŽ°æˆ‘ä»¬æ¯æ¬¡æ“ä½œçš„è¯è‚¯å®šæ˜¯å¯¹æœ€å¤§å€¼æˆ–è€…æœ€å°å€¼è¿›è¡Œæ“ä½œ.æ‰€ä»¥æˆ‘ä»¬å…ˆæŠŠåŽŸæ¥çš„æ•°ç»„æŽ’åº.ç„¶åŽæˆ‘ä»¬æ¯æ¬¡æžšä¸¾ä¸€ä¸‹æˆ‘ä»¬è¦æŠŠç¬¬å‡ å¤§çš„å’Œç¬¬å‡ å°çš„è¿›è¡Œæ“ä½œ,è€Œè¿™ä¸ªæ“ä½œæ˜¾ç„¶å¯ä»¥åŒæŒ‡é’ˆä¼˜åŒ–.12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int inf = 1e18 + 7;const int N = 1e5 + 10;int n, k,ans;int a[N], sum[N], cnt[N];signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++ i)&#123; cin &gt;&gt; a[i]; cnt[i] = 1; &#125; sort(a + 1, a + n + 1); ans = a[n] - a[1]; for (int i = 0; i &lt; n; ++ i)&#123; int l = 1 + i; int r = n - i; if (l &gt;= r) break; if (l + 1 != r)&#123; int can = k / (i+1); if (can == 0) break; int lim = a[l+1]-a[l] + a[r]-a[r-1]; ans -= min(lim, can); k -= min(lim, can) * (i+1); if (lim &gt; can) break; &#125; if (l + 1 == r)&#123; int can = k / (i+1); if (can == 0) break; int lim = a[r]-a[l]; ans -= min(lim, can); k -= min(lim, can) * (i+1); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROIæ™®è½¬æD4]]></title>
    <url>%2F2019%2F10%2F13%2FZROI%E6%99%AE%E8%BD%AC%E6%8F%90D4%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€ æŽ§åˆ¶äººå¶å‘çŽ°æˆ‘ä»¬åªè¦ç®—å‡ºæ¥åœ¨ä¸€ä¸ªå¾ªçŽ¯ä¸­,åæ ‡çš„å˜åŒ–å€¼$(\Delta x , \Delta y)$.ç„¶åŽå°†å˜åŒ–å€¼åŽ»ä¹˜å¾ªçŽ¯æ—¶é—´çš„ä¸ªæ•°,æœ€åŽå¤šå‡ºæ¥çš„æš´åŠ›å³å¯. å¤æ‚åº¦è®¡ç®—æ¥æˆ‘ä»¬å¼€å§‹ä¸€æ­¥ä¸€æ­¥çš„æŽ¨å…¬å¼(é¢˜ç›®ä¸­è¦æˆ‘ä»¬æ±‚çš„æ—¶é—´å¤æ‚åº¦,å†™æˆå¤šé¡¹å¼çš„å½¢å¼å°±æ˜¯: \sum_{i=1}^n\sum_{j=1}^m\sum_{k=i}^n\sum_{l=j}^m\sum_{x=i}^k\sum_{y=j}^l 1é¦–å…ˆæˆ‘ä»¬å¯ä»¥å‘çŽ°,æœ€åŽçš„$x$å’Œ$y$çš„ä¸¤ç»´,å› ä¸ºæ˜¯ç›´æŽ¥åŠ èµ·æ¥çš„,æ‰€ä»¥å¯ä»¥ç›´æŽ¥å˜æˆ$(l-j+1) \times (k-i+1)$,é‚£ä¹ˆåŽŸæ¥å¼å°±å˜æˆäº† \sum_{i=1}^n\sum_{j=1}^m\sum_{k=i}^n\sum_{l=j}^m(l-j+1) \times (k-i+1)ç„¶åŽæˆ‘ä»¬å‘çŽ°,åŒæ ·çš„$(l-j+1)$å’Œ$(k-i+1)$åˆ†åˆ«éƒ½æ˜¯è¢«ç»Ÿè®¡äº†$(m-j+1)$æ¬¡å’Œ$(n-i+1)$æ¬¡,æ‰€ä»¥ç”±ä¹˜æ³•åˆ†é…å¾‹å¯çŸ¥ \sum_{k=i}^n\sum_{l=j}^m(l-j+1) \times (k-i+1) = \sum_{k=i}^n[\sum_{l=1}^{m-j+1} \times (k-i+1)]å‘çŽ°$(k-i+1)$çš„ç³»æ•°å¯ä»¥ç›´æŽ¥ç­‰å·®æ•°åˆ—æ±‚å’Œ,ç„¶åŽå†å°†$\sum_{k=i}^n$æ‹†å¼€å’Œç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼ä¹‹åŽå°±ä¼šå¾—åˆ° \sum_{i=1}^n\sum_{j=1}^m\sum_{k=i}^n\sum_{l=j}^m(l-j+1) \times (k-i+1) = \sum_{i=1}^n\sum_{j=1}^m\frac{(n-i+1) \times (n-i+2)}{2} \times \frac{(m-j+1) \times (m-j+2)}{2}å°†åˆ†æ¯æå–å‡ºæ¥ä¹‹åŽ,å¯ä»¥å¾—åˆ°åŽŸå¼ç­‰ä»·äºŽ \frac{\sum_{i=1}^n\sum_{j=1}^m (n-i+1) \times (n-i+2) \times (m-j+1) \times (m-j+2)}{4}ç„¶åŽç»§ç»­å›ºå®š$i$,æˆ‘ä»¬å‘çŽ°ç³»æ•°æ»¡è¶³$A_i=i^2+i$,é‚£ä¹ˆæ ¹æ®$\sum_{i=1}^n i^2=\frac{n \times (n+1) \times (2 \times n + 1)}{6}$æœ‰åŽŸå¼ç­‰ä»·äºŽ$[\frac{m \times ( m + 1 ) \times ( 2 \times m + 1) }{6} \times \frac{m \times (m+1)}{2}] \times [\frac{n \times (n+1) \times (2 \times n + 1 )}{6}+\frac{n \times ( n + 1 )}{2}] / 4$é¢„å¤„ç†é€†å…ƒä¹‹åŽå¯ä»¥ç›´æŽ¥$O(1)$æ±‚å‡º å¤å°ä»»åŠ¡æˆ‘ä»¬æ³¨æ„åˆ°$1&lt;=t_i&lt;=10^3$.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨å¾ˆå°‘çš„æ—¶é—´å†…æ€¼åŒç±»æ—¶é—´çš„å¤å°æœºè¿›è¡Œé¢„å¤„ç†.ç”±äºŽæˆ‘ä»¬çŸ¥é“æ¯ä¸ªå¤å°æœºçš„å¯åŠ¨æ—¶é—´,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸‰ä¸ªå€¼.æˆ‘ä»¬ç”¨$c_i$è¡¨ç¤ºå‘¨æœŸä¸º$i$çš„å¤å°æœºä¸ªæ•°,$f_{t,p}$è¡¨ç¤ºå‘¨æœŸä¸º$t$çš„å¤å°æœº,ä¸”å®ƒçš„å·¥ä½œçš„èµ·å§‹æ—¶é—´å¯¹$t$å–è†œä»¥åŽæ˜¯$p$çš„ä¸ªæ•°(åŒæ—¶æˆ‘ä»¬ç”¨$g$)è¡¨ç¤º$f$çš„åŽç¼€å’Œ.åŒæ—¶æˆ‘ä»¬è®°å½•$s_t$è¡¨ç¤ºæ‰€æœ‰å‘¨æœŸä¸º$t$çš„æ—¶é—´çš„å¤å°æœºè¿›å…¥æ‰“å°çŠ¶æ€æ‰€æ¬²è¦çš„$t$çš„æ—¶é—´å‘¨æœŸæœ‰å¤šå°‘ä¸ª.é€šè¿‡å¤„ç†è¿™ä¸‰ä¸ªæ•°ç»„,æˆ‘ä»¬å¯ä»¥å¾ˆå¿«çš„è®¡ç®—åŒç±»å‘¨æœŸçš„å¤è¯»æœºåœ¨ä¸€æ®µæ—¶é—´å†…çš„æ‰“å°ä¸ªæ•°. æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€‰æ‹©äºŒåˆ†ä¸€ä¸ªæ—¶é—´$T$,å‡è®¾æˆ‘ä»¬çŽ°åœ¨æžšä¸¾çš„å¤å°æœºçš„æ—¶é—´å‘¨æœŸä¸º$t$,é‚£ä¹ˆæˆ‘ä»¬å‘çŽ°èƒ½äº§ç”Ÿçš„å¤å°ä»¶ä¸ªæ•°ä¸º$c_t \times (T/t) - s_j - f_{j,Tmodt+1} $ç„¶åŽæˆ‘ä»¬æŠŠæ¯ä¸ªæ—¶é—´çš„åŠ èµ·æ¥å°±æ˜¯ç­”æ¡ˆ. A+B ProblemäºŒç»´æ ‘çŠ¶æ•°ç»„è£¸é¢˜â€¦.ç›´æŽ¥å®‰åˆ©æˆ‘å­¦ä¹ çš„åšå®¢äº†qwq.. å†™çš„æŒºå¥½çš„ä¸€ç¯‡åšå®¢ å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROIæ™®åŠäº”è”æµ‹D3]]></title>
    <url>%2F2019%2F10%2F12%2FZROI%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8BD3%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€. æ—‹é£Žå›žæ—‹æ›²ç”±äºŽå¯èƒ½çš„æƒ…å†µéžå¸¸çš„å°,æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦åˆ¤æ–­ä¸€ä¸‹çš„å‡ ç§æƒ…å†µ: ä»Ž$x$ç›´æŽ¥èµ°åˆ°$y$. ä»Ž$x$èµ°åˆ°$a$,å†ä»Ž$b$èµ°åˆ°$y$. ä»Ž$x$èµ°åˆ°$b$,å†ä»Ž$a$èµ°åˆ°$y$.ç”±äºŽåªæœ‰ä¸‰ç§æƒ…å†µ,ç›´æŽ¥$3$ä¸ª$if$åˆ¤æ–­ä¸€ä¸‹å³å¯. å‡é¢é¥­åº—é¦–å…ˆç¬¬ä¸€ååº”å°±æ˜¯æžšä¸¾æ¯ä¸ªæ•°å­—å–è¿˜æ˜¯ä¸å–,æ‰€ä»¥æˆ‘ä»¬éœ€è¦$2^{size}$æžšä¸¾æ¯ä¸ªæ•°,ä½†æ˜¯æ˜¾ç„¶è¿˜å¾—æžšä¸¾æ¯ä¸ªæ•°çš„é¡ºåº,å¤æ‚åº¦æ˜Žæ˜¾è¿‡ä¸äº†.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘æžšä¸¾$i$æ¥å¾—åˆ°$i^2$.è¿™æ ·çš„è¯,å‘çŽ°æˆ‘ä»¬æœ€å¤šæ˜¯åªéœ€è¦æžšä¸¾åˆ°$\sqrt{10 \times n}$å³å¯.æžšä¸¾çš„æ—¶å€™æ³¨æ„ä¸€ä¸‹å‰ªæž,ä¸ç„¶å°±ä¼š$T$æŽ‰. ç–¯ç‹‚å¤–æ˜Ÿäººå‘çŽ°æˆ‘ä»¬å¯ä»¥æžšä¸¾ä¸€ä¸‹ä¸èƒ½æ”¾å…¥çš„ç‰©å“æ˜¯å“ªä¸ª.é‚£ä¹ˆæ˜¾ç„¶å¦‚æžœç¬¬$i$ä¸ªç‰©å“ä¸èƒ½æ”¾å…¥çš„è¯,é‡é‡æ¯”$i$å°çš„ç‰©å“ä¸€å®šè¦éƒ½è¢«æ”¾è¿›åŽ».ç„¶åŽå†æ¥è€ƒè™‘ä¸€ä¸‹é‡é‡æ¯”$i$å¤§çš„ç‰©å“.å‘çŽ°æˆ‘ä»¬å¯ä»¥ç”¨è®¡æ•°ç±»çš„$01$èƒŒåŒ…æ¥è§£å†³.æœ€åŽéœ€è¦æ³¨æ„ä¸€ç‚¹,å¦‚æžœå…¨éƒ½èƒ½æ”¾è¿›åŽ»çš„è¯,ä¹Ÿéœ€è¦ç®—ä¸€ç§æ–¹æ¡ˆ,æ‰€ä»¥æˆ‘ä»¬è¦æžšä¸¾åˆ°ç¬¬$n+1$ä¸ªç‰©å“. æµæµªåœ°çƒå‘çŽ°ç»´æŠ¤è¿žé€šå—çš„æ¶ˆå¤±çš„è¯,æ˜¾ç„¶ä¸æ€Žä¹ˆå¯åš.æ‰€ä»¥æˆ‘ä»¬å°è¯•ç¦»çº¿,æˆ‘ä»¬æŠŠè¯¢é—®æŒ‰ç…§ä»Žå¤§åˆ°å°æŽ’åº,ç„¶åŽæ¯æ¬¡ä»Žä¸€ä¸ªè¯¢é—®è¿‡æ¸¡åˆ°å¦å¤–ä¸€ä¸ªè¯¢é—®çš„æ—¶å€™,ä¼šå‡ºçŽ°è‹¥å¹²ä¸ªæ–°çš„â€å¤§é™†â€.ç„¶åŽæˆ‘ä»¬çš„ä»»åŠ¡å°±å˜æˆäº†è¿™äº›æ–°çš„å¤§é™†èƒ½ä¸èƒ½å’Œå…¶ä»–çš„è¿žé€šå—è¿žèµ·æ¥.å¯¹äºŽè¿™ä¸€ä¸ªæ“ä½œ,æ˜¾ç„¶æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå¹¶æŸ¥é›†,æ¯æ¬¡åˆ¤æ–­+åˆå¹¶å‡ ä¸ªè¿žé€šå—å³å¯. å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round74é¢˜è§£]]></title>
    <url>%2F2019%2F10%2F10%2FRound74%2F</url>
    <content type="text"><![CDATA[åˆå®‰æŽ’äº†é˜Ÿå‹ä¸€æ‰‹â€¦.. Prime Subtractionå¯ä»¥å‘çŽ°,å¦‚æžœåªæ˜¯ç”¨è´¨æ•°çš„è¯,é‚£ä¹ˆé™¤äº†$1$ä¹‹å¤–çš„æ•°éƒ½æ˜¯å¯ä»¥ç”±è´¨æ•°å‡‘å‡ºæ¥çš„.æ‰€ä»¥åªéœ€è¦åˆ¤æ–­ä¸€æ³¢æ˜¯ä¸æ˜¯ç›¸å·®ä¸º$1$å³å¯.123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long a,b; int T; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;a&gt;&gt;b; if(a-b==1) puts("NO"); else puts("YES"); &#125; return 0;&#125; Kill â€˜Em Allå‘çŽ°å¦‚æžœæˆ‘ä»¬æ‰“äº†ä¸€ä¸ªæŒ‰ç…§åæ ‡æŽ’åºä¹‹åŽä¸­é—´çš„æ•°,é‚£ä¹ˆå¯¹äºŽå³è¾¹çš„æ•°å­—æ¥è¯´ä¸€å®šæ˜¯åŠ£çš„.æ‰€ä»¥æˆ‘ä»¬å‘çŽ°,å¦‚æžœæˆ‘ä»¬æŽ’åºä¹‹åŽ,ä»Žå³å¾€å·¦å¼€å§‹æ‰“çš„è¯,é‚£ä¹ˆå¯¹äºŽç­”æ¡ˆçš„è´¡çŒ®ä¸€å®šä¸ä¼šæ›´åŠ£.æ‰€ä»¥ç›´æŽ¥æŽ’åºä¹‹åŽä»Žå³å¾€å·¦æ‰“ç„¶åŽåˆ¤æ–­å³å¯. 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; return s*w;&#125; const int N=1e5+10;int n,r;int pos[N];bool dis[N];inline bool cmp(int x,int y)&#123; return x&gt;y;&#125;signed main()&#123; int T=read(); while(T--)&#123; memset(dis,0,sizeof(dis)); n=read(),r=read(); for(int i=1;i&lt;=n;i++) pos[i]=read(); sort(pos+1,pos+1+n,cmp); int tag=0,ans=0; for(int i=1;i&lt;=n;i++)&#123; if(dis[pos[i]]) continue; if(pos[i]-tag*r&lt;=0) break; dis[pos[i]]=1; ans++; tag++; &#125; printf("%lld\n",ans); &#125; return 0;&#125; Standard Free2playæˆ‘ä»¬æ¥æ¨¡æ‹Ÿä¸€ä¸‹ä¸€ä¸ªäººä»Žé«˜å¤„åˆ°ä½Žå¤„â€æŽ‰ä¸‹æ¥â€çš„è¿‡ç¨‹.æˆ‘ä»¬å‡è®¾æœ¬æ¥åœ¨å¤–é¢çš„æ˜¯$1$,ä¸åœ¨å¤–é¢çš„æ˜¯$0$.è€ƒè™‘ä¸€ä¸ªåºåˆ—$11100$,å¦‚æžœæˆ‘ä»¬ç«™åœ¨æœ€å·¦è¾¹çš„é‚£ä¸ª$1$ä¸Š,å¦‚æžœæˆ‘ä»¬æƒ³è¦å¾€å³(å³å¾€ä¸‹è·³)çš„è¯,æˆ‘ä»¬ä½¿ç”¨æœ€å·¦è¾¹çš„è¿™ä¸ªæŒ‰é’®,é‚£ä¹ˆåºåˆ—å°±ä¼šå˜æˆ$00100$,è€Œæˆ‘ä»¬çŽ°åœ¨ä½äºŽä¸­é—´çš„é‚£ä¸ª$1$ä¸Š.å‘çŽ°å¦‚æžœæˆ‘ä»¬å½“å‰çš„ä½ç½®åˆ°ä¸‹ä¸€ä¸ª$1$çš„ä½ç½®,å¦‚æžœæ˜¯è¿žç»­çš„$1$çš„åŒºé—´çš„è¯,é‚£ä¹ˆæˆ‘ä»¬ä¸€å®šåªèƒ½è·³å¥‡æ•°ä¸ªæ®µ.å¦‚æžœä¸¤è€…çš„é«˜åº¦å·®å¤§äºŽ$2$(å³è·³ä¸€ä¸‹ä¼šæ‘”æ­»çš„è¯),é‚£ä¹ˆå°±è¦ä¹ˆæ”¹å˜çŽ°åœ¨çš„çŠ¶æ€,è¦ä¹ˆä½¿ç”¨ä¸€ä¸ªè†œæ³•çŸ³.æ˜¾ç„¶,å¦‚æžœæˆ‘ä»¬è¦è·³åˆ°çš„è¿™ä¸ªä½ç½®åˆ°æˆ‘ä»¬çŽ°åœ¨çš„è¿™ä¸ªä½ç½®ä¸­é—´é—´éš”äº†å¶æ•°ä¸ªç´§è´´ç€çš„å³$111$è¿™æ ·çš„è¯,æˆ‘ä»¬å°±éœ€è¦ä½¿ç”¨è†œæ³•çŸ³,å¦åˆ™æˆ‘ä»¬å°±ä¸éœ€è¦ç”¨è†œæ³•çŸ³.ä½†æ˜¯æ³¨æ„ä¸€ä¸‹å‘çŽ°å¼€å¤´å’Œç»“å°¾çš„ä½ç½®æ˜¯ä¸ä¸€æ ·çš„æ‰€ä»¥å¯¹ä½äºŽé¡¶ç«¯å’Œæœ«å°¾çš„æƒ…å†µç‰¹æ®Šè®¨è®ºä¸€ä¸‹å³å¯. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;#define fore(i, l, r) for(int i = int(l); i &lt; int(r); i++)#define sz(a) int((a).size())#define x first#define y secondconst int INF = int(1e9);int h, n;vector&lt;int&gt; p;inline bool read() &#123; if(!(cin &gt;&gt; h &gt;&gt; n)) return false; p.resize(n); fore(i, 0, n) cin &gt;&gt; p[i]; return true;&#125;inline void solve() &#123; int ans = 0; int lf = 0; fore(i, 1, n) &#123; if (i &gt; 0 &amp;&amp; p[i - 1] &gt; p[i] + 1) &#123; if (lf &gt; 0) ans += (i - lf) &amp; 1; else ans += 1 - ((i - lf) &amp; 1); lf = i; &#125; &#125; if (p[n - 1] &gt; 1) &#123; if (lf != 0) ans += (n - lf) &amp; 1; else ans += 1 - ((n - lf) &amp; 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int tc; cin &gt;&gt; tc; while(tc--) &#123; read(); solve(); &#125; return 0;&#125; AB-stringå‘çŽ°ç›´æŽ¥æ±‚çš„è¯è²Œä¼¼ä¸æ€Žä¹ˆå¥½æ±‚,æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ä¸‹æ±‚å‡ºæ‰€æœ‰çš„ä¸å¥½çš„ä¸²ç„¶åŽä»Žæ€»ç­”æ¡ˆä¸­å‡åŽ».è€ƒè™‘æ€Žæ±‚å‡ºæ‰€æœ‰ä¸å¥½çš„å­—ä¸².é¦–å…ˆå‘çŽ°åªæœ‰$A$å’Œ$B$è¿™ä¸¤ç§å­—ç¬¦,é‚£ä¹ˆæœ‰ä¸€ä¸ªå¾ˆæ˜¾ç„¶çš„ç»“è®º:å¦‚æžœ$s_i!=s_{i+1}$æˆ–è€…$s_i!=s_{i-1}$,é‚£ä¹ˆ$s_i$å’Œ$s_{i+1}$æ‰€åœ¨çš„å­—ä¸²ä¸€å®šæ˜¯ä¸å¥½çš„.æ‰€ä»¥æˆ‘ä»¬ç›´æŽ¥æ­£ååˆ¤æ–­ä¸¤è¾¹å³å¯.1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int N=3e5+10;int n;long long ans;char str[N];inline void Solve(int x)&#123; int now=1,d=x; for(int i=2;i&lt;=n;i++)&#123; // cout&lt;&lt;str[i]&lt;&lt;" "&lt;&lt;str[i-1]&lt;&lt;endl;3 if(str[i] == str[i-1]) now++; else &#123; ans -= now-d; now = 1; &#125; &#125; return;&#125; int main()&#123; scanf("%d",&amp;n); scanf("%s",str+1); ans = 1ll*n*(n-1)/2; Solve(0); std::reverse(str+1,str+n+1); Solve(1); printf("%lld\n",ans); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kruscalé‡æž„æ ‘å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2019%2F10%2F09%2FKruskal%E9%87%8D%E6%9E%84%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[å­¦ä¸ä¼šå•Šâ€¦. ä»¥ä¸Šå°±æ˜¯æ€§è´¨,è®²å®Œäº† ä½ ä»¬ä¸è¦æ‰“æˆ‘QAQâ€¦ ä¸€é“ä¾‹é¢˜(è´§è½¦è¿è¾“)æˆ‘ä»¬çœ‹ä¸€ä¸‹ç¬¬äº”æ¡æ€§è´¨,å“Žå¦ˆå‘€è¿™é“é¢˜ä¸æ˜¯è£¸é¢˜å—.æˆ‘ä»¬è·‘ä¸€é$Kruscal$é‡æž„æ ‘,ç„¶åŽè¯¢é—®çš„æ—¶å€™æ¯ä¸¤ä¸ªç‚¹çš„ç­”æ¡ˆ,å°±æ˜¯è¿™ä¸¤ä¸ªåœ¨é‡æž„æ ‘ä¸Š$LCA$çš„ç‚¹æƒ.ç„¶åŽå°±æ²¡äº†. å¦ä¸€é“ä¾‹é¢˜(æœ‰æ²¡æœ‰å¤§ä½¬çŸ¥é“æ˜¯å“ªä¸ªOJä¸Šçš„é¢˜è¯å‘Šè¯‰æˆ‘è°¢è°¢) ç¬¬ä¸€ååº”æ˜¯è€ƒè™‘æ¯æ¡è¾¹åœ¨ä½œä¸ºæƒå€¼æœ€å°çš„è¾¹çš„æ—¶å€™çš„è´¡çŒ®,ä½†æ˜¯å‘çŽ°è¿™æ ·ä¹Ÿå¹¶ä¸å¥½ç»Ÿè®¡æœ€ç»ˆè´¡çŒ®.æ‰€ä»¥æ ¹æ®è¿™ç¯‡åšå®¢çš„æ ‡é¢˜,æˆ‘ä»¬æ¥è€ƒè™‘$Kruscal$é‡æž„æ ‘çš„åšæ³•.æˆ‘ä»¬å‘çŽ°$Kruscal$é‡æž„æ ‘æ»¡è¶³å¤§æ ¹å †çš„æ€§è´¨,é‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘æŸä¸€ä¸ªè¾¹æƒèŠ‚ç‚¹,ä»–æœ‰è´¡çŒ®çš„è·¯å¾„å¾ˆæ˜¾ç„¶æ˜¯å®ƒè¿žæŽ¥çš„å¶å­èŠ‚ç‚¹çš„è·¯å¾„ä¸€ç›´åˆ°æŸä¸ªä¸åœ¨å®ƒå­æ ‘å†…è€Œä¸”çˆ¶äº²èŠ‚ç‚¹å¤§äºŽå®ƒçš„èŠ‚ç‚¹.ä½†æ˜¯å‘çŽ°è¿™æ ·ä¹Ÿå¹¶ä¸å¥½ç»Ÿè®¡æœ€ç»ˆè´¡çŒ®.å‘çŽ°,å¦‚æžœé‡æž„æ ‘æ»¡è¶³å°æ ¹å †çš„æ€§è´¨çš„è¯,é‚£ä¹ˆæˆ‘ä»¬å‘çŽ°ä¸¤ç‚¹é—´è·¯å¾„è¾¹æƒçš„æœ€å°å€¼å°±æ˜¯ä»–ä»¬çš„$LCA$,è¿™æ ·å°±æ–¹ä¾¿ç»Ÿè®¡ç­”æ¡ˆäº†.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘æŠŠæ‰€æœ‰çš„è¾¹æƒåŒä¹˜$-1$,è¿™æ ·ä¹‹åŽå†å»ºé‡æž„æ ‘.ç„¶åŽå°±å¯ä»¥ç»Ÿè®¡ç­”æ¡ˆäº†. è¿˜æœ‰ä¸€é“ä¾‹é¢˜(æœ‰æ²¡æœ‰å¤§ä½¬çŸ¥é“æ˜¯å“ªä¸ªOJä¸Šçš„é¢˜è¯å‘Šè¯‰æˆ‘è°¢è°¢)ä¹Ÿæ˜¯$Kruscal$é‡æž„æ ‘çš„å¥—è·¯é¢˜â€¦å¯¹äºŽè¾¹æƒæœ€å¤§å€¼çš„é™åˆ¶ï¼Œ å®Œå…¨å¯ä»¥ç­‰ä»·åœ°è½¬åŒ–åˆ°å®ƒä»¬åœ¨æœ€å°ç“¶é¢ˆç”Ÿæˆæ ‘ä¸Šè·¯å¾„è¾¹æƒæœ€å¤§å€¼çš„é™åˆ¶ã€‚è€ƒè™‘$Kruskal$é‡æž„æ ‘ä¸Šä¸€ä¸ªç‚¹åœ¨åªå…è®¸èµ°è¾¹æƒ$&lt;=k$çš„è¾¹çš„æƒ…å†µä¸‹èƒ½å¤Ÿåˆ°çš„ç‚¹çš„é›†åˆ,å‘çŽ°å®ƒä»¬æ˜¯ä¸€æ£µå­æ ‘,ä¸”æ ¹ä¸º$s$çš„æŸä¸ªç¥–å…ˆ.å…·ä½“æ¥è¯´,æ˜¯$s$åˆ°æ ¹è·¯å¾„ä¸Šæ·±åº¦æœ€å°çš„ç‚¹æƒ$&lt;=k$çš„ç¥–å…ˆæˆ‘ä»¬å¯ä»¥å€å¢žåœ°æ‰¾åˆ°è¿™ä¸ªç¥–å…ˆ,æŽ¥ä¸‹æ¥é—®é¢˜å°±è½¬åŒ–ä¸ºäº†ç»å…¸é—®é¢˜:æ±‚ä¸€ä¸ªå­æ ‘å½“ä¸­çš„æƒå€¼ç¬¬kå¤§.ä½¿ç”¨ä¸»å¸­æ ‘å¯ä»¥è½»æ¾è§£å†³. æœ€åŽä¸€é“ä¾‹é¢˜(å½’ç¨‹)é¢˜é¢å°±ä¸æ”¾äº†â€¦.å› ä¸ºæ¯å¤©å¼€å§‹çš„æ—¶å€™è½¦çš„ä½ç½®éƒ½ä¼šè¢«é‡ç½®ä¸€æ¬¡,æ‰€ä»¥æˆ‘ä»¬å¯¹äºŽæ¯æ¬¡è¯¢é—®éƒ½å¯ä»¥åœ¨èµ·ç‚¹è¿›è¡Œä¸€æ¬¡$bfs$,ç„¶åŽç­”æ¡ˆå°±æ˜¯è¿™äº›ç‚¹ä¸­åˆ°$1$å·ç‚¹è·ç¦»æœ€å°çš„ç‚¹.ä½†æ˜¯è¿™æ ·â€¦æ˜¾ç„¶è¿‡ä¸äº†â€¦å‘çŽ°æ¯æ¬¡è¿›è¡Œè¯¢é—®çš„æ—¶å€™éƒ½åŽ»$bfs$ä¸€éæ˜¾ç„¶å¤ªæ…¢äº†,è€Œä¸”è¿™é“é¢˜ä¸ºå¼ºåˆ¶åœ¨çº¿,ä¹Ÿä¸èƒ½æŒ‰ç…§è¿™äº›è¯¢é—®çš„æµ·æ‹”æŽ’åº.é‚£ä¹ˆæˆ‘ä»¬æ€Žä¹ˆåŠžå‘¢?æ ¹æ®æ ‡é¢˜,æˆ‘ä»¬å¯ä»¥é€‰æ‹©$Kruscal$é‡æž„æ ‘æ¥è§£å†³æŽ‰è¿™é“é¢˜.é¦–å…ˆæˆ‘ä»¬å‘çŽ°,$Kruscal$é‡æž„æ ‘æ»¡è¶³å¤§æ ¹å †çš„æ€§è´¨,é‚£ä¹ˆæ»¡è¶³æµ·æ‹”å¤§äºŽæ°´ä½çº¿çš„è¾¹ç»„æˆçš„ç‚¹ä¸€å®šæ˜¯æŸä¸€é¢—å­æ ‘.ç„¶åŽæˆ‘ä»¬å¯ä»¥è¿›è¡Œä¸€æ¬¡å †ä¼˜åŒ–çš„$Dijkstra$è¿›è¡Œé¢„å¤„ç†,ç„¶åŽæŠŠ$1$å·ç‚¹åˆ°æ¯ä¸ªç‚¹çš„æœ€çŸ­è·¯çš„é•¿åº¦è®°ä¸ºé‡æž„æ ‘ä¸Šæ–°çš„ç‚¹çš„ç‚¹æƒ.ç„¶åŽå¯¹äºŽæ¯æ¬¡æŸ¥è¯¢,æˆ‘ä»¬çš„ä»»åŠ¡å°±å˜æˆäº†æŸ¥è¯¢æŸé¢—å­æ ‘ä¸­çš„å¶å­çš„æƒå€¼æœ€å°å€¼,è€Œä¸”æ˜¯é™æ€çš„.æ˜¾ç„¶å¯ä»¥$log$çš„å¤æ‚åº¦éšä¾¿æžä¸€æž. å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å›¾è®º</tag>
        <tag>å­¦ä¹ ç¬”è®°</tag>
        <tag>æœ€å°ç”Ÿæˆæ ‘</tag>
        <tag>Kruscalé‡æž„æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF416E]]></title>
    <url>%2F2019%2F10%2F09%2FCF416E%2F</url>
    <content type="text"><![CDATA[$ZROI$æ‚é¢˜é€‰è®²â€¦. çœ‹åˆ°è¿™é“é¢˜ä¹‹åŽ,æˆ‘ä»¬ç¬¬ä¸€ååº”è‚¯å®šæ˜¯ä¸€é$Floyd$.ç„¶åŽè€ƒè™‘ä¸€ä¸‹æ€Žä¹ˆåˆ¤æ–­æŸæ¡è¾¹æ˜¯ä¸æ˜¯è¢«æœ€çŸ­è·¯è¦†ç›–.æœ´ç´ çš„æƒ³æ³•æ˜¯æˆ‘ä»¬æ¯æ¬¡æžšä¸¾è¾¹,ç„¶åŽä»¥è¿™æ¡è¾¹ä¸¤æ¡è¾¹çš„ç«¯ç‚¹$u,v$å†æžšä¸¾è¿™ä¸¤ä¸ªç«¯ç‚¹çš„æ‰€æœ‰æœ€çŸ­è·¯.å³åˆ¤æ–­ dis(s,u)+w+dis(v,t)==dis(s,t)æˆ–è€… dis(s,v)+w+dis(u,t)==dis(s,t)ä½†æ˜¯è¿™æ ·ç»Ÿè®¡ç­”æ¡ˆçš„è¯,ç”±äºŽè¾¹çš„æ¡æ•°ä¸º$n^2$çš„,æ‰€ä»¥è¿™ç§ç®—æ³•çš„æ€»å¤æ‚åº¦ä¸º$O(n^4)$çš„.æ˜¾ç„¶è¿‡ä¸äº†æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹æ€Žä¹ˆä¼˜åŒ–.æˆ‘ä»¬è€ƒè™‘ä¸Šä¸€ä¸ªç®—æ³•çš„æ—¶é—´å¤æ‚åº¦çš„ç“¶é¢ˆ,æ˜¾ç„¶åœ¨æˆ‘ä»¬æžšä¸¾äº†$s,t$ä¹‹åŽ,å› ä¸ºè¿˜éœ€è¦æžšä¸¾æ¯ä¸€æ¡è¾¹,æ‰€ä»¥æžšä¸¾è¾¹æ˜¾ç„¶ä¼šè¶…æ—¶.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹æžšä¸¾å®Œ$s,t$ä¹‹åŽä¸å†æžšä¸¾æ¯ä¸€æ¡è¾¹,è€Œæ˜¯åŽ»æžšä¸¾æ¯ä¸€ä¸ªä¸­è½¬ç‚¹$p$.ç„¶åŽå¦‚æžœæˆ‘ä»¬å‘çŽ° dis(s,p)+dis(p,t)==dis(s,t)é‚£ä¹ˆæ˜¾ç„¶åœ¨$dis(s,p)$ä¸Šä»¥$p$ç»“å°¾çš„è¾¹éƒ½æ˜¯å¯ä»¥è¢«åŠ å…¥çš„.æ‰€ä»¥æˆ‘ä»¬çŽ°åœ¨çš„é—®é¢˜å°±åªå‰©ä¸‹äº†æ€Žä¹ˆæ±‚åœ¨$dis(s,p)$ä¸Šçš„ç‚¹äº†.å‘çŽ°æˆ‘ä»¬å°±ç®—æš´åŠ›æžšä¸¾æ¯æ¡è¾¹ç„¶åŽéªŒè¯ä¹Ÿå¹¶ä¸ä¼šè¶…æ—¶.æ‰€ä»¥ç›´æŽ¥è¿™æ ·åšå°±å¯ä»¥äº† å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GXOI/GZOI2019]æ—…è¡Œè€…]]></title>
    <url>%2F2019%2F10%2F08%2FSNOI2017-%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[$ZROI$æ‚é¢˜é€‰è®²â€¦..å¤šç‚¹æœ€çŸ­è·¯?floydç›´æŽ¥èŽ½å•Šæˆ‘çŸ¥é“ä½ å¾ˆå‹‡,ä½†æ˜¯è¿™é“é¢˜$10^5$çœŸçš„æ²¡æ³•ç›´æŽ¥èŽ½å•Šâ€¦ è€ƒè™‘é‚£$K$ç»„ç‰¹æ®Šçš„ç‚¹,æˆ‘ä»¬å‘çŽ°å¦‚æžœæˆ‘ä»¬æŠŠå®ƒä»¬åˆ†æˆä¸¤ç»„,ç„¶åŽç”±ä¸€ç»„å‘å¦ä¸€ç§è·‘æœ€çŸ­è·¯,å¾ˆæ˜Žæ˜¾å¯ä»¥å¾—åˆ°ç­”æ¡ˆ.ä½†æ˜¯å¾ˆæ˜¾ç„¶ä¸èƒ½åªæ˜¯åˆ†ç»„åˆ†ä¸€æ¬¡.æˆ‘ä»¬è€ƒè™‘ä¼˜åŒ–åˆ†ç»„çš„è¿‡ç¨‹.å‘çŽ°åœ¨è€ƒè™‘äºŒè¿›åˆ¶ä¹‹åŽ,æ¯ä¸¤ä¸ªäº’ä¸ç›¸åŒçš„å€¼ä¸€å®šæœ€å°‘ä¼šæœ‰ä¸€ä¸ªä¸åŒçš„åœ°æ–¹.æ‰€ä»¥æˆ‘ä»¬å¦‚æžœå¯¹äºŽæ¯ä¸ªç‚¹çš„ç¼–å·,æŒ‰ç…§$1&lt;&lt;i$è¿›è¡Œåˆ†ç±»çš„è¯.ä¸€å®šå¯ä»¥ä¿è¯åœ¨æŸä¸€æ¬¡åˆ†ç±»çš„è¿‡ç¨‹ä¸­,æœ‰ä»»æ„ä¸¤ä¸ªç‚¹è¢«åˆ†åˆ°äº†ä¸åŒçš„é›†åˆå†…éƒ¨.æ‰€ä»¥æˆ‘ä»¬å¯¹è¿™$K$ç»„å…³é”®ç‚¹è¿›è¡ŒäºŒè¿›åˆ¶åˆ†ç»„,ç„¶åŽå»ºä¸€ä¸ªè¶…çº§æºç‚¹å’Œä¸€ä¸ªè¶…çº§æ±‡ç‚¹åˆ†åˆ«è¿žæŽ¥å…¥é›†åˆå’Œå‡ºé›†åˆ.ç„¶åŽæŸ¥è¯¢è¿™ä¸ªè¶…çº§æºå’Œè¶…çº§æ±‡ä¹‹é—´çš„æœ€çŸ­è·¯å³å¯. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;inline LL read()&#123; LL x = 0,f = 1; char c = getchar(); while (c != EOF &amp;&amp; !isdigit(c)) &#123;if (c == '-') f = -1;c = getchar();&#125; while (isdigit(c)) &#123;x = x * 10 + c - '0';c = getchar();&#125; return x * f;&#125;inline void write(LL x)&#123; if (x &lt; 0) putchar('-'),x = -x; if (x &gt; 9) write(x/10); putchar(x%10+'0');&#125;inline void writeln(LL x)&#123; write(x),putchar('\n'); &#125;const int N = 100005,M = 500005;int Fr[M&lt;&lt;2],To[M&lt;&lt;2],Ne[M&lt;&lt;2],Dis[M&lt;&lt;2],He1[N],He2[N],_k;inline void add(int *He,int x,int y,int z)&#123; ++_k,Fr[_k] = x,To[_k] = y,Dis[_k] = z,Ne[_k] = He[x],He[x] = _k;&#125;int T,n,m,k,p[N];const LL INF = 1ll&lt;&lt;60;int f1[N],f2[N];LL dis1[N],dis2[N];LL ans;struct Node&#123; int x; LL d; Node (int xx = 0,LL dd = 0)&#123; x = xx,d = dd; &#125; inline bool operator &lt; (Node x) const&#123; return d &gt; x.d; &#125;&#125;t;priority_queue&lt;Node&gt;Heap;void Dij_1()&#123; int i; while (!Heap.empty()) Heap.pop(); for (i = 1; i &lt;= n; ++i) &#123; dis1[i] = INF; f1[i] = -1; &#125; for (i = 1; i &lt;= k; ++i) &#123; dis1[p[i]] = 0; f1[p[i]] = p[i]; Heap.push(Node(p[i],0)); &#125; int p,x; while (!Heap.empty())&#123; t = Heap.top(); Heap.pop(); if (t.d == dis1[t.x]) for (p = He1[t.x]; p ; p = Ne[p]) if (dis1[To[p]] &gt; dis1[t.x] + Dis[p])&#123; dis1[To[p]] = dis1[t.x] + Dis[p]; f1[To[p]] = f1[t.x]; Heap.push(Node(To[p],dis1[To[p]])); &#125; &#125; return;&#125;void Dij_2()&#123; int i; for (i = 1; i &lt;= n; ++i) &#123; dis2[i] = INF; f2[i] = -1; &#125; for (i = 1; i &lt;= k; ++i) &#123; dis2[p[i]] = 0; f2[p[i]] = p[i]; Heap.push(Node(p[i],0)); &#125; int p,x; while (!Heap.empty())&#123; t = Heap.top(); Heap.pop(); if (t.d == dis2[t.x]) for (p = He2[t.x]; p ; p = Ne[p]) if (dis2[To[p]] &gt; dis2[t.x] + Dis[p])&#123; dis2[To[p]] = dis2[t.x] + Dis[p]; f2[To[p]] = f2[t.x]; Heap.push(Node(To[p],dis2[To[p]])); &#125; &#125; return;&#125;int main(void)&#123; int i,u,v,w; T = read(); while (T--)&#123; _k = 0; memset(He1,0,sizeof(He1)); memset(He2,0,sizeof(He2)); n = read(),m = read(),k = read(); while (m--)&#123; u = read(); v = read(); w = read(); if (u^v) &#123; add(He1,u,v,w); add(He2,v,u,w); &#125; &#125; for (i = 1; i &lt;= k; ++i) p[i] = read(); Dij_1(); Dij_2(); ans = INF; for (i = 1; i &lt;= n; ++i) if (f1[i] ^ f2[i]) ans = min(ans,dis1[i] + dis2[i]); for (i = 1; i &lt;= _k; i += 2) if (f1[Fr[i]]^f2[To[i]]) ans = min(ans,dis1[Fr[i]] + dis2[To[i]] + Dis[i]); writeln(ans); &#125; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
        <tag>äºŒè¿›åˆ¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF938Dé¢˜è§£]]></title>
    <url>%2F2019%2F10%2F08%2FCF938D%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$ZROI$æ‚é¢˜é€‰è®²â€¦..åˆšå¼€å§‹çš„æ—¶å€™çœ‹è§é¢˜ç›®ä¸­è¦æ±‚çš„è¿™ä¸ªå¼å­è²Œä¼¼ä¸çŸ¥é“ä»Žä½•å¼€å§‹æƒ³â€¦.é¦–å…ˆå‘çŽ°$2 \times d(i,j)$è¿™ä¸ªä¸œè¥¿å¯ä»¥ç›´æŽ¥åœ¨å­˜è¾¹çš„æ—¶å€™æŠŠè¾¹æƒå˜æˆä¸¤å€å³å¯.ä½†æ˜¯å‰©ä¸‹çš„é‚£ä¸ªåŠ $a_j$è²Œä¼¼å¾ˆéš¾å¤„ç†,æ¯æ¬¡æš´åŠ›æžšä¸¾ä¹ˆ?æ˜¾ç„¶ä¸è¡Œ.æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹,å¯¹äºŽè¿™ä¸ªæ•°æ®èŒƒå›´æ¥è¯´,æ˜¾ç„¶åªèƒ½è·‘ä¸€éæœ€çŸ­è·¯,æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘æ€Žä¹ˆåœ¨ä¸€éæœ€çŸ­è·¯çš„è¿‡ç¨‹ä¸­æ±‚å‡ºæ¯ä¸ªç‚¹çš„ç­”æ¡ˆ.ä½†æ˜¯è¿™æ ·åšçš„è¯,æ˜¾ç„¶è¦æŠŠæ‰€æœ‰çš„$a_i$è”ç³»èµ·æ¥,æ€Žä¹ˆåŠžå‘¢?å»ºè™šç‚¹âˆšæˆ‘ä»¬æ–°å»ºä¸€ä¸ªè™šç‚¹,ç„¶åŽç”±è¿™ä¸ªè™šç‚¹å‘æ¯ä¸ªç‚¹$i$è¿žä¸€æ¡è¾¹æƒä¸º$a_i$çš„è¾¹.ç„¶åŽæˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹åŽŸæ¥çš„é‚£ä¸ªå¼å­,å‘çŽ°è¿™æ ·çš„è¯åŽŸæ¥çš„å¼å­å°±å˜æˆäº†æ±‚$min(2\times d(i,j)+d(new,j))$.å†è€ƒè™‘ä¸€ä¸‹æœ€çŸ­è·¯çš„æ¾å¼›æ“ä½œ,æ˜¯ä¸æ˜¯å‘çŽ°äº†å•¥.æˆ‘ä»¬ç›´æŽ¥ä»Žæ–°å»ºçš„è™šç‚¹å¼€å§‹è·‘ä¸€éæœ€çŸ­è·¯,ç„¶åŽå¯¹äºŽæ¯ä¸ªç‚¹,$dis_i$å°±æ˜¯ç­”æ¡ˆäº†.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define int long long#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , date = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) date = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * date;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , date = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) date = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * date;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 1e6 + 10;int n , m , t;int head[N];struct Edge&#123; int to; int date; int next;&#125;e[N];int dis[N];bool vis[N];std :: priority_queue &lt; std :: pair &lt; int , int &gt; , std :: vector &lt; std :: pair &lt; int , int &gt; &gt; , std :: greater &lt; std :: pair &lt; int , int &gt; &gt; &gt;qu;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].date = z; e[t].next = head[x]; head[x] = t; return;&#125;signed main ( void ) &#123; read ( n , m ); for(int i=1;i&lt;=m;i++)&#123; int x,y,z; read(x,y,z); add(x,y,2*z); add(y,x,2*z); &#125; for(int i=1;i&lt;=n;i++)&#123; int x=_read(); add(n+1,i,x); &#125; memset(dis,0x3f,sizeof(dis)); dis[n+1]=0; qu.push(MP(0,n+1)); while ( !qu.empty () ) &#123; int j = qu.top().se; qu.pop (); if ( vis[j] ) continue; vis[j] = 1; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].date ) &#123; dis[k] = dis[j] + e[i].date; if ( !vis[k] ) qu.push ( MP ( dis[k] , k ) ); &#125; &#125; &#125; F ( i , 1 , n ) printf ( "%lld%c" , dis[i] , i == n ? '\n' : ' ' ); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4479é¢˜è§£]]></title>
    <url>%2F2019%2F10%2F08%2FHDU4479%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$ZROI$æ‚é¢˜æ€»ç»“â€¦ å‘çŽ°æˆ‘ä»¬éœ€è¦ä¿è¯è¾¹æƒé€’å¢ž,ä½†æ˜¯ä¼¼ä¹Žå¹¶æ²¡æœ‰ä»€ä¹ˆæ–¹æ³•.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘å°†è¾¹æƒæŽ’ä¸ªåº,ç„¶åŽå°†è¾¹æƒä»Žå°åˆ°å¤§å¼€å§‹è€ƒè™‘.è¿™æ ·ä¹‹åŽ,å½“æˆ‘ä»¬å…ˆé»˜è®¤è¾¹æƒéƒ½äº’ä¸ç›¸åŒæ—¶,æˆ‘ä»¬æ¯æ¬¡ä»¥ä¸€æ¡è¾¹åŽ»æ›´æ–°å®ƒä¸¤ç«¯çš„èŠ‚ç‚¹.å¦‚æžœèƒ½æ›´æ–°çš„è¯,æ˜¾ç„¶åœ¨ç»è¿‡çš„èŠ‚ç‚¹ä¸Š,ä¸€å®šæ˜¯å…ˆç»è¿‡è¾¹æƒè¾ƒå°çš„è·¯å¾„,å†ç»è¿‡è¾¹æƒè¾ƒå¤§çš„è·¯å¾„.è¿™æ ·ä¹‹åŽå¯ä»¥ä¿è¯æˆ‘ä»¬æ±‚çš„å°±ä¸€å®šæ˜¯é¢˜ç›®ä¸­è¦æ±‚çš„ç­”æ¡ˆ.ç„¶åŽå‘çŽ°å…¶å®žè¾¹æƒå¹¶ä¸æ˜¯äº’ä¸ç›¸åŒçš„,æ‰€ä»¥å¯ä»¥å°†è¾¹æƒä¸€æ ·çš„è¾¹åˆ†æˆä¸€ç»„,æ¯æ¬¡æ“ä½œçš„è¿‡ç¨‹ä¸­åŽ»ç”¨è¿™ç»„ä¸­çš„ä¸€å¨è¾¹åŽ»æ›´æ–°. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; return s*w;&#125;const int N=1e4+10;const int M=1e5+10;const LL oo=0x3f;int n,m,t;LL dis[N];bool updated[N];struct Edge&#123; int from; int to; LL date;&#125;lis[M];int v[N];LL vdis[N];inline bool cmp(Edge x,Edge y)&#123; return x.date&lt;y.date;&#125;inline void work(int l,int r)&#123; int cnt=0; for(int i=l;i&lt;=r;i++)&#123; int ll=lis[i].from,rr=lis[i].to; if(updated[ll]&amp;&amp;dis[rr]&gt;lis[i].date+dis[ll])&#123; v[++cnt]=rr; vdis[cnt]=lis[i].date+dis[ll]; &#125; if(updated[rr]&amp;&amp;dis[ll]&gt;lis[i].date+dis[rr])&#123; v[++cnt]=ll; vdis[cnt]=lis[i].date+dis[rr]; &#125; &#125; for(int i=1;i&lt;=cnt;i++)&#123; dis[v[i]]=min(dis[v[i]],vdis[i]); updated[v[i]]=1; &#125; return;&#125;int main(void)&#123; int T=read(); while(T--)&#123; t=0; memset(updated,0,sizeof(updated)); n=read(),m=read(); for(int i=1;i&lt;=n;i++)dis[i]=oo; dis[1]=0; updated[1]=1; for(int i=1;i&lt;=m;i++)&#123; int x=read(),y=read(); LL z=read(); lis[++t].from=x; lis[t].to=y; lis[t].date=z; &#125; sort(lis+1,lis+1+t,cmp); lis[t+1].date=oo; for(int i=1;i&lt;=t;i++)&#123; int l=lis[i].from,r=lis[i].to; int j; for(j=i+1;j&lt;=t+1;j++) if(lis[j].date!=lis[i].date) break; work(i,j-1); i = j-1; &#125; if(dis[n]&gt;=oo) puts("No answer"); else printf("%lld\n",dis[n]); &#125; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROIå›½åº†ä¸ƒå¤©ä¹D5]]></title>
    <url>%2F2019%2F10%2F07%2FZROI%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%90D5%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€è¦æ˜¯CSPçš„D1è¿™ä¹ˆè€ƒæˆ‘ä¼°è®¡æˆ‘ä»Šå¹´åˆå‡‰äº† æ·»ç»è¿‡è§‚å¯Ÿä¹‹åŽå‘çŽ°,åœ¨æ²¡æœ‰ä»»æ„ä¸‰çº¿å…±ç‚¹çš„æƒ…å†µä¸‹,ç­”æ¡ˆåªå¯èƒ½æ˜¯$1,2,3$å½“ä¸­çš„ä¸€ä¸ª.ç„¶åŽå‘çŽ°ç­”æ¡ˆå§ä¸º$1$çš„æƒ…å†µåªæœ‰åœ¨æ‰€æœ‰ç›´çº¿éƒ½ç›¸äº’å¹³è¡Œæˆ–è€…$n$å°äºŽ$2$çš„æƒ…å†µä¸‹ä¼šæˆç«‹.ç„¶åŽè€ƒè™‘ç­”æ¡ˆä¸º$2$çš„æƒ…å†µ,å‘çŽ°åªæœ‰ä¸¤ç»„å¹³è¡Œçº¿é›†åˆ,è€Œä¸”æ€»çº¿æ®µçš„ä¸ªæ•°å¤§äºŽ$2$çš„æƒ…å†µæ—¶,ä¼šå‘çŽ°ç­”æ¡ˆä¸º$2$.å‰©ä¸‹çš„æƒ…å†µå°±æ˜¯ç­”æ¡ˆä¸º$3$çš„æƒ…å†µ. ç½è£…é¦–å…ˆæŒ‰ç…§å›½çŽ‹æ¸¸æˆçš„å¥—è·¯æ¥æŽ¨ä¸€æ³¢è´ªå¿ƒçš„å¼å­.ç„¶åŽå‘çŽ°å¾—åˆ°äº†$p_i \times t_j &gt; p_j \times t_i$ç§»é¡¹ä¹‹åŽå°±æœ‰$\frac{p_i}{t_i}&gt;\frac{p_j}{t_j}$.ç„¶åŽæˆ‘ä»¬æŒ‰ç…§è¿™ä¸ªä¸œè¥¿æŽ’åº,æ¯æ¬¡ä¿®æ”¹çš„æ—¶å€™éƒ½æš´åŠ›åšä¸€é,æ€»å¤æ‚åº¦ä¸º$O(m\times nlogn)$,å°±å¯ä»¥æ‹¿åˆ°$70$åˆ†çš„å¥½æˆç»©.ç„¶åŽæˆ‘ä»¬åˆå‘çŽ°,æ¯æ¬¡ä¿®æ”¹æ—¶åªä¼šä¿®æ”¹ä¸€ä¸ªç‚¹,è¿™æ ·çš„è¯æ¯æ¬¡ä¿®æ”¹çš„æ—¶å€™éƒ½é‡æ–°åšä¸€é,æ„Ÿè§‰éžå¸¸çš„æµªè´¹.æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹,æˆ‘ä»¬ä¿®æ”¹ä¸€ä¸ªç‚¹çš„æ—¶å€™,å¯¹å…¶ä»–ç‚¹çš„è´¡çŒ®çš„å½±å“.æˆ‘ä»¬å‘çŽ°å¦‚æžœæˆ‘ä»¬ä¿®æ”¹çš„é‚£ä¸ªä½ç½®,åœ¨æŽ’å®Œåºä¹‹åŽåœ¨åŽŸæ¥åºåˆ—ä¸­çš„ä½ç½®ä¸º$pos$çš„è¯,æˆ‘ä»¬å¦‚æžœæŠŠè¿™ä¸ªç‚¹å…ˆåŽ»æŽ‰çš„è¯,é‚£ä¹ˆä»Ž$pos+1$åˆ°$n$çš„ä½ç½®çš„æ•°çš„è´¡çŒ®éƒ½ä¼šå¢žåŠ $t_{pos} \times \sum_{i=pos+1}^np_i$ç„¶åŽæˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹ä¿®æ”¹çš„è¿‡ç¨‹,ç­‰ä»·äºŽæˆ‘ä»¬æŠŠä¸€ä¸ªä½ç½®åˆ åŽ»,ç„¶åŽå†åœ¨è¿™ä¸ªåŒºé—´ä¸­æ’å…¥æˆ‘ä»¬è¦ä¿®æ”¹çš„æ•°å€¼,è¿™ä¸ªè¿‡ç¨‹ä¸­è¦è¿›è¡Œä¸¤æ¬¡åŒºé—´$sum$. æ‰€ä»¥ç”¨æƒå€¼çº¿æ®µæ ‘æˆ–è€…å¹³è¡¡æ ‘ç­‰æ•°æ®ç»“æž„ç»´æŠ¤å³å¯. ä¸‰åƒç±³è¿™é“é¢˜æ˜¯ä¸å¯èƒ½è¡¥çš„,è¿™è¾ˆå­éƒ½ä¸å¯èƒ½è¡¥çš„ æ€»ç»“:éš¾åº¦å·®ä¸å¤š$noip$çš„$d1$éš¾åº¦å§(ç”šè‡³è¿˜è¦ä½Ž)â€¦.ä½†æ˜¯æˆ‘è¿™ä¸ªå¾—åˆ†å°±â€¦.ç®—äº†æˆ‘å¤ªèœäº†/kk å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å›½åº†ä¸ƒå¤©ä¹D1]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%90D1%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€w å¹¸ç¦é¢˜ç›®ä¸­è¦æˆ‘ä»¬åŽ»æ±‚$\sum_{i=0}^n F_i$æˆ‘ä»¬å‘çŽ°ç›´æŽ¥åŽ»ç”±$f$æ•°ç»„åŽ»é€’æŽ¨$F$æ•°ç»„çš„è¯æ—¶é—´å¤æ‚åº¦æ˜¯$O(n^2)$çš„,æ˜¾ç„¶è¿‡ä¸äº†,æ‰€ä»¥æˆ‘ä»¬è¦æŽ¨ä¸€æ³¢å¼å­.ç”±é¢˜æ„å¯çŸ¥ F_i=\sum_{i=0}^n f_i\times f_{n-i}æˆ‘ä»¬å‘çŽ°$f_i=f_{i-1}+f_{i-2}$,é‚£ä¹ˆæˆ‘ä»¬æŠŠ$f_0$å’Œ$f_1$å•ç‹¬æ‹¿å‡ºæ¥ä¹‹åŽ,ä¸Šè¾¹çš„å¼å­å°±å¯ä»¥æ‹†æˆ F_i=\sum_{i=2}^n [(f_{i-1}+f_{i-2}) \times f_{n-i}]+f_0 \times f_n + f_1 \times f_{n-1}å†æ ¹æ®ä¸‡èƒ½çš„åŠ æ³•ç»“åˆå¾‹,æˆ‘ä»¬æŠŠä¸Šå¼ä¸­çš„å‡ ä¸ª$\sum$æ‹†åˆ†é­”æ”¹ä¹‹åŽå¾—åˆ° F_i=\sum_{i=0}^{n-1} f_i \times f_{n-i-1} + \sum_{i=0}^{n-2} f_i \times f_{n-i-2} + f_0 \times f_n - f_1 \times f_n + f_0 \times f_nç„¶åŽå‘çŽ°å‰è¾¹é‚£ä¸¤ä¸ª$\sum$çš„å¼å­åˆ†åˆ«æ˜¯$F_{i-1}å’ŒF_{i-2}$,åˆå› ä¸º$f_0=f_1=1$,å¸¦å…¥è¿™ä¸ªå¼å­ä¹‹åŽæˆ‘ä»¬å¯ä»¥å¾—åˆ°: F_i=F_{i-1}+F_{i-2}+f_iç„¶åŽå°±å¯ä»¥æ„‰å¿«çš„çŸ©ä¹˜æ±‚å‡ºæ¥äº†.ä½†æ˜¯å› ä¸ºæˆ‘æ¯”è¾ƒèœ,åªä¼šç”¨çŸ©é˜µå¿«é€Ÿå¹‚æ±‚ç¬¬$i$é¡¹,ä½†æ˜¯é¢˜ç›®ä¸­è¦æ±‚ä½ æ±‚$\sum_{i=0}^nF_i$,æˆ‘ä»¬æ€Žä¹ˆåŠžå‘¢?ç„¶åŽæˆ‘ä»¬æ¥è€ƒè™‘ä¸€ä¸‹æ€Žä¹ˆç”¨çŸ©é˜µå¿«é€Ÿå¹‚çš„è¿‡ç¨‹ä¸­ç›´æŽ¥æ±‚å‡ºå‰ç¼€å’Œ. æˆ‘ä»¬æƒ³ä¸€ä¸‹çŸ©é˜µä¹˜æ³•çš„è¿‡ç¨‹,å› ä¸ºæˆ‘ä»¬çš„ç›®æ ‡çŸ©é˜µæ˜¯ç”±åŽŸæ¥çš„çŸ©é˜µå’Œæˆ‘ä»¬æž„é€ çš„çŸ©é˜µç›¸ä¹˜å¾—åˆ°çš„,å¦‚æžœæˆ‘ä»¬ä¸­é—´æž„é€ ä¸€ä¸ª$01$çŸ©é˜µçš„è¯,çŸ©é˜µä¹˜æ³•å°±å¯ä»¥çœ‹æˆæ˜¯çŸ©é˜µä¸­çš„å…ƒç´ ä¸æ–­çš„ç›¸åŠ ,æ‰€ä»¥åŽŸç†ä¸Šåœ¨çŸ©é˜µå¿«é€Ÿå¹‚çš„è¿‡ç¨‹ä¸­æ˜¯å¯ä»¥ç›´æŽ¥æ±‚å‡ºæˆ‘ä»¬è¦æ±‚çš„æ•°åˆ—çš„å‰ç¼€å’Œçš„.æˆ‘ä»¬ä»¥æ±‚æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å‰ç¼€å’Œä¸ºä¾‹å­,å› ä¸ºæˆ‘ä»¬çŸ¥é“,ä¸€ä¸ª$n \times m$çš„çŸ©é˜µä¸Žä¸€ä¸ª$m \times k$çš„çŸ©é˜µç›¸ä¹˜ä¹‹åŽ,æˆ‘ä»¬å¾—åˆ°çš„çŸ©é˜µæ˜¯ä¸€ä¸ª$n \times k$çš„çŸ©é˜µ.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘åœ¨æˆ‘ä»¬åŽŸæ¥æž„é€ çš„çŸ©é˜µä¸­åŠ ä¸Šä¸€ä½,è¿™æ ·çš„è¯çŸ©é˜µå°±å˜æˆäº†{$f_i,f_{i+1},\sum_{j=1}^{i+1}f_j$}.ç›¸åº”çš„,åœ¨æˆ‘ä»¬æž„é€ çš„çŸ©é˜µä¸­,æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿$f_iä¸Žf_{i+1}$éƒ½è¢«åŠ å…¥æˆ‘ä»¬æ–°åŠ çš„ä¸€ç»´æ¥è¾¾åˆ°æ›´æ–°å‰ç¼€å’Œçš„ç›®çš„.ç»¼ä¸Š,æˆ‘ä»¬å¯ä»¥åœ¨æ±‚$F_i$çš„çŸ©é˜µä¸­åŠ ä¸€ç»´è¡¨ç¤ºå‰ç¼€å’Œ,ç„¶åŽç›´æŽ¥çŸ©é˜µå¿«é€Ÿå¹‚å³å¯.æ—¶é—´å¤æ‚åº¦ä¸º$O(logn)$,å¯ä»¥é€šè¿‡æœ¬é¢˜ æ ‘é“¾å‰–åˆ†å…ˆè€ƒè™‘æš´åŠ›æ€Žä¹ˆå†™.æˆ‘ä»¬å‘çŽ°å¦‚æžœæ ¹èŠ‚ç‚¹è¢«ç¡®å®šäº†çš„è¯,æˆ‘ä»¬æå‰ç”¨æ ‘ä¸Šå·®åˆ†ç»Ÿè®¡å‡ºæ¯ä¸ªç‚¹è¢«ç»è¿‡äº†å¤šå°‘æ¬¡ä¹‹åŽ,å¯ä»¥ç›´æŽ¥è´ªå¿ƒçš„åŽ»æ‰¾ç­”æ¡ˆ.æ‰€ä»¥è¿™æ ·çš„è¯æˆ‘ä»¬å¿…é¡»è¦æžšä¸¾æ ¹èŠ‚ç‚¹.è¿™æ ·çš„è¯å¤æ‚åº¦ä¹Ÿæ˜¯æ˜¾ç„¶è¿‡ä¸äº†.æˆ‘ä»¬å…ˆé’¦å®šä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹,ç„¶åŽæˆ‘ä»¬è€ƒè™‘æ¯ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹çš„æƒ…å†µ.æ˜¾ç„¶å‘çŽ°æŸä¸ªç‚¹çš„åœ¨åŽŸæ ‘ä¸Šçš„å„¿å­èŠ‚ç‚¹æ˜¯ä¸å—å½±å“çš„,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é¢„å…ˆè¿›è¡Œä¸€æ¬¡$dfs$æ¥ç¡®å®šæˆ‘ä»¬å‘çŽ°,å¦‚æžœæŸä¸ªèŠ‚ç‚¹$i$ä¸Žæˆ‘ä»¬å½“å‰çš„è¿™ä¸ªå³å°†è¦æˆä¸ºæ ¹çš„èŠ‚ç‚¹ä¸ç›¸é‚»çš„è¯,é‚£ä¹ˆè¿™ä¸ªç‚¹$i$æ˜¯å¾ˆæ˜¾ç„¶ä¸ä¼šå—åˆ°å½±å“çš„(è¯¥æ€Žä¹ˆèµ°è¿˜å¾—æ€Žä¹ˆèµ°)æˆ‘ä»¬è€ƒè™‘ä»Žä¸Šå¾€ä¸‹çš„é¡ºåºè¿›è¡Œ$DFS$ï¼Œç„¶åŽæ¯æ¬¡æ±‚å‡ºå½“å‰èŠ‚ç‚¹ä½œä¸ºæ ¹æ—¶çš„æœ€å°ä»£ä»·ã€‚æ˜¾ç„¶ï¼Œä¸Žå½“å‰èŠ‚ç‚¹ä¸ç›¸é‚»çš„è¾¹ä¸å—è¿™ä¸ªèŠ‚ç‚¹çš„å½±å“ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æŽ¥æ±‚å‡º.åˆå› ä¸ºå­©å­æ–¹å‘çš„åœ¨ç¬¬ä¸€æ¬¡$DFS$ä¸­é¢„å¤„ç†äº†ï¼Œè€Œçˆ¶äº²æ–¹å‘çš„åœ¨åˆšåˆš$DFS$çš„è¿‡ç¨‹ä¸­æ±‚å‡ºã€‚ç„¶åŽæ±‚å‡ºä¸Žå½“å‰èŠ‚ç‚¹ç›¸é‚»çš„è¾¹ä¸­ï¼Œæœ€å¤§çš„ä»¥åŠæ¬¡å¤§çš„ï¼Œæ ¹æ®$DFS$çš„å­©å­é€‰æ‹©æ˜¯åŽ»æŽ‰æœ€å¤§çš„è¿˜æ˜¯æ¬¡å¤§çš„å³å¯ã€‚ å°Eå’Œå°F strikes againè¿™é“é¢˜æ˜¯ä¸å¯èƒ½è¡¥çš„,è¿™è¾ˆå­éƒ½ä¸å¯èƒ½è¡¥çš„ å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #588 (Div. 2)é¢˜è§£]]></title>
    <url>%2F2019%2F09%2F27%2FCF588%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[lytæˆ‘å¯¹ä¸èµ·ä½ å•Š/ll Dawid and Bags of Candieså…¶å®žæˆ‘ä»¬æŒ‰ç…§å¤§å°æŽ’åºäº†ä¹‹åŽ,æˆ‘ä»¬å‘çŽ°å¯èƒ½çš„ç­”æ¡ˆåªæœ‰ç¬¬$1,4$ç»„æˆæˆ–è€…ç¬¬$4$ä¸ªå•ç‹¬ç»„æˆ,åˆ¤æ–­ä¸€ä¸‹å³å¯.æ³¨æ„ç²¾åº¦,ä¸ç„¶ç›´æŽ¥é™¤$2$çš„æ—¶å€™å¯èƒ½ä¼šè¢«å¡. Ania and Minimizingå‘çŽ°å¦‚æžœæŠŠé«˜ä½å˜å°äº†ä¹‹åŽ,é‚£ä¹ˆç­”æ¡ˆä¸€å®šä¼šå˜å¾—æ›´ä¼˜.æ‰€ä»¥æˆ‘ä»¬ç›´æŽ¥ä»Žé«˜ä½å‘ä½Žä½è´ªå¿ƒå³å¯.æ³¨æ„åˆ¤æ–­$k$ä¸º$0$çš„æƒ…å†µ. Anadi and Domino$emmmmmâ€¦.$çœ‹é¢˜é¢å°±éžå¸¸é«˜å¤§ä¸Šç„¶åŽæˆ‘ä»¬è®¤çœŸè¯»äº†è¯»é¢˜å‘çŽ°çœŸçš„å¾ˆé«˜å¤§ä¸Š.çœ‹ä¸€çœ¼æ•°æ®èŒƒå›´,$n&lt;=7$,æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹æžšä¸¾ä¸Žæ¯ä¸ªç‚¹ç›¸è¿žçš„è¾¹çš„é¢œè‰².ç„¶åŽæˆ‘ä»¬ç›´æŽ¥æš´åŠ›$check$å³å¯.å¯¹ä¸èµ·æ•°æ®èŒƒå›´å°çœŸçš„å¯ä»¥ä¸ºæ‰€æ¬²ä¸º1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;int G[10][10];int col[8],ans;bool used[7],uc[7][7];void Prep()&#123; memset(uc,false,sizeof(uc)); return;&#125;inline void check()&#123; Prep(); int tmp=0; for(int i=1;i&lt;=n;i++)&#123; if(col[i]==0) continue; for(int j=i+1;j&lt;=n;j++)&#123; if(!G[i][j]||!col[j]) continue; if(!uc[col[i]][col[j]])&#123; uc[col[i]][col[j]]=1; uc[col[j]][col[i]]=1; tmp++; &#125; &#125; &#125; ans=max(ans,tmp);// if(tmp==21)&#123;// for(int i=1;i&lt;=n;i++)// cout&lt;&lt;col[i]&lt;&lt;" ";// exit(0); // &#125; return;&#125;void dfs(int x)&#123; if(x==n+1)&#123; check(); return; &#125; for(int i=0;i&lt;=6;i++)&#123; col[x]=i; dfs(x+1); &#125; return;&#125;int main ( void ) &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; G[x][y]=1; G[y][x]=1; &#125; memset(col,-1,sizeof(col)); dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;// Main Code Marcin and Training Campæˆ‘ä»¬è€ƒè™‘åˆ°,å¦‚æžœä¸€ä¸ªäºº$i$å’Œå¦ä¸€ä¸ªäºº$j$èƒ½çœ‹é¡ºçœ¼çš„è¯,åªæœ‰$j$æ˜¯$i$çš„å­é›†æ‰å¯ä»¥.ç„¶åŽå¦‚æžœåœ¨æŸä¸ªåˆ†ç»„é‡Œ,$j$å·²ç»æ˜¯æŸä¸ª$i$äººçš„å­é›†äº†,é‚£ä¹ˆ$j$ä¸€å®šæ˜¯å¯ä»¥è¢«é€‰å‡ºçš„.æ‰€ä»¥æˆ‘ä»¬çš„ä»»åŠ¡å°±å˜æˆäº†æ‰¾åˆ°æ‰€æœ‰çš„$a_k$åªå‡ºçŽ°è¿‡ä¸€æ¬¡æˆ–è€…ä¸æ˜¯å…¶ä»–å‡ºçŽ°è¿‡ä¸¤æ¬¡æˆ–å¤šæ¬¡çš„$a_i$çš„å­é›†åˆçš„$k$.ç„¶åŽä»Ž$sum$ä¸­å°†è¿™äº›ä¸åˆæ³•çš„çŠ¶æ€åˆ åŽ»å³å¯. å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ•°è®ºå­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[æ•°è®ºæžœç„¶åšå¤§ç²¾æ·±,ä½†æ˜¯æˆ‘å•¥éƒ½æ²¡å¬æ‡‚ å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å­¦ä¹ ç¬”è®°</tag>
        <tag>æ•°è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCP-114514]]></title>
    <url>%2F2019%2F09%2F23%2FSCP1%2F</url>
    <content type="text"><![CDATA[qwq SCP-114514 ç ”ç©¶ç¤¾ ç­‰çº§: Keter ç‰¹æ®Šæ”¶å®¹æŽªæ–½: ç›®å‰SCP-114514æ— æ³•è¢«æ”¶å®¹,ç›®å‰åŸºé‡‘ä¼šçš„ç›®çš„æ˜¯ä½¿SCP-114514ä¿æŒä¸å†å‘ç”Ÿå˜åŒ–. é¡¹ç›®æè¿°: å·²çŸ¥SCP-114514æ›¾ç»çš„åç§°æœ‰ä¿¡æ¯å­¦,OI,å›½é™…è±¡æ£‹,å›´æ£‹,äº”å­æ£‹,ç¾½æ¯›çƒ,ç¯®çƒ,OSU,æ¤ç‰©å¤§æˆ˜åƒµå°¸,å¤–å–Kæ­Œç ”ç©¶ç¤¾.å·²çŸ¥é¡¹ç›®ä¼šåœ¨éšæœºçš„æ—¶é—´è¿›è¡Œåç§°ä¸Šçš„å˜åŒ–.ç›®å‰å·²ç»è¯å®ž,åœ¨æ¯æ¬¡é¡¹ç›®çš„åç§°å‘ç”Ÿæ”¹å˜æ—¶,é¡¹ç›®å†…çš„äººå‘˜(ç§°ä¹‹ä¸º$SCP-114514-1919810$)çš„å…´è¶£çˆ±å¥½ä¼šéšç€ç ”ç©¶ç¤¾çš„åç§°å‘ç”Ÿå˜åŒ–. ç»è¿‡ç ”ç©¶å‘çŽ°,SCP-114514å†…çš„äººå‘˜çˆ±å¥½éœ€è¦çš„ç‰©ä»¶ä¼¼ä¹Žå¹¶ä¸éœ€è¦ä»Žå¤–ç•ŒèŽ·å–,ä¼šæœ‰ä¸€ä¸ªè¢«ç§°ä¸º$SCP-114514-1$çš„è¢«ç§°ä¸º$Z$ä¸»ä»»çš„äººå½¢å®žä½“ä¾›ç»™,è€Œä¾›ç»™çš„ç‰©å“ä¼¼ä¹Žæ˜¯ä»Žå†…éƒ¨è‡ªç„¶äº§ç”Ÿçš„. åœ¨æ¯æ¬¡é¡¹ç›®çš„åç§°å‘ç”Ÿæ”¹å˜æ—¶,ä¼šå¼ºåˆ¶å°†é¡¹ç›®å‘¨è¾¹è·ç¦»ä¸è¶…è¿‡$10m$çš„äººå‘˜å¼ºåˆ¶è½¬åŒ–ä¸º$SCP-114514-1919810$,å·²çŸ¥è¿™ä¸€å½±å“ä¸å¯é€†.è€Œä¸”åœ¨æ™®é€šäººå‘˜è¢«å¼ºåˆ¶è½¬åŒ–åŽ,ä¼šåœ¨[æ•°æ®åˆ é™¤]çš„æ—¶é—´ä¹‹å†…ä¸§å¤±å¯¹æ–‡åŒ–è¯¾å­¦ä¹ çš„å…´è¶£. å¸¸äººæš´éœ²åœ¨SCP-114514é¢å‰æ˜¯è‡´å‘½çš„,æ‰€ä»¥å¯¹äºŽSCP-114514çš„ä»»ä½•æŽ¥è§¦éœ€è¦3ååŠä»¥ä¸Šå››çº§æƒé™è€…çš„å…è®¸,ä¸”å®žéªŒè€…åœ¨å®žéªŒåŽå°†è¢«å¼ºåˆ¶éš”ç¦»$3$å¤©,å¦‚æžœåœ¨éš”ç¦»æ—¶é—´ä¹‹å†…å®žéªŒè€…è¡¨çŽ°äº†æ˜Žæ˜¾çš„å…´è¶£çˆ±å¥½å˜åŒ–,é‚£ä¹ˆå®žéªŒè€…å°†ä¼šè¢«å¤„å†³. å¯¹äºŽSCP-114514çš„è¿›ä¸€æ­¥ç ”ç©¶æŠ¥å‘Šä¸ºè‡´å‘½åª’ä»‹æ¨¡å› ,éœ€è¦å¾—åˆ°O5è®®ä¼šçš„æ‰¹å‡†ä¹‹åŽè®¿é—®. æ‚¨å¥½,ç›‘ç£è€…,å·²å–æ¶ˆå¯¹æœºåŠ¨ç‰¹é£é˜Ÿçš„æ´¾é£æŒ‡ä»¤.]]></content>
      <categories>
        <category>å¹æ°´</category>
      </categories>
      <tags>
        <tag>SCPä¹±æž</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #587é¢˜è§£]]></title>
    <url>%2F2019%2F09%2F22%2FCodeforcesRound-587%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[LYTæˆ‘å¯¹ä¸èµ·ä½ å•Š/ll Prefixesç»è¿‡è§‚å¯Ÿç§ä¿¡æ‰¾è§„å¾‹ä¹‹åŽå‘çŽ°,å¯¹äºŽæ¯ä¸ªå¶æ•°çš„å‰ç¼€$i$,å¦‚æžœ$i&gt;2$ä¸”$i$è¿™ä¸ªå‰ç¼€æ»¡è¶³æ¡ä»¶,é‚£ä¹ˆ$i/2$ä¹Ÿä¸€å®šä¼šæ»¡è¶³æ¡ä»¶.æ‰€ä»¥æˆ‘ä»¬è¦æ»¡è¶³çš„å°±æ˜¯å¯¹äºŽæ¯ä¸ªæœ€å°çš„é—´éš”ä¸º$2$çš„åŒºé—´,ä½¿ä»–ä»¬å½“ä¸­æœ‰ä¸€ä¸ª$a$å’Œä¸€ä¸ª$b$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 2e5 + 10; int n , ans;char ss[N]; int main() &#123; read ( n ); scanf ( "%s" , ss + 1 ); int s1 = 0 , s2 = 0; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( ss[i] == 'a' ) s1++; else s2++; if ( i % 2 == 0 ) &#123; if ( s1 == s2 ) continue; ans++; if ( s1 &gt; s2 ) ss[i] = 'b'; else ss[i] = 'a'; s1 = 0; s2 = 0; &#125; &#125; writeln ( ans ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%c" , ss[i] ); return 0; &#125; Shootingé€šè¿‡è§‚å¯Ÿæ ·ä¾‹å¯çŸ¥,ä»Žå¤§åˆ°å°æŽ’åºå³å¯qwqâ€¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 1005; int n;struct Node &#123; int val; int pos;&#125;ls[N]; ll ans; inline bool cmp ( Node x , Node y ) &#123; return x.val &gt; y.val;&#125; int main() &#123; read ( n ); F ( i , 1 , n ) &#123; ls[i].val = _read (); ls[i].pos = i; &#125; std :: sort ( ls + 1 , ls + 1 + n , cmp ); F ( i , 1 , n ) ans += ls[i].val * ( i - 1 ) + 1; writeln ( ans ); F ( i , 1 , n ) printf ( "%d " , ls[i].pos ); return 0; &#125; White Sheetå‘çŽ°å¦‚æžœè¿™ä¸ªç™½è‰²çŸ©å½¢çš„å››æ¡è¾¹éƒ½è¢«è¦†ç›–äº†çš„è¯,é‚£ä¹ˆä¸­é—´ä¸€å®šä¹Ÿè¢«è¦†ç›–äº†.ç„¶åŽæš´åŠ›æžšä¸¾åˆ¤æ–­å³å¯. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ struct Point&#123; int x; int y;&#125;p[7];int main ( void )&#123; for(int i=1;i&lt;=6;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); if(p[3].x&lt;=p[1].x&amp;&amp;p[3].y&lt;=p[1].y&amp;&amp;p[4].x&gt;=p[2].x&amp;&amp;p[4].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[5].x&lt;=p[1].x&amp;&amp;p[5].y&lt;=p[1].y&amp;&amp;p[6].x&gt;=p[2].x&amp;&amp;p[6].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[3].x&lt;=p[1].x&amp;&amp;p[4].x&gt;=p[2].x&amp;&amp;p[5].x&lt;=p[1].x&amp;&amp;p[6].x&gt;=p[2].x)&#123; if(p[3].y&lt;=p[1].y&amp;&amp;p[4].y&gt;=p[5].y&amp;&amp;p[6].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[5].y&lt;=p[1].y&amp;&amp;p[6].y&gt;=p[3].y&amp;&amp;p[4].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; &#125; if(p[3].y&lt;=p[1].y&amp;&amp;p[4].y&gt;=p[2].y&amp;&amp;p[5].y&lt;=p[1].y&amp;&amp;p[6].y&gt;=p[2].y)&#123; if(p[3].x&lt;=p[1].x&amp;&amp;p[4].x&gt;=p[5].x&amp;&amp;p[6].x&gt;=p[2].x)&#123; printf("NO\n"); return 0; &#125; if(p[5].x&lt;=p[1].x&amp;&amp;p[6].x&gt;=p[3].x&amp;&amp;p[4].x&gt;=p[2].x)&#123; printf("NO\n"); return 0; &#125; &#125; printf("YES\n"); return 0;&#125; Swordså‘çŽ°æ±‚ä¸ª$gcd$å°±å¥½äº† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 2e5 + 10; int n , maxs;int num[N];ll ans , sum; int main() &#123; read ( n ); F ( i , 1 , n ) &#123; num[i] = _read (); maxs = max ( maxs , num[i] ); &#125; F ( i , 1 , n ) &#123; int res = ( maxs - num[i] ); ans = std :: __gcd ( ans , res * 1ll ); &#125; if ( ans == 0 ) &#123; puts ( "0 0" ); return 0; &#125; else &#123; F ( i , 1 , n ) sum += ( maxs - num[i] ) / ans; printf ( "%I64d %I64d\n" , sum , ans ); &#125; return 0; &#125; Numerical Sequence (easy version)å‘çŽ°$k$åªæœ‰$10^9$çš„èŒƒå›´,æ‰€ä»¥å°±æš´åŠ›è·³å°±å¯ä»¥äº†. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std; #define LL long long#define N 40010 LL sum[N],T; int judge(int x) &#123; int count = (int)log10((double)x) + 1; return count;&#125;int fun(int x) &#123; int sum = pow(10,x); return sum;&#125;void solve() &#123; int sumn = 0; memset(sum, 0,sizeof(sum)); for(int i = 1 ; i &lt; 40005 ; ++i) &#123; sumn += judge(i); sum[i] = sum[i - 1] +sumn; &#125;&#125;void answer(int x) &#123; int j,ans,summ,i = 1; while(sum[i] &lt; x) i++; ans = x - sum[i -1]; summ = 0; for(j = 1 ; j &lt;= i ; ++j) &#123; summ += judge(j); if(summ &gt;= ans) break; &#125; if(summ == ans) printf("%d\n", j %10); if(summ &gt; ans) printf("%d\n", (j / fun(summ -ans)) % 10);&#125; int main() &#123; scanf("%lld",&amp;T); solve(); while(T--) &#123; int pos; scanf("%d",&amp;pos); answer(pos); &#125; //system("pause"); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®è½¬æä¸ƒè¿žæµ‹D3]]></title>
    <url>%2F2019%2F09%2F22%2FP%E8%BD%ACTD3%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€ åºåˆ—æˆ‘ä»¬è€ƒè™‘åŒ–ç®€å¼å­: (x^2+y)^2\equiv(x^2-y)^2+1\pmod{p}ä¸¤è¾¹çš„å¹³æ–¹å¼å±•å¼€ä¹‹åŽå†åˆå¹¶åŒç±»é¡¹ä¹‹åŽå¯æœ‰ 4x^2y\equiv1\pmod{p}æˆ‘ä»¬å‘çŽ°,å¦‚æžœæˆ‘ä»¬æŠŠ$4x^2$çœ‹ä½œä¸€ä¸ªæ•´ä½“,é‚£ä¹ˆ$y$å°±æ˜¯$4x^2$åœ¨è†œ$p$æ„ä¹‰ä¸‹çš„é€†å…ƒ.æ‰€ä»¥æˆ‘ä»¬çŽ°åœ¨çš„ä»»åŠ¡å˜æˆäº†æ‰¾å¯¹äºŽæ¯ä¸ª$num_i$,$4num_i$çš„é€†å…ƒæœ‰å¤šå°‘ä¸ªåˆå› ä¸ºé¢˜é¢ä¸­è¯´äº†æ•°å­—äº’ä¸ç›¸ç­‰,æ‰€ä»¥æˆ‘ä»¬å®Œå…¨å¯ä»¥ä½¿ç”¨$unordered$_$map$ç»Ÿè®¡.æ³¨æ„åŽ»é‡å³å¯,æ—¶é—´å¤æ‚åº¦$O(nlogINTMAX)$ æ±½æ°´ä¹ä¸€çœ‹å¹¶èŽ«å¾—å•¥æ€è·¯.ç„¶åŽæˆ‘ä»¬æƒ³ä¸€ä¸‹,å¦‚æžœæˆ‘ä»¬æŠŠæ¯ä¸ªç³–æµ†çš„æµ“åº¦éƒ½å‡å°‘$n$çš„è¯,é‚£ä¹ˆæˆ‘ä»¬çš„ä»»åŠ¡å°±å˜æˆäº†æ€Žä¹ˆå‡‘å‡º$0$æµ“åº¦çš„ä»»åŠ¡.ç„¶åŽæˆ‘ä»¬å»ºç«‹ä¸€ä¸ªå›¾è®ºæ¨¡åž‹:æˆ‘ä»¬è®¾$dis_i$è¡¨ç¤ºå‡‘åˆ°$i+n$è¿™ä¸ªæµ“åº¦æ—¶æœ€å°‘ç”¨çš„ç³–æµ†æ˜¯å¤šå°‘,æ˜¾ç„¶å¯ä»¥ä½¿ç”¨$bfs$æ±‚æœ€çŸ­è·¯. æ ‘æˆ‘ä»¬å‘çŽ°,æœ€ä¼˜è§£ä¸€å®šæ˜¯åŽŸæ¥çš„æŸäº›è¿žé€šå—ç›¸äº’è¿žæŽ¥å½¢æˆçš„,ç„¶åŽå°±æ²¡äº†qwq DAGé¦–å…ˆæŽ¨å¹¿ä¸€ä¸ªç»“è®º:å¦‚æžœæœ€é•¿è·¯æ˜¯$x$,é‚£ä¹ˆä¸€å®šå­˜åœ¨ä¸€ä¸ª$x+1$çš„æŸ“è‰²æ–¹æ¡ˆ.æˆ‘ä»¬å¯¹äºŽæ¯ä¸€æ¡è¾¹$(i-&gt;j)$,æˆ‘ä»¬è§„å®šåªèƒ½ä»Žé¢œè‰²å°çš„ç‚¹èµ°å‘é¢œè‰²å¤§çš„ç‚¹.ç„¶åŽè€ƒè™‘è¿™æ ·çš„è¯æˆ‘ä»¬å°±åˆ’åˆ†æˆäº†ä¸€ä¸ªåˆ†å±‚å›¾.ç„¶åŽåˆå› ä¸ºæˆ‘ä»¬è¦è®©æœ€çŸ­è·¯æœ€é•¿,è¯´ç™½äº†å°±æ˜¯è¦è®©å±‚æ•°æœ€å°‘.è€Œæˆ‘ä»¬åˆå‘çŽ°åŒå±‚çš„ç‚¹ä¹‹é—´æ²¡æœ‰è¾¹,ç­‰ä»·äºŽä¸€ä¸ªç‹¬ç«‹é›†.æ‰€ä»¥æˆ‘ä»¬çš„ä»»åŠ¡å°±è½¬åŒ–æˆäº†æŠŠè¿™å¼ å›¾åˆ’åˆ†æˆæœ€å°‘çš„ç‹¬ç«‹é›†ä¸ªæ•°,ä½¿å¾—ä»–ä»¬çš„å¹¶é›†ä¸ºè¿™ä¸€å¼ å›¾.åˆå› ä¸ºæˆ‘ä»¬å‘çŽ°æ•°æ®èŒƒå›´å¾ˆå°,åªæœ‰$17$,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è€ƒè™‘çŠ¶åŽ‹$DP$æ¥è§£å†³è¿™ä¸ªé—®é¢˜.æˆ‘ä»¬è®¾$f_i$è¡¨ç¤ºæˆ‘ä»¬ç›®å‰é€‰æ‹©çš„ç‚¹çš„æ€»é›†ä¸º$i$çš„æ—¶å€™çš„æœ€å°çš„ç‹¬ç«‹é›†ä¸ªæ•°.æˆ‘ä»¬é¢„å¤„ç†å‡ºä»Ž$0$åˆ°$(1&lt;&lt;n)-1$ä¸­çš„æ¯ä¸ªçŠ¶æ€æ˜¯å¦ä¸ºç‹¬ç«‹é›†,ç„¶åŽæˆ‘ä»¬åœ¨æ¯æ¬¡æžšä¸¾çŠ¶æ€$i$çš„æ—¶å€™,æ˜¾ç„¶$i$è¿™ä¸ªçŠ¶æ€åªèƒ½ä»Žå®ƒçš„æŸä¸ªä¸ºç‹¬ç«‹é›†çš„å­é›†è½¬ç§»è¿‡æ¥.è½¬ç§»å¾ˆæ˜¾ç„¶,$f_i=min(f_j+1)$$(j$ä¸º$i$çš„å­é›†ä¸”$j$è¿™ä¸ªé›†åˆä¸ºç‹¬ç«‹é›†). å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æé«˜å¤±è”æµ‹D4]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E8%81%94%E6%B5%8BD4%2F</url>
    <content type="text"><![CDATA[ç½—å°é»‘çœŸå°¼çŽ›å¥½çœ‹ ç½—å…¶å®žæš´åŠ›æœ‰$60$åˆ†,åªéœ€è¦åˆ¤æ–­ä¸€ä¸‹ä¸Šä¸‹æ˜¯å¦ç›¸ç­‰å³å¯.å¯¹äºŽå…¶ä»–çš„æƒ…å†µ,æˆ‘ä»¬å‘çŽ°å¦‚æžœæˆ‘ä»¬åªæœ‰ä¸€ä¸ª*çš„è¯,å°±å¯ä»¥åŒ¹é…æ‰€æœ‰çš„å­—ç¬¦ä¸²,æ‰€ä»¥*çš„ä¸ªæ•°æœ€å¤šåªæœ‰ä¸€ä¸ª.ç„¶åŽæˆ‘ä»¬å†è€ƒè™‘ä¸€ä¸‹ä¸‡èƒ½å­—ç¬¦ä¸²(èƒ½åŒ¹é…æ‰€æœ‰é•¿åº¦æœ‰ä¸‹ç•Œçš„å­—ç¬¦ä¸²çš„å­—ç¬¦ä¸²)é•¿ä»€ä¹ˆæ ·å­.æ˜¾ç„¶æ˜¯*???????????????ç„¶åŽæˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹,æˆ‘ä»¬å¯¹äºŽæŸä¸¤ä¸ªå­—ç¬¦ä¸²xxxx*xxxxx*xxxå’Œxxxx*xxxxxx.æˆ‘ä»¬å‘çŽ°ç­”æ¡ˆä¸­çš„é‚£ä¸ª*ä¸€å®šä¼šåŒ¹é…åŽŸæ¥ä¸¤ä¸ªä¸²ä¸­æ‰€æœ‰çš„*.é‚£ä¹ˆæˆ‘ä»¬æœ€ç»ˆæž„é€ å‡ºæ¥çš„é‚£ä¸ªä¸²çš„é•¿åº¦ä¸€å®šå°±æ˜¯åŽŸæ¥ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­æ‰€æœ‰éž*çš„æœ€å°å€¼åŠ ä¸€. ç„¶åŽæˆ‘ä»¬è€ƒè™‘äº†ä¹‹å‰çš„æ¡ä»¶ä¹‹åŽ,å‘çŽ°æˆ‘ä»¬å¯ä»¥æžšä¸¾æˆ‘ä»¬çš„è¿™ä¸ª*ä¹‹å‰çš„é•¿åº¦$L_1$.å¯¹äºŽ*ä¹‹åŽçš„é•¿åº¦æˆ‘ä»¬å¯ä»¥ç®—å‡ºæ¥.ç„¶åŽå¯¹äºŽåŽŸæ¥çš„ä¸¤ä¸ªå­—ç¬¦ä¸²ä¹‹å‰çš„$L_1$ä½,æˆ‘ä»¬å¯ä»¥åƒç™½ç»™çš„$60$åˆ†é‚£æ ·åšåŒ¹é…æ¥è¿™æ ·çš„è¯æˆ‘ä»¬æœ€åŽæŠŠæ‰€æœ‰ç­”æ¡ˆæ‹¿å‡ºæ¥,æ¯”è¾ƒä¸€ä¸‹å­—å…¸åºå’Œ$?$çš„ä¸ªæ•°,å°±èƒ½åœ¨$O(n)$çš„å¤æ‚åº¦å†…è§£å†³è¿™é“é¢˜.ä½†æ˜¯è¿™æ ·çš„å¤æ‚åº¦å¯¹äºŽè¿™é“é¢˜æ¥è¯´æ˜¾ç„¶ä¸å¤Ÿä¼˜ç§€,æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘æ€Žä¹ˆä¼˜åŒ–è¿™ä¸ªç®—æ³•.æˆ‘ä»¬å‘çŽ°ä¸¤ä¸ªç­”æ¡ˆä¸ä¸€æ ·çš„åœ°æ–¹ä¸€å®šæ˜¯*,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ†åˆ«ä»Žå·¦å‘å³å’Œä»Žå³å‘å·¦é€’æŽ¨å‡ºä»¥$i$ä¸º*çš„ä½ç½®æ—¶,å·¦è¾¹$?$çš„ä¸ªæ•°å’Œå³è¾¹$?$çš„ä¸ªæ•°.è¿™æ ·çš„è¯æˆ‘ä»¬å°±å¯ä»¥ç”¨$O(n)$çš„æ—¶é—´å¤æ‚åº¦æž„é€ å‡ºæ‰€æœ‰æ–­ç‚¹$i$çš„å·¦è¾¹å’Œå³è¾¹çš„ç¬¦å·æ˜¯ä¸æ˜¯é—®å·ä»¥åŠé—®å·çš„ä¸ªæ•°,è€Œé€šè¿‡è¿™äº›ä¸œè¥¿å°±å¯ä»¥æž„é€ å‡ºç­”æ¡ˆ.ç„¶åŽæˆ‘ä»¬åœ¨æ‰€æœ‰çš„ç­”æ¡ˆä¸­,è´ªå¿ƒçš„å…ˆæ‰¾å‡ºä¸€ä¸ª$?$çš„ä¸ªæ•°æœ€å°çš„ä¸²,ç„¶åŽå†åœ¨è¿™äº›ä¸²é‡Œæ‰¾å‡º$L_1$æœ€å°çš„ä¸²(å› ä¸º$L_1$å°çš„è¯è¯´æ˜Žç¬¬ä¸€ä¸ªå‡ºçŽ°çš„*ä½ç½®é å‰,å­—å…¸åºå°).ç„¶åŽæ ¹æ®è¿™ä¸ªæž„é€ æœ€åŽçš„ä¸²å°±å¥½äº†. å°é¦–å…ˆæœ‰ä¸€ä¸ªç»“è®º:ä¸€ä¸ªä¸è¶…è¿‡$T$çš„æ•°æœ‰$loglogT$ä¸ªè´¨å› å­.è¿™æ ·çš„è¯,å¦‚æžœæˆ‘ä»¬æ¯æ¬¡æžšä¸¾åŒºé—´,ç„¶åŽ$check$ç­”æ¡ˆçš„è¯,å°±å¾—åˆ°äº†ä¸€ä¸ª$O(n^3loglogT)$çš„æ–¹æ³•.å‘çŽ°è¿™ä¸ªæ–¹æ³•è¿˜æ˜¯å¤ª$naive$,æˆ‘ä»¬æ¥å°è¯•ä¼˜åŒ–ä¸€ä¸‹,æˆ‘ä»¬å‘çŽ°,å¦‚æžœæˆ‘ä»¬æžšä¸¾åŒºé—´,ç„¶åŽåœ¨åŒºé—´å³ç§»çš„æ—¶å€™ç»´æŠ¤çŽ°åœ¨å‡º/è¿›åŒºé—´çš„å…ƒç´ çš„è¯,æˆ‘ä»¬å¯ä»¥æŠŠæžšä¸¾+$check$çš„å¤æ‚åº¦ä»Ž$O(n^2)$é™ä½Žåˆ°$O(n)$è¿™æ ·çš„è¯å°±æ˜¯$O(n^2loglogT)$äº†,å¯ä»¥é€šè¿‡$60$åˆ†. è€ƒè™‘æ¯ä¸ªè´¨å› å­åœ¨æ¯ä¸ªåŒºé—´ä¸­çš„è´¡çŒ®,å‡è®¾æˆ‘ä»¬çŽ°åœ¨æžšä¸¾çš„è´¨å› å­æ˜¯$p$,é‚£ä¹ˆå¯¹äºŽä½ç½®$i$ä¸Šçš„æ•°å­—$num_i$å¦‚æžœå­˜åœ¨è´¨å› å­$p$,é‚£ä¹ˆæˆ‘ä»¬è®°$pre_{i,p}=1$,å¦åˆ™çš„è¯è®°å½•$pre_{i,p}=-1$.è¿™æ ·æžšä¸¾åŒºé—´çš„æ—¶å€™,æˆ‘ä»¬å¯ä»¥ç›´æŽ¥ä»Žè¿™ä¸ªåŒºé—´çš„åŒºé—´å’Œæ˜¯å¦å¤§äºŽç­‰äºŽ$0$æ¥åˆ¤æ–­.è¿™æ ·ä¹‹åŽå¤æ‚åº¦è¿˜æ˜¯$O(n^2loglogT)$,è¿˜éœ€è¦è¿›ä¸€æ­¥ä¼˜åŒ–. æˆ‘ä»¬è¿˜æ˜¯å…ˆæžšä¸¾æ¯ä¸ªè´¨å› å­,ç„¶åŽæˆ‘ä»¬ä»¤$p_1,p_2,â€¦â€¦,p_k$ä¸ºè¿™ä¸ªè´¨å› å­ç¬¬$1,2,3â€¦.k$æ¬¡å‡ºçŽ°çš„ä½ç½®.åœ¨æˆ‘ä»¬æŠŠ$p$æ•°ç»„æŽ’åºä¹‹åŽ,æˆ‘ä»¬å‘çŽ°,å¦‚æžœæˆ‘ä»¬èƒ½æ‰¾åˆ°ä¸€ä¸ª$p_j-p_i+1&lt;=2\times(j-i+1){j&gt;i}$,é‚£ä¹ˆæˆ‘ä»¬å°±æ‰¾åˆ°äº†ä¸€ç»„$2\times(j-i+1)$çš„è§£.æˆ‘ä»¬æŠŠè¿™ä¸ªå¼å­ç§»é¡¹ä¹‹åŽæœ‰$p_j-2\times j&lt;=p_i-2\times i+1$.æ˜¾ç„¶,æˆ‘ä»¬å¯ä»¥æŒ‰ç…§$p_i-2\times i$æ¥æŽ’åº.æœ€åŽæˆ‘ä»¬æžšä¸¾$j$ä¹‹åŽ,ç”±äºŽæˆ‘ä»¬çš„æŽ’åºæ–¹å¼,æˆ‘ä»¬å¯ä»¥å‘çŽ°$p_j-2\times j&lt;=p_i-2\times i$ä¸€å®šæ˜¯ä¼šè¢«æ»¡è¶³çš„,æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦æ‰¾ä¸€ä¸ª$max(j-i+1)$å³å¯.ç„¶åŽæˆ‘ä»¬å‘çŽ°è¿™ä¸ªä¸œè¥¿æ˜¾ç„¶æ˜¯å¯ä»¥äºŒåˆ†æˆ–è€…åŒæŒ‡é’ˆç›´æŽ¥æ‰¾çš„,æ€»å¤æ‚åº¦ä¸º$O(nloglogTlogn)$. é»‘æš‚æ—¶å…ˆé»‘ä¸€ä¼š~ å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®åŠäº”è¿žæµ‹D2]]></title>
    <url>%2F2019%2F09%2F21%2FPJ%E4%BA%94%E8%BF%9E%E6%B5%8BD2%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€ å®‰æŽ’åº§ä½é¦–å…ˆæˆ‘ä»¬å¯ä»¥ç®—å‡ºå¯¹äºŽæ¯ä¸€æŽ’,æˆ‘ä»¬å¯ä»¥æŽ’å‡ºæ¥å¤šå°‘åº§ä½,ä»¥åŠä¸€å…±éœ€è¦å¤šå°‘æŽ’æ‰èƒ½æŠŠåº§ä½æŽ’å®Œ.ç„¶åŽæˆ‘ä»¬è€ƒè™‘æ’å…¥èµ°å»Šçš„äº‹æƒ…è¦ä½¿å¾—å°½é‡å¤šçš„ä½ç½®åœ¨èµ°å»Šè¾¹ä¸Š, äºŽæ˜¯åœ¨ n åˆ—ä¸­æ’å…¥èµ°å»Šçš„ç­–ç•¥æ˜¯æ˜¾ç„¶çš„, æˆ‘ä»¬åªè¦ä»¥ä¸¤åˆ—ä¸ºå•ä½, åœ¨å…¶ä¸­æ’å…¥å³å¯ï¼Žæœ‰ä¸€äº›è¾¹ç•Œæƒ…å†µéœ€è¦è€ƒè™‘æ¸…æ¥šï¼Ž åŠ æ³•é—®é¢˜æˆ‘ä»¬è€ƒè™‘å¦‚æžœæ»¡è¶³å¼å­$a \times 10^x+b \times 10^y$=$c \times 10^z$,é‚£ä¹ˆä¸€å®šæœ‰$a,b,c$è¿™ä¸‰ä¸ªæ•°åœ¨ä¹˜æ–¹ä¹‹åŽçš„ä½æ•°æœ€å°‘æ˜¯$len_c&gt;=len_{a,b}$é¦–å…ˆæˆ‘ä»¬å°†$c$çš„æœ«ä½æ•°è¡¥é½,ç„¶åŽæˆ‘ä»¬å‘çŽ°,$c$ä¸€å®šæ˜¯ç”±$a,b$ç›¸åŠ è¿›ä½ä¹‹åŽå¾—åˆ°çš„. æˆ‘ä»¬å›ºå®š$a,b$ä¸º$len_c$ä½å’Œ$len_{c-1}$ä½,ç„¶åŽæˆ‘ä»¬æžšä¸¾$0$çš„ä¸ªæ•°ä¹‹åŽåˆ¤æ–­. è¿™æ ·çš„è¯è²Œä¼¼è¦å†™é«˜ç²¾åº¦,å…¶å®žä¸ç”¨,æˆ‘ä»¬çŸ¥é“$hash$å°±æ˜¯ä»¥ä¸€ä¸ª$base$è¿›åˆ¶æ¥è¡¨ç¤ºæ•°çš„æ–¹å¼,å¦‚æžœæˆ‘ä»¬çš„$hash$ä¸­çš„$base$è®¾ä¸º$10$,é‚£ä¹ˆä¸€ä¸ªåŽŸæœ¬çš„$10$è¿›åˆ¶æ•°åœ¨$hash$ä¹‹åŽ,å¯ä»¥ç›´æŽ¥ç”¨å“ˆå¸Œå€¼åŠ å‡æ¥åˆ¤æ–­. æœ‰è¶£çš„æ•°ç»è¿‡æˆ‘ä»¬å¿«ä¹çš„æ‰“è¡¨ä¹‹åŽå‘çŽ°,å¯¹äºŽ$k$è¿›åˆ¶ä¸‹çš„æœ«å°¾æœ‰å¥‡æ•°ä¸ª$0$çš„æ•°,æœ‰$m=a \times k^p(p\equiv1\pmod{2},!a\equiv0\pmod{k})$.æœ‰äº†è¿™ä¸ªç»“è®º,æˆ‘ä»¬å°±å¯ä»¥å¿«é€Ÿçš„ç»Ÿè®¡å‡ºåœ¨$[1,n]$çš„åŒºé—´ä¸­,ç¬¦åˆæ¡ä»¶çš„æ•°å­—çš„ä¸ªæ•°.åˆå› ä¸ºä¸¤ä¸ªæ•°çš„ç›¸å¯¹å¤§å°å…³ç³»ä¸ä¼šå› ä¸ºè¿›åˆ¶è€Œæ”¹å˜,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥äºŒåˆ†åŒºé—´ä¸Šç•Œæ¥æ‰¾åˆ°æˆ‘ä»¬è¦æ‰¾çš„ç¬¬$n$ä¸ªæ•°. ä¸Žéžé—¨æ ‘æˆ‘ä»¬å‘çŽ°,å¯¹äºŽæŸä¸€ä¸ªèŠ‚ç‚¹,æ— è®ºæ˜¯å¦å‘ç”Ÿæ•…éšœ,é‚£ä¹ˆå®ƒçš„çŠ¶æ€ä¸€å®šåªæœ‰$0$å’Œ$1$ä¸¤ç§.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è®¾$f_{i,0/1,0/1}$,è¡¨ç¤ºçŽ°åœ¨æ˜¯ç¬¬$i$ä¸ªç‚¹,ç†è®ºçŠ¶æ€ä¸º$0/1$,å®žé™…çŠ¶æ€ä¸º$0/1$æ—¶çš„æ–¹æ¡ˆæ•°. ä¹ä¸€çœ‹è²Œä¼¼ä¸æ€Žä¹ˆå¯è½¬ç§»,æˆ‘ä»¬æƒ³,å¯¹äºŽç†è®ºçŠ¶æ€ä¸º$0$,å®žé™…çŠ¶æ€ä¹Ÿä¸º$0$çš„çŠ¶æ€ä¸€å®šæ˜¯åªèƒ½ä»Žå­æ ‘ä¸ºå…¨$0$å’Œå…¨$1$çš„çŠ¶æ€è½¬ç§»è€Œæ¥.ç„¶åŽå¯¹äºŽç†è®ºçŠ¶æ€å’Œå®žé™…çŠ¶æ€ç›¸å¼‚æˆ–ä¸º$1$çš„çŠ¶æ€,ä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡è¾“å…¥ä¸º$0$æˆ–è€…$1$çš„çŠ¶æ€å‡åŽ»è¾“å…¥å…¨$0$çš„çŠ¶æ€å¿«é€Ÿå¾—åˆ°ï¼Žç„¶åŽå¯¹äºŽ$f_{i,1,1}$çš„è¿™ç§çŠ¶æ€,æˆ‘ä»¬å¯ä»¥ç”¨æ‰€æœ‰çš„æ€»çŠ¶æ€å‡åŽ»å…¶ä»–çš„æ‰€æœ‰çŠ¶æ€è¾¾åˆ°. æ€»ç»“:æ¯”è¾ƒåŸºç¡€çš„æ ‘å½¢$DP$+ç®€å•å®¹æ–¥å³å¯.(æ°”ç¨½è´¥å.png) å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 73é¢˜è§£]]></title>
    <url>%2F2019%2F09%2F20%2FCF%E9%A2%98%E8%A7%A3%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[qwq A.2048 Gameæˆ‘ä»¬å‘çŽ°,æˆ‘ä»¬å¯ä»¥å¿½ç•¥æŽ‰$2048$ä»¥ä¸Šçš„æ•°,å‰©ä¸‹çš„æ•°å¼€æ¡¶ç»Ÿè®¡ç„¶åŽè´ªå¿ƒå³å¯. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 105;int n; ll num[N];int used[2050];int main ( void ) &#123; int T = _read (); while ( T-- ) &#123; memset ( used , 0 , sizeof ( used ) ); n = _read (); F ( i , 1 , n ) &#123; num[i] = _read (); if ( num[i] &lt;= 2048 ) used[num[i]]++; &#125; if ( used[2048] ) &#123; puts ( "YES" ); continue; &#125; for ( int i = 1 ; i &lt;= 1024 ; i *= 2 ) used[i * 2] += ( used[i] / 2 ); if ( used[2048] ) puts ( "YES" ); else puts ( "NO" ); &#125; return 0;&#125; B.Knightsæˆ‘ä»¬è´ªå¿ƒçš„è€ƒè™‘ä¸€ä¸‹,å¦‚æžœæˆ‘ä»¬çŽ°åœ¨è¿™ä¸ªä½ç½®çš„éª‘å£«,åœ¨å®ƒèƒ½ç§»åŠ¨çš„å…«ä¸ªæ–¹å‘ä¸Š,éƒ½ä¼šç¢°åˆ°å…¶ä»–çš„éª‘å£«,é‚£ä¹ˆè¿™ä¸ªä½ç½®å¯¹ç­”æ¡ˆçš„è´¡çŒ®ä¸€å®šæ˜¯æœ€ä¼˜çš„. ç»“åˆæ ·ä¾‹,æˆ‘ä»¬å¯ä»¥å‘çŽ°è¿™æ ·ä¸€ç§æž„é€ æ–¹æ³•,æˆ‘ä»¬ä»Žç‚¹$(1,1)$å¼€å§‹è¿›è¡Œä¸€æ¬¡$bfs$,ç„¶åŽæŒ‰ç…§éª‘å£«çš„ç§»åŠ¨æ–¹æ³•,æ¯æ¬¡æ›´æ–°ä¸€å±‚,ç„¶åŽæŠŠè¿™ä¸€å±‚çš„éª‘å£«æŸ“è‰²æˆå’ŒçŽ°åœ¨çš„éª‘å£«é¢œè‰²ä¸ä¸€æ ·çš„é¢œè‰². å¯¹äºŽå‰©ä¸‹çš„,é‚£ä¹ˆå¯ä»¥è¯æ˜Žæ²¡æœ‰ä»»ä½•ç‚¹èƒ½è·³åˆ°è¿™ä¸ªç‚¹,æ‰€ä»¥éšä¾¿ä»€ä¹ˆé¢œè‰²éƒ½å¯ä»¥. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/int n;char mp[105][105];const int dx[] = &#123; 0 , 1 , 1 , -1 , -1 , 2 , 2 , -2 , - 2 &#125;;const int dy[] = &#123; 0 , 2 , -2 , 2 , -2 , 1 , -1 , 1 , -1 &#125;;void dfs ( int x , int y , char col ) &#123; mp[x][y] = col; for ( int i = 1 ; i &lt;= 8 ; i++ ) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if ( xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= n &amp;&amp; mp[xx][yy] != 'W' &amp;&amp; mp[xx][yy] != 'B' ) dfs ( xx , yy , col == 'W' ? 'B' : 'W' ); &#125; return;&#125;int main ( void ) &#123; n = _read (); dfs ( 1 , 1 , 'W' ); bool flag = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= n ; j++ ) &#123; if ( mp[i][j] == 'W' || mp[i][j] == 'B' ) printf ("%c",mp[i][j]); else &#123; printf ("%c" , flag?'B':'W'); flag ^= 1; &#125; &#125; puts(""); &#125; return 0;&#125;// Main Code C.Perfect Teamä¸€ä¸ªç›´è§‚çš„æ„Ÿè§‰å°±æ˜¯ä½ ä»Ž$c,m$ä¸­å–ä¸€ä¸ª$Min$,ç„¶åŽæˆ‘ä»¬ä¼šå‘çŽ°å¯èƒ½äººæ•°å‡‘ä¸å¤Ÿ$Min*3$,æ‰€ä»¥æˆ‘ä»¬åˆ¤æ–­ä¸€ä¸‹$min(Min,sum/3)$å°±æ˜¯ç­”æ¡ˆäº†. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/int n;int c , m , x;int main ( void ) &#123; int T = _read (); while ( T-- ) &#123; read ( c , m , x ); int mins = min ( c , m ); int sums = c + m + x; printf ( "%d\n" , min ( mins , sums / 3 ) ); &#125; return 0;&#125;// Main Code D.Make The Fence Great Againæ¯’ç˜¤å‡ºé¢˜äººä¸€ä¸ªDPæ•°æ®èŒƒå›´å¼€3e5 çœ‹åˆ°$3e5$çš„æ•°æ®èŒƒå›´,ç¬¬ä¸€ååº”å°±æ˜¯è´ªå¿ƒ,ä½†æ˜¯å‘çŽ°è²Œä¼¼ä¸æ€Žä¹ˆå¯åš?ç„¶åŽå¼€å§‹è€ƒè™‘$DP$,å‘çŽ°å¦‚æžœ$i$è¿™ä¸ªç‚¹è¢«å‡é«˜äº†çš„è¯,è²Œä¼¼å¯¹åŽè¾¹çš„ç‚¹æ˜¯æœ‰å½±å“çš„,æœ‰åŽæ•ˆæ€§,æ€Žä¹ˆåŠž?æˆ‘ä»¬ç»è¿‡è§‚å¯Ÿå¯çŸ¥,å¦‚æžœä¸€ä¸ªç‚¹è¦å‡é«˜,é‚£ä¹ˆå®ƒæœ€å¤šå‡é«˜ä¸¤æ¬¡,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è®¾$f_{i,j}$è¡¨ç¤ºçŽ°åœ¨æ˜¯ç¬¬$i$ä¸ªä½ç½®,å…¶ä¸­$i$è¿™ä¸ªä½ç½®å‡é«˜äº†$j$æ¬¡. è½¬ç§»çš„è¯å¾ˆæ˜¾ç„¶,æˆ‘ä»¬æžšä¸¾ä¸€ä¸ªæœ€å°çš„$f_{i-1,k}$å¹¶ä¸”è¦ä¿è¯$fence_{i-1}.high+k$ä¸ç­‰äºŽ$fence_i.high+j$ç„¶åŽè½¬ç§»å°±å¥½äº†. æ—¶é—´å¤æ‚åº¦çš„è¯æ˜¯$O(n*16)$ç¡¬æ ¸O(nlogn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define int long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 3e5 + 10;int n , idx;struct Node &#123; int hi; int vi;&#125;fence[N];int f[N][5];signed main ( void ) &#123; int T = _read (); while ( T-- ) &#123; n = _read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; read ( fence[i].hi , fence[i].vi ); for ( int j = 0 ; j &lt;= 4 ; j++ ) f[i][j] = 1e17; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 0 ; j &lt;= 4 ; j++ ) &#123; for ( int k = 0 ; k &lt;= 4 ; k++ ) &#123; if ( fence[i].hi + j == fence[i - 1].hi + k ) continue; f[i][j] = min ( f[i][j] , f[i - 1][k] ); &#125; if ( f[i][j] == 1e17 ) continue; f[i][j] += 1ll * j * fence[i].vi; &#125; &#125; int ans = 1e17; for ( int i = 0 ; i &lt;= 4 ; i++ ) ans = min ( ans , f[n][i] ); writeln ( ans ); &#125; return 0;&#125;// Main Code å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO09FEB]æ”¹é€ è·¯Revamping Trailsé¢˜è§£]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%94%B9%E9%80%A0%E8%B7%AF%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[å¤ä¹ äº†ä¸€æ³¢åˆ†å±‚å›¾â€¦. å¯ä»¥å‘çŽ°è¿™é“é¢˜å°±æ˜¯åˆ†å±‚å›¾è£¸é¢˜.æˆ‘ä»¬å¯ä»¥è®¾$dis_{time,i}$è¡¨ç¤ºçŽ°åœ¨å·²ç»ç”¨äº†$time$æ¬¡å…è´¹æœºä¼š,åˆ°è¾¾äº†$i$è¿™ä¸ªç‚¹çš„æ—¶å€™çš„æœ€çŸ­è·¯å¾„.é‚£ä¹ˆæˆ‘ä»¬åœ¨è¿›è¡Œå †ä¼˜åŒ–$Dijkstra$æ—¶($SPFA$è·‘åˆ†å±‚å›¾ä¸€èˆ¬ä¼šæ­»çš„å¾ˆæƒ¨),æˆ‘ä»¬å¯¹äºŽæ¯æ¬¡è½¬ç§»æ—¶,åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦ä½¿ç”¨ä¸€æ¬¡å…è´¹æœºä¼šå³å¯. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define K 25#define N 10005#define M 4200005#define F(i,a,b) for(int i=a;i&lt;=b;i++)#define G(i,a,b) for(int i=head[a];i;i=b[i].next)using namespace std;int n,m,k,t,start,end;struct Edge&#123; int to; int data; int next;&#125;e[M];struct Que&#123; int time,cur; Que(int a,int b):time(a),cur(b)&#123;&#125;&#125;;int head[N],vis[K][N];bool inque[K][N];int ans=2147483647;struct cmp &#123; bool operator () ( Que x , Que y ) &#123; return vis[x.time][x.cur] &gt; vis[y.time][y.cur]; &#125;&#125;;priority_queue &lt; Que , vector &lt; Que &gt; , cmp &gt; qu;void add (int x,int y,int z)&#123; e[++t].to=y; e[t].data=z; e[t].next=head[x]; head[x]=t; return;&#125;inline void spfa (int x)&#123; memset(vis,0x3f3f3f3f,sizeof(vis)); vis[0][x]=0; inque[0][x]=1; qu.push(Que(0,1)); while (!qu.empty())&#123; Que j=qu.top(); qu.pop(); inque[j.time][j.cur]=0; G(i,j.cur,e)&#123; int k=e[i].to; if (vis[j.time][k]&gt;vis[j.time][j.cur]+e[i].data)&#123; vis[j.time][k]=vis[j.time][j.cur]+e[i].data; if (!inque[j.time][k])&#123; inque[j.time][k]=1; qu.push(Que(j.time,k)); &#125; &#125; &#125; if (j.time&lt;k) G(i,j.cur,e)&#123; int k=e[i].to; if (vis[j.time+1][k]&gt;vis[j.time][j.cur])&#123; vis[j.time+1][k]=vis[j.time][j.cur]; if (!inque[j.time+1][k])&#123; inque[j.time+1][k]=1; qu.push(Que(j.time+1,k)); &#125; &#125; &#125; &#125; F(i,0,k) ans=min(ans,vis[i][n]); return;&#125;int main()&#123; scanf ("%d%d%d",&amp;n,&amp;m,&amp;k); F(i,1,m)&#123; int x,y,z; scanf ("%d%d%d",&amp;x,&amp;y,&amp;z); add (x,y,z); add (y,x,z); &#125; spfa(1); printf ("%d\n",ans); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
        <tag>DP</tag>
        <tag>åˆ†å±‚å›¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æé«˜å¤±æ‹æµ‹D3]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E6%81%8B%E6%B5%8BD3%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€ æœ€é•¿01å­åºåˆ—æˆ‘ä»¬é¦–å…ˆè€ƒè™‘æš´åŠ›,æˆ‘ä»¬å‘çŽ°,ä¸€ä¸ªä¸²çš„å½¢å¼,æ˜¯ç”±å®ƒä¸­é—´çš„$0$çš„ä¸ªæ•°æ‰€å†³å®šçš„,è€Œä¸­é—´$0$çš„ä¸ªæ•°æ˜¯ç”±å‰å¯¼$0$çš„ä¸ªæ•°æ‰€å†³å®šçš„.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æžšä¸¾å‰å¯¼$0$çš„ä¸ªæ•°,ä»Žè€Œè´ªå¿ƒåŒ¹é…å³å¯,è¿™æ ·å¤æ‚åº¦ä¸º$O(n^2)$,èƒ½æ‹¿åˆ°60åˆ†. æˆ‘ä»¬æŽ¥ç€æ¥è€ƒè™‘æ€Žä¹ˆä¼˜åŒ–è¿™ä¸ªè¿‡ç¨‹,æˆ‘ä»¬å‘çŽ°,æˆ‘ä»¬åŒ¹é…çš„è¿‡ç¨‹,å°±æ˜¯ç»è¿‡ä¸€æ®µ$0$ä¹‹åŽ,æ‰¾åˆ°ä¸‹ä¸€ä¸ª$1$çš„ä½ç½®,è€Œéšç€ä½ç½®ä»Žå·¦å‘å³,å‰ç¼€çš„$0$çš„ä¸ªæ•°æ˜¯å•è°ƒé€’å¢žçš„,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è€ƒè™‘äºŒåˆ†ä¼˜åŒ–.æˆ‘ä»¬å¯¹äºŽçŽ°åœ¨çš„ä½ç½®$i$(åˆå§‹æƒ…å†µä¸‹ä¸º$0$,ä¸”å‡è®¾æˆ‘ä»¬çŽ°åœ¨æžšä¸¾çš„å‰å¯¼$0$çš„ä¸ªæ•°ä¸º$x$)æˆ‘ä»¬è¦æ‰¾çš„å°±æ˜¯æ»¡è¶³$fro[pos]-fro[i]&gt;=x$çš„æœ€å·¦è¾¹çš„ä½ç½®,è€Œè¿™ä¸ªä½ç½®æ˜¾ç„¶å¯ä»¥äºŒåˆ†å¤„ç†.æˆ‘ä»¬è®¡ç®—ä¸€ä¸‹å¤æ‚åº¦,å‘çŽ°è¿™ç§æ–¹æ³•çš„å¤æ‚åº¦ä¸º$\sum_{i=1}^n\frac{n}{i}$=$O(nIn n)$.ä¾¿å¯ä»¥é€šè¿‡æ­¤é¢˜. è·¯å¾„é•¿åº¦å…ˆè€ƒè™‘æš´åŠ›,æˆ‘ä»¬å¯ä»¥æŠŠåˆ°è¾¾æ¯ä¸€ä¸ªç‚¹çš„æ‰€æœ‰å€¼ç”¨èƒŒåŒ…è®°å½•ä¸‹æ¥,è¿™æ ·æœ‰$40$åˆ†. ç„¶åŽæˆ‘ä»¬è€ƒè™‘è¿™ä¸ªè¿‡ç¨‹,æˆ‘ä»¬å‘çŽ°,å¦‚æžœæˆ‘ä»¬è€ƒè™‘ä¸‰ä¸ªè·ç¦»$x,y,z$çš„è¯.å¦‚æžœè¿™ä¸‰ä¸ªè·ç¦»,æ»¡è¶³$z&lt;=1.1x&lt;=1.1y&lt;=1.1z$çš„è¯,é‚£ä¹ˆ$y$è¿™ä¸ªè·ç¦»å®Œå…¨å¯ä»¥ä¸è¦.åŽŸå› çš„è¯,æˆ‘ä»¬å‘çŽ°,æˆ‘ä»¬è¦æ±‚çš„æ˜¯åˆ°ä¸€ä¸ªç‚¹çš„è·ç¦»æ»¡è¶³åœ¨åŒºé—´$[dis,1.1dis]$ä¹‹é—´çš„è·¯å¾„,é‚£ä¹ˆå¦‚æžœè¿™é‡Œçš„$y$æ»¡è¶³$dis&lt;=y&lt;=1.1dis$çš„è¯,é‚£ä¹ˆ$x$å’Œ$z$å½“ä¸­ä¸€å®šä¼šæœ‰ä¸€ä¸ªæ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ ¹æ®è¿™ä¸ªæ¡ä»¶,ä¸è®°å½•æ‰€æœ‰çš„è·ç¦».åˆå› ä¸º$1.1^{420}$å¤§æ¦‚ç­‰äºŽ$10^{17}$,æ‰€ä»¥æˆ‘ä»¬åªéœ€è®°å½•$420$ä¸ªå·¦å³çš„è·ç¦».åŒæ—¶,åœ¨åˆå¹¶ä¸¤ä¸ªé›†åˆæ—¶,å¦‚æžœæˆ‘ä»¬ç”¨å½’å¹¶æŽ’åºæ—¶,å¯ä»¥åšåˆ°$O(A+B)=O(logM)$. åŠ¨æ€çŸ©é˜µæœ€çŸ­è·¯æˆ‘ä»¬å…ˆè€ƒè™‘ä¸€ç»´çš„æƒ…å†µ:å¯¹äºŽæ¯ä¸€æ¬¡çš„æ“ä½œ,æˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸€åˆ—çœ‹æˆä¸€ä¸ªç‚¹,ç„¶åŽæˆ‘ä»¬ç»´æŠ¤ä¸€ä¸‹è¿™ä¸ªç‚¹æœ€åŽä¸€æ¬¡è¢«æ¸…ç©ºçš„æ—¶é—´ç‚¹.ç„¶åŽå¯¹äºŽæ¯æ¬¡è¯¢é—®,æˆ‘ä»¬åªéœ€è¦æŸ¥è¯¢ä¸€ä¸‹ä¸¤ä¸ªç‚¹ä¸­é—´çš„æœ€å‰ä¸€æ¬¡è¢«æ¸…ç©ºçš„æ—¶é—´åˆ°çŽ°åœ¨æ˜¯ä¸æ˜¯å°äºŽ$v$å³å¯. å‘çŽ°è¿™ç§åšæ³•è²Œä¼¼å¾ˆå®¹æ˜“æŽ¨å¹¿åˆ°äºŒç»´çš„æƒ…å†µ,å¯¹äºŽè¡Œå’Œåˆ—,æˆ‘ä»¬åˆ†åˆ«å»ºçº¿æ®µæ ‘.ç„¶åŽæˆ‘ä»¬åˆ¤æ–­ä¸€ä¸‹ä¸¤ä¸ªç‚¹ä¹‹é—´çš„å„ç§è¿žæŽ¥æƒ…å†µç„¶åŽåˆ¤æ–­ç­”æ¡ˆå³å¯.è²Œä¼¼éœ€è¦å†™çº¿æ®µæ ‘ä¸ŠäºŒåˆ†. å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces round585é¢˜è§£]]></title>
    <url>%2F2019%2F09%2F15%2Fround585%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[A.å‚»é€¼é¢˜,æš´åŠ›æžšä¸¾å³å¯(æˆ‘ä¹Ÿå°±åªä¼šå‚»é€¼é¢˜äº†) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)#define G(i,a,b,c) for(rint a=head[b];a;a=c[a].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 10005;int n , a1 , a2 , k1 , k2 , idx;int num[N];inline bool cmp1 ( int x , int y ) &#123; return x &gt; y;&#125;inline bool cmp2 ( int x , int y ) &#123; return x &lt; y;&#125;int main ( void ) &#123; read ( a1 , a2 , k1 , k2 , n ); for ( int i = 1 ; i &lt;= a1 ; i++ ) num[++idx] = k1; for ( int i = 1 ; i &lt;= a2 ; i++ ) num[++idx] = k2; std :: sort ( num + 1 , num + 1 + idx , cmp1 ); int ans = 0; int tmp = n; for ( int i = 1 ; i &lt;= idx ; i++ ) if ( tmp &lt; num[i] ) &#123; tmp = 0; break; &#125; else tmp -= num[i] - 1; if ( tmp == 0 ) printf ( "%d " , ans ); else printf ( "%d " , tmp ); std :: sort ( num + 1 , num + 1 + idx , cmp2 ); ans = 0 , tmp = n; for ( int i = 1 ; i &lt;= idx ; i++ ) if ( tmp &lt; num[i] ) break; else &#123; ans ++; tmp -= num[i]; &#125; printf ( "%d\n" , ans ); return 0;&#125;// Main Code B.åˆ†ä»ŽåŽå¾€å‰çŽ°åœ¨çš„æ•°çš„æ­£è´Ÿæ€§è®¨è®ºå³å¯,è´Ÿè´Ÿå¾—æ­£. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 4e5 + 10;int n;ll num[N] , s[N];ll tai,fro;ll odd,uodd;int main ( void ) &#123; read ( n ); F ( i , 1 , n ) &#123; num[i] = _read (); s[i] = s[i - 1] ^ ( num[i] &lt; 0 ); if ( s[i] == 1 ) &#123; tai += odd; fro += uodd; odd++; fro++; &#125; else &#123; tai += uodd; fro += odd; tai++; uodd++; &#125; &#125; std :: cout &lt;&lt; fro &lt;&lt; " " &lt;&lt; tai &lt;&lt; std :: endl; return 0;&#125; C.å‘çŽ°åªæœ‰$A$å’Œ$B$,ä¸¤ç§å­—ç¬¦,å¾ˆå®¹æ˜“å‘çŽ°è§„å¾‹. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/char s[3][200005];int n , sum;int can1,can2,bc;int cnt1[200005],cnt2[200005];int main()&#123; read ( n ); scanf ( "%s%s" , s[1] , s[2] ); for(int i=0;i&lt;n;i++)&#123; if(s[1][i]!=s[2][i])&#123; if(s[1][i]=='a')&#123; can1++; cnt1[can1]=i+1; &#125; else&#123; can2++; cnt2[can2]=i+1; &#125; &#125; &#125; if(n%2==1)&#123; puts ( "-1" ); return 0; &#125; if(can1%2==1)&#123; sum+=2; sum+=(n-2)/2; writeln ( sum ); printf ( "%d %d\n" , cnt1[1] , cnt1[1] ); printf ( "%d %d\n" , cnt1[1] , cnt2[1] ); for(int i=2;i&lt;=can1;i+=2) printf ( "%d %d\n" , cnt1[i] , cnt1[i + 1] ); for(int i=2;i&lt;=can2;i+=2) printf ( "%d %d\n" , cnt2[i] , cnt2[i + 1] ); return 0; &#125; sum=(can1+can2)/2; writeln ( sum ); for(int i=1;i&lt;=can1;i+=2) printf ( "%d %d\n" , cnt1[i] , cnt1[i + 1] ); for(int i=1;i&lt;=can2;i+=2) printf ( "%d %d\n" , cnt2[i] , cnt2[i + 1] ); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®è½¬æä¸ƒè¿žæµ‹D2]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%99%AE%E4%B8%93%E6%8F%90D2%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€ T1.é¦–å…ˆ$naive$çš„åšæ³•å°±æ˜¯æžšä¸¾ä¸€ä¸‹ä»Ž$L$åˆ°$R$çš„æ•°ç„¶åŽåˆ¤æ–­æ˜¯å¦åˆæ³•,å¤æ‚åº¦ä¸º$O((R-L)*log_{10}n$) ç„¶åŽæ­£è§£æ˜¯æš´åŠ›æš´åŠ›å‡ºå¥‡è¿¹ æˆ‘ä»¬å¯ä»¥å‘çŽ°è¿™ç§æ•°æ˜¯ååˆ†ç¨€ç–çš„,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è€ƒè™‘æžšä¸¾æ¯ä¸€ä¸ªç‰¹æ®Šçš„æ•°å­—,ç„¶åŽåˆ¤æ–­æ¯ä¸€ä¸ªæ•°å­—æ˜¯å¦åœ¨åŒºé—´$[L,R]$ä¹‹å†….æ—¶é—´å¤æ‚åº¦ä¸º$O(17^2*9^2)$. T2.æˆ‘ä»¬é¦–å…ˆè®°å½•ä¸€ä¸‹æ¯ä¸ªå­—ç¬¦çš„å‰ç¼€å’Œ$A_i,B_i,C_i$æˆ‘ä»¬è€ƒè™‘æ€Žä¹ˆåˆ¤æ–­ä¸€ä¸ªåŒºé—´åˆæ³•:å¦‚æžœåœ¨ä¸€ä¸ªåŒºé—´$[l,r]$å½“ä¸­,$A_{l-1}-B_{l-1}==A_{r}-B{r}$,åŒæ—¶$B_{l-1}-C_{l-1}==B_r-C_r$.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹,å¦‚æžœå¯¹äºŽæ¯ä¸ª$i$,æˆ‘ä»¬æŠŠ$A_i-B_i$å’Œ$B_i-C_i$çœ‹æˆä¸¤ä¸ªäºŒå…ƒç»„,é‚£ä¹ˆæˆ‘ä»¬çš„ä»»åŠ¡å°±æ˜¯åŽ»å¯»æ‰¾æœ‰å‡ å¯¹äºŒå…ƒç»„ç›¸åŒ. T3.å…ˆè€ƒè™‘ä¸€ä¸‹èƒ½ç»„æˆ$11$çš„å€æ•°çš„æ•°çš„ç‰¹å¾:å¥‡æ•°ä½å’Œå¶æ•°ä½çš„å’Œçš„å·®çš„ç»å¯¹å€¼å¯¹$11$å–æ¨¡çš„ç»“æžœä¸º$0$.æ‰€ä»¥æˆ‘ä»¬æžšä¸¾ä¸€ä¸‹æ¯ä¸ªæ•°å­—åˆ†åˆ°å¥‡æ•°ä½è¿˜æ˜¯å¶æ•°ä½å³å¯,è¿™æ ·æ˜¯$O(2^n)$çš„,å¯ä»¥é€šè¿‡$60$åˆ†çš„æ•°æ®. æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹,å¦‚æžœåˆ†åˆ°äº†å¥‡æ•°ä½æˆ–è€…å¶æ•°ä½,é‚£ä¹ˆä»–çš„ä½ç½®å’Œè¢«æ”¾çš„å…ˆåŽé¡ºåºæ˜¯æ— å…³ç´§è¦çš„,æ¢å¥è¯è¯´,ä¹Ÿå°±æ˜¯æ— åŽæ•ˆæ€§.æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ç”¨èƒŒåŒ…å®žçŽ°è¿™ä¸ªè¿‡ç¨‹,æˆ‘ä»¬å¯ä»¥è®¾$f_{i,j,k}$è¡¨ç¤ºå‰$i$ä¸ªæ•°ä¸­,é€‰äº†$j$ä¸ªæ”¾åœ¨å¥‡æ•°ä½,èƒ½ä¸èƒ½ä½¿å’Œå˜æˆ$k$. ç„¶åŽæˆ‘ä»¬å°±å¯ä»¥ç»Ÿè®¡ç­”æ¡ˆäº†. T4.æˆ‘ä»¬é€šè¿‡æ€è€ƒå‘çŽ°,å¦‚æžœçŽ°åœ¨é¢å‰åªæœ‰$1$ä¸ªæˆ–è€…$2$ä¸ªæ€ªç‰©çš„è¯,å¦‚æžœæˆ‘ä»¬æ”¾ä¸€æ¬¡é‡å‡»å’Œæ”¾ä¸€æ¬¡$AOE$,é‚£ä¹ˆæˆ‘ä»¬çš„æ”¶ç›Šæ˜¯ç›¸åŒçš„(åœ¨çŽ°åœ¨ç”Ÿå‘½å€¼æœ€å°çš„æ€ªç‰©ä¸èƒ½è¢«ä¸€æ¬¡æ‰“æ­»çš„æƒ…å†µä¸‹).æ‰€ä»¥æˆ‘ä»¬è¦æŒ‰ç…§ç”Ÿå‘½å€¼ä»Žå°åˆ°å¤§æŽ’åº. æˆ‘ä»¬å‘çŽ°,å¦‚æžœçŽ°åœ¨æ€ªç‰©çš„æ•°é‡$num &gt;= 3$,é‚£ä¹ˆæˆ‘ä»¬æ”¾ä¸€æ¬¡ç¾¤æ”»çš„è¯,æ”¶ç›Šä¸€å®šæ¯”æ”¾ä¸€æ¬¡é‡å‡»è¦å¤§.æ‰€ä»¥æˆ‘ä»¬å°±å¯ä»¥ç›´æŽ¥è´ªå¿ƒäº†. å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ•°æ®ç”Ÿæˆ]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[å›¾å’Œæ ‘çš„æ•°æ®ç”Ÿæˆå™¨ å›¾æœ‰å‘å›¾å’Œæ— å‘å›¾åŒæ ·é€‚ç”¨çš„æ•°æ®ç”Ÿæˆå™¨,å¯ç”Ÿæˆéšæœºå›¾ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;using namespace std;int n,m,s,T;inline int random() &#123; static int seed = s; return seed = (int)(seed*48271ll%2147483647);&#125;set&lt;int&gt;to[100005];//åŽ»é‡int main() &#123; srand ( time ( NULL ) ) ; cin &gt;&gt; T; cout &lt;&lt; T &lt;&lt; endl; while(T--) &#123; s = rand(); n = 96; m = 102; printf("%d %d \n",n,m); for(int i = 1 ; i &lt;= m ; i++) &#123; int u = random() % n + 1; int v = random() % n + 1; while(to[u].find(v) != to[u].end() || u == v) &#123; u = random() % n + 1; v = random() % n + 1; &#125; printf("%d %d\n",u,v); to[u].insert(v); &#125; printf("\n"); &#125; return 0;&#125; æ ‘ä¿è¯æ•°æ®ä¸ºä¸€æ£µéšæœºæ ‘ 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;using namespace std;int a[10005],e[10005][2];int n = 1000;bool flag[10005];int main() &#123; freopen("testdata.in","w",stdout); printf("%d\n",n); for(int i = 1 ; i &lt;= n ; i++) &#123; a[i] = rand() % n + 1; while(flag[a[i]]) a[i] = rand() % n + 1; flag[a[i]] = 1; &#125; for(int i = 2 ; i &lt;= n ; i++) &#123; e[i-1][0] = a[i]; e[i-1][1] = a[rand() % (i - 1) + 1]; &#125; memset(flag,0,sizeof(flag)); for(int i = 1 ; i &lt; n ; i++) &#123; int x = rand() % (n - 1) + 1; while(flag[x]) x = rand() % (n - 1) + 1; flag[x] = 1; int f = rand() % 2; if(f) printf("%d %d\n",e[x][0],e[x][1]); else printf("%d %d\n",e[x][1],e[x][0]); &#125; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>çŸ¥è¯†æ°´å¹³</category>
      </categories>
      <tags>
        <tag>æ•°æ®åˆ¶é€ </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ™®åŠäº”è”æµ‹D1]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8BD1%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒåŽŸå› ,é¢˜é¢ä¸å…¬å¼€ T1.æ ¹æ®æŸäº›å¤§ä½¬è¯´å¯ä»¥ç›´æŽ¥æŠŠæ‰€æœ‰çš„æ•°åŠ èµ·æ¥å°±æ˜¯ç­”æ¡ˆ,ä½†æ˜¯å› ä¸ºæˆ‘è¿™ä¸ªäººæ¯”è¾ƒå¼±æ‰€ä»¥å°±åªä¼š$DP$äº†æˆ‘ä»¬è®¾$f[i][0/1]$è¡¨ç¤ºå‰$i$ä¸ªæ•°å­—ä¸­,åœ¨ä»Žç¬¬$i-1$æ¬¡åˆ°ç¬¬$i$æ¬¡çš„è½¬ç§»æ—¶ç”¨äº†åŠ /å¼‚æˆ–çš„æœ€å¤§å€¼,è½¬ç§»æ˜¾ç„¶. T2.æˆ‘ä»¬å¯ä»¥å‘çŽ°æ¯ä¸ªæ•°å­—,ä»Žä»–çŽ°åœ¨çš„ä½ç½®å¼€å§‹,åˆ°ä»–ä¸‹ä¸€æ¬¡å‡ºçŽ°çš„åœ°æ–¹ä¸ºæ­¢å°±æ˜¯è¿™ä¸ªæ•°å­—æœ‰è´¡çŒ®çš„åŒºé—´,ç„¶åŽæˆ‘ä»¬æŒ‰ç…§åŒºé—´ä¸ªæ•°ç»Ÿè®¡ç­”æ¡ˆå°±å¥½äº† T3:æˆ‘ä»¬å‘çŽ°å¦‚æžœæŒ‰ç…§é¢˜è§£ä»Žå°åˆ°å¤§æŽ’åºä¹‹åŽ,é‚£ä¹ˆèƒ½è¢«æ”¾ä¸‹çš„ä¸€å®šæ˜¯$[1,(n+1)/2]$è¿™ä¸ªåŒºé—´é‡Œçš„æ•°.ç„¶åŽæˆ‘ä»¬å¯ä»¥åŒæŒ‡é’ˆæ‰«ä¸€ä¸‹,é‡åˆ°èƒ½è£…çš„å°±è£…ä¸€å®šæ›´ä¼˜. T4æˆ‘ä»¬å‘çŽ°,ä¸€ä¸ªæ€§è´¨,å¦‚æžœä¸€æ¡é“¾çš„ä¸¤ä¸ªé¡¶ç‚¹çš„$LCA$åœ¨ç¬¬ä¸‰æ¡é“¾ä¸Š,é‚£ä¹ˆè¿™ä¸¤æ¡é“¾ä¸€å®šä¼šæœ‰äº¤ç‚¹.æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨æ ‘ä¸Šå·®åˆ†ç»Ÿè®¡ä¸€ä¸‹æ¯ä¸ªç‚¹è¢«ç»è¿‡äº†å¤šå°‘æ¬¡,ç„¶åŽæˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹åŽ»é‡.æˆ‘ä»¬å‘çŽ°,å¦‚æžœä¸€ä¸ªç‚¹è¢«å¤šæ¡é“¾çš„$LCA$åŒæ—¶ç»è¿‡äº†ä¸€ä¸ªç‚¹çš„è¯,é‚£ä¹ˆåœ¨è¿™ä¸ªç‚¹ä¸Š,ç­”æ¡ˆä¼šè¢«é‡å¤ç»Ÿè®¡å¤šæ¬¡,æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ç»Ÿè®¡ä¸€ä¸‹æ¯ä¸ªç‚¹ä¸Š$LCA$å‡ºçŽ°çš„æ¬¡æ•°ç„¶åŽç»„åˆæ•°å­¦åŽ»é‡å³å¯. å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£:æ ‘]]></title>
    <url>%2F2019%2F09%2F12%2F%E9%A2%98%E8%A7%A3-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[æš´åŠ›éƒ½ä¸æƒ³å†™çš„é¢˜â€¦ è€ƒè™‘åˆ°é¢˜ç›®ä¸­è¦æ±‚çš„æœ€å°çš„é‚£ä¸ªä¸œè¥¿ä¸å¤ªå¥½æ±‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ‰¾ä¸€ä¸ªæœ€å¤§çš„ç¬¦åˆæ¡ä»¶çš„å€¼,æˆ‘ä»¬è®°ä¸º$tmp$,é‚£ä¹ˆæœ‰$ans=tmp+1$ é‚£æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹è¿™ä¸ª$tmp$æ€Žä¹ˆæ±‚.å‘çŽ°å’Œæ ‘çš„ç›´å¾„è¿™ä¸ªä¸œè¥¿ç±»ä¼¼,ç„¶åŽå°±æ²¡å•¦x å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>æ ‘çš„ç›´å¾„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROIæ™®è½¬æD1é¢˜è§£]]></title>
    <url>%2F2019%2F09%2F11%2FZROI%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒé—®é¢˜,é¢˜é¢ä¸å…¬å¼€ T1.æ˜¾ç„¶å¯ä»¥å‘çŽ°è¿™ä¸ªåŒºé—´é•¿åº¦æ»¡è¶³å•è°ƒæ€§(è®¾$len1&gt;len2$,é‚£ä¹ˆå¦‚æžœ$len2$æ»¡è¶³æ¡ä»¶,$len1$ä¸€å®šæ»¡è¶³æ¡ä»¶.).æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è€ƒè™‘äºŒåˆ†ç­”æ¡ˆ.æˆ‘ä»¬è®¾$buck[i][j]$æ•°ç»„æ¥è¡¨ç¤ºå‰$i$ä¸ªæ•°ä¸­,$j$è¿™ä¸ªæ•°å­—å‡ºçŽ°äº†å¤šå°‘æ¬¡(å°±æ˜¯ä¸€ä¸ªå‰ç¼€å’Œ).ä½†æ˜¯è¿™æ ·çš„è¯æˆ‘ä»¬ä¼šå‘çŽ°æ•°æ®çš„æƒå€¼æ˜¯$10^9$èŒƒå›´çš„,ç›´æŽ¥å¼€ä¸€ä¸ªæ¡¶ä¼šæŒ‚æŽ‰(å¼€$map$ä¼š$TLE$,,,ä¸è¦é—®æˆ‘å’‹çŸ¥é“çš„),æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘å…ˆå¯¹æ•°æ®ç¦»æ•£åŒ–.ç„¶åŽå¯¹äºŽæ¯ä¸€æ¬¡äºŒåˆ†,æˆ‘ä»¬å¯ä»¥$O(n)$æžšä¸¾åŒºé—´,ç„¶åŽæžšä¸¾æƒå€¼,å¯¹äºŽæ¯ä¸ªæžšä¸¾çš„åŒºé—´å¯ä»¥$O(n)$checkæ¯ç§æƒå€¼,æ€»å¤æ‚åº¦ä¸º$O(n^2log_2n)$ T2.æ˜¾ç„¶å¯ä»¥å‘çŽ°,é¢˜ç›®ä¸­è¦æ±‚çš„ä¸ªä½æ•°å­—åªå—è¦é™¤çš„æ•°çš„ä¸ªä½çš„å½±å“,æ‰€ä»¥æˆ‘ä»¬åœ¨æ±‚å‡ºæ¥äº†å€æ•°çš„ä¸ªæ•°$num$æ—¶,å¯ä»¥å‘çŽ°,ä¸ªä½æ•°å­—çš„å‡ºçŽ°æ˜¯æœ‰å‘¨æœŸçš„,è€Œè¿™ä¸ªå‘¨æœŸå’Œå‘¨æœŸä¸­çš„æ•°å­—æ˜¯ç”±è¦é™¤çš„æ•°å­—çš„ä¸ªä½å†³å®šçš„.è€Œå› ä¸ºè¦é™¤çš„æ•°å­—çš„ä¸ªä½æœ€å¤šåªæœ‰10ä¸ª,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆé¢„å¤„ç†å‡ºæ¯ä¸ªæ•°å­—çš„å‘¨æœŸä»¥åŠä»–ä»¬çš„å’Œ,å†å¯¹å¤šå‡ºæ¥çš„éƒ¨åˆ†ç›´æŽ¥æš´åŠ›å°±å¯ä»¥äº†. T3.ç¬¬ä¸€çœ¼çœ‹ä¸ŠåŽ»å‘çŽ°é™åˆ¶æœ‰ç‚¹å¤š,ä½†æ˜¯åˆ†æžä¸€ä¸‹,ä¸€ä¸ªç‰©å“èƒ½ä¸èƒ½æ”¾åªå—åˆ°äº†å®ƒæ”¾çš„æ—¶é—´ä»¥åŠå®ƒä¸Šè¾¹æœ€å¤šæ”¾å¤šå°‘ä¸œè¥¿çš„é™åˆ¶.æ‰€ä»¥å¯¹äºŽæ—¶é—´è¿™ä¸€æ–¹é¢çš„é™åˆ¶,æˆ‘ä»¬å¯ä»¥è€ƒè™‘å¯¹æ—¶é—´è¿™ä¸€ç»´è¿›è¡ŒæŽ’åº. è®²çš„å¾ˆæ˜Žç™½,ä½†æ˜¯æˆ‘å¹¶ä¸çŸ¥é“æ€Žä¹ˆè¯æ˜Žqwq D.ç¬¬ä¸€çœ¼çœ‹æ¥è²Œä¼¼ä¸æ€Žä¹ˆå¯åšâ€¦ è‡ªå·±è§‚å¯Ÿä¹‹åŽæˆ‘ä»¬å‘çŽ°ç›´æŽ¥æ±‚æ‰€æœ‰çš„æ–¹æ¡ˆæ•°è²Œä¼¼ä¸å¤ªå¯åšâ€¦æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹å®¹æ–¥. æˆ‘ä»¬è®¾$f_i$ä¸ºåŒ…å«äº†çŠ¶æ€$i$ä»¥åŠçŠ¶æ€$i$çš„æ‰€æœ‰å­é›†çš„æ–¹æ¡ˆæ•°.é‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹æ€Žä¹ˆå®¹æ–¥. æˆ‘ä»¬ä»¥$n=3$çš„æƒ…å†µä¸ºç¤ºèŒƒ.(ä¸è¦åæ§½æˆ‘æ˜¯çµé­‚ç”»å¸ˆ) æˆ‘ä»¬å¯ä»¥å‘çŽ°,å¯¹äºŽæŸä¸ªçŠ¶æ€$j$,å½“è¿™ä¸ªçŠ¶æ€ä¸­çš„$1$çš„ä¸ªæ•°çš„å¥‡å¶æ€§ç­‰äºŽ$(1&lt;&lt;m)-1$çš„ä¸ªæ•°æ—¶,é‚£ä¹ˆå¯ä»¥å‘çŽ°æ­¤çŠ¶æ€çš„må®¹æ–¥ç³»æ•°ä¸º$1$,å¦åˆ™,è¯¥çŠ¶æ€çš„å®¹æ–¥ç³»æ•°ä¸º$-1$. æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆæ­¥çš„åˆ—å‡ºä¸€ä¸ªå¼å­: ans=\sum_{i=0}^{(1]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ•£æ­¥]]></title>
    <url>%2F2019%2F09%2F11%2F%E6%95%A3%E6%AD%A5%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[è¿™é¢˜å¥½éš¾å•Š é¦–å…ˆå¯ä»¥å‘çŽ°å¯ä»¥äºŒåˆ†ç­”æ¡ˆ. æˆ‘ä»¬å¯ä»¥è€ƒè™‘äºŒåˆ†ä¸€ä¸ªæœ€é•¿çš„è·¯å¾„é•¿åº¦$mid$,ç„¶åŽå°†æ¯ä¸ªç‚¹çœ‹æˆä¸èƒ½åœ¨æœ€å¤šè¿žç»­èµ°$mid$ä¸ªç›¸åŒçš„è·¯çš„æƒ…å†µä¸‹,ä»Ž$1$å·ç‚¹åˆ°$n$å·ç‚¹æ˜¯å¦è”é€š. ç„¶åŽçŽ°åœ¨çš„é—®é¢˜å°±å˜æˆäº†åˆ¤æ–­å›¾çš„è¿žé€šæ€§çš„é—®é¢˜.æˆ‘ä»¬å‘çŽ°,æ¯ä¸ªç‚¹åªæœ‰ä¸¤æ¡å‡ºè¾¹.è€Œä¸”æ¯ç§ç±»åž‹çš„å‡ºè¾¹åªæœ‰ä¸€æ¡,é‚£ä¹ˆå¯ä»¥å‘çŽ°åŒæ ·çš„ç±»åž‹çš„è·¯å¾„çš„èµ°è·¯çš„è·¯å¾„,å¯ä»¥çœ‹ä½œä¸€ä¸ªé›†åˆ.æˆ‘ä»¬å¯ä»¥è®¾$dis_{i,siz}$è¡¨ç¤º$i$è¿™ä¸ªç‚¹ä¸€ç›´æŒ‰ç…§$siz$ç±»åž‹çš„è·¯å¾„ä¸€ç›´èµ°,æœ€åŽä¸€æ®µ$siz$è·¯å¾„çš„é•¿åº¦,ç„¶åŽæˆ‘ä»¬å‘çŽ°,å¦‚æžœ$i$è¿™ä¸ªç‚¹èµ°åˆ°$j$è¿™ä¸ªç‚¹æ—¶,é‚£ä¹ˆ$dis_{j,siz}=dis_{i,siz}+1$,è€Œæˆ‘ä»¬å‘çŽ°è¿™ä¸ªä¸œè¥¿æ˜¾ç„¶å¯ä»¥ç”¨å¸¦æƒå¹¶æŸ¥é›†æ¥ç»´æŠ¤.åœ¨ä½¿ç”¨äº†å¸¦æƒå¹¶æŸ¥é›†ä¹‹åŽ,æˆ‘ä»¬æ¯æ¬¡å°±å¯ä»¥åœ¨$O(logn)$çš„æ—¶é—´å¤æ‚åº¦å†…æ±‚å‡ºä»¥æŸä¸ªç‚¹ä¸ºèµ·ç‚¹èµ°åˆ°æœ€è¿œèƒ½èµ°åˆ°é‚£ä¸ªç‚¹äº†.ç„¶åŽæˆ‘ä»¬å¯ä»¥è¿›è¡Œä¸€æ¬¡$bfs$.åœ¨æŸæ¬¡æ›´æ–°ä¸­,å¯ä»¥å‘çŽ°,å¦‚æžœçŽ°åœ¨åˆ°è¾¾è¿™ä¸ªç‚¹çš„æœ€åŽçš„è·¯å¾„æ˜¯$siz$ç±»åž‹çš„è¯,å¦‚æžœçŽ°åœ¨è¿™ä¸ªç‚¹è¿žå‘çš„$siz xor 1$ç±»åž‹çš„ç‚¹è¿˜æ²¡æœ‰è¢«å…¥é˜Ÿè¿‡,é‚£ä¹ˆå°±å°†è¿™ä¸ªç‚¹æ‰”è¿›é˜Ÿé‡Œ. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 2e5 + 10; int n;int G[N][2];int father[N][2] , dis[N][2];bool vis[N][2];struct Node &#123; int pos; int kid;&#125;;std :: queue &lt; Node &gt; qu;int find ( int x , int kd ) &#123; if ( father[x][kd] != x ) &#123; int tmp = father[x][kd]; father[x][kd] = find ( father[x][kd] , kd ); dis[x][kd] += dis[tmp][kd]; &#125; return father[x][kd];&#125;inline bool check ( int rdm ) &#123; memset ( vis , false , sizeof ( vis ) ); memset ( dis , 0 , sizeof ( dis ) ); F ( i , 1 , n ) father[i][0] = father[i][1] = i; qu.push ( Node &#123; 1 , 0 &#125; ); qu.push ( Node &#123; 1 , 1 &#125; ); while ( !qu.empty() ) &#123; int j = qu.front().pos; int siz = qu.front().kid; qu.pop(); int now = 0; while ( 1 ) &#123; int root = find ( j , siz ); now = dis[j][siz]; if ( now + 1 &gt; rdm ) break; int kt = G[root][siz]; int kj = find ( kt , siz ); if ( !vis[kt][siz ^ 1] ) &#123; vis[kt][siz ^ 1] = 1; qu.push ( Node &#123; kt , siz ^ 1 &#125; ); &#125; if ( kj == root ) break; father[root][siz] = kt; dis[root][siz] = 1; &#125; &#125; if ( vis[n][0] || vis[n][1] ) return 1; return 0;&#125;int main ( void ) &#123; read ( n ); F ( i , 1 , n ) &#123; G[i][0] = _read(); G[i][1] = _read(); &#125; int l = 0 , r = n + 1; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( check ( mid ) ) r = mid - 1; else l = mid + 1; &#125; if ( l &gt; n ) puts ( "-1" ); else writeln ( l ); return 0;&#125;// Main Code å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>äºŒåˆ†</tag>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 72 é¢˜è§£æŠ¥å‘Š]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[qwq A.ç¬¬ä¸€çœ¼çœ‹ä¸ŠåŽ»è²Œä¼¼æ˜¯ä¸ªæ‰¾è§„å¾‹$O(1)$é¢˜,å®žé™…çœ‹äº†ä¸€ä¸‹,ç¡®å®žæ˜¯æ‰¾è§„å¾‹$O(1)$é¢˜.æ‰€ä»¥å°±å¼€å§‹æ„‰å¿«çš„æ‰¾è§„å¾‹,äºŽæ˜¯å°±æœ‰äº†ä»¥ä¸‹çš„æäº¤è®°å½•: emmmâ€¦. QAQç„¶åŽæˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹æ­£è§£. æˆ‘ä»¬è®¾åŽŸæ¥æˆ‘ä»¬æœ‰$str in exp$,æˆ‘ä»¬è®¾æˆ‘ä»¬åˆ†ç»™$str x$ç‚¹çš„$exp$,åˆ†ç»™$in y$ç‚¹çš„$exp$,é‚£ä¹ˆæ˜¾ç„¶æœ‰: x+y=exp \ and \ str+x>in+yå‘çŽ°ä¸Šè¾¹çš„è¿™ä¸ªæ–¹ç¨‹,é€šè¿‡å°†$y$ç”¨$exp-x$ä»£æ›¿ä¹‹åŽ,æˆ‘ä»¬å¯ä»¥è§£å‡º$x$çš„å…·ä½“èŒƒå›´.è€Œä¸”æˆ‘ä»¬å¯ä»¥å‘çŽ°:æ‰€æœ‰$x$çš„å–å€¼èŒƒå›´ä¸€å…±åªæœ‰$exp + 1$ç§,æ‰€ä»¥å°±å¯ä»¥æ„‰å¿«çš„æ±‚å‡ºç­”æ¡ˆäº†. æœ€åŽåˆ«å¿˜äº†åˆ¤æ–­$exp$ä¸º$0$çš„æƒ…å†µ. 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; int str,in,exp; cin&gt;&gt;str&gt;&gt;in&gt;&gt;exp; if (exp==0)&#123; if(str&gt;in) cout&lt;&lt;"1"&lt;&lt;endl; else cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; if(in+exp-str&lt;0)&#123; cout&lt;&lt;exp+1&lt;&lt;endl; continue; &#125; int ans=min(exp+1,(exp+1)-max(0ll,((in+exp-str)/2+1))); if ( ans &lt; 0 ) ans = 0; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; B.è¿™ä¹ˆå¯çˆ±çš„æ€ªå…½æˆ‘æ€Žä¹ˆå¯èƒ½å¿å¿ƒåŽ»æ‰“å®ƒå‘¢ æˆ‘ä»¬çœ‹åˆ°é¢˜,é¦–å…ˆæƒ³åˆ°,å¦‚æžœæˆ‘ä»¬ç ä¸€åˆ€,è¿™ä¸ªæ€ªå…½ä¸æ­»,é‚£ä¹ˆå®ƒå¦‚æžœé•¿å‡ºæ¥çš„å¤´å¤§äºŽæˆ‘ä»¬æˆ‘ä»¬è¿™æ¬¡ç æŽ‰çš„å¤´.é‚£ä¹ˆæˆ‘ä»¬è¿™æ¬¡çš„æ“ä½œæ˜¾ç„¶æ²¡ç”¨.æ‰€ä»¥,åœ¨å‰å‡ åˆ€ç ä¸æ­»æ€ªå…½çš„æƒ…å†µä¸‹,æˆ‘ä»¬éœ€è¦æœ€å¤§åŒ–æ¯ä¸€æ¬¡ç å¤´æ—¶çš„$d_i-h_i$,åŒæ—¶æˆ‘ä»¬å‘çŽ°.åœ¨æŸä¸€æ¬¡ç å¤´ä¸­,å¦‚æžœè¿™æ¬¡çš„$d_j$éžå¸¸å¤§,å¤§åˆ°ä¸€ä¸‹å­å¯ä»¥æŠŠæ€ªå…½å‰©ä¸‹çš„å¤´ç å®Œ.æˆ‘ä»¬å°±å¯ä»¥ä¸ç”¨ç®¡è¿™æ¬¡ç å¤´çš„å‰¯ä½œç”¨$h_j$äº†. æ‰€ä»¥æˆ‘ä»¬ç»´æŠ¤ä¸¤ä¸ªæœ€å¤§å€¼,å³$d_i-h_i$çš„æœ€å¤§å€¼ä»¥åŠ$d_i$çš„æœ€å¤§å€¼,ç„¶åŽç›´æŽ¥æ‰¾é¢˜æ„åšå³å¯. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n,x;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; int maxs=-1e16; int Damage=-1e16; cin&gt;&gt;n&gt;&gt;x; for(int i=1;i&lt;=n;i++) &#123; int tx,ty; cin&gt;&gt;tx&gt;&gt;ty; maxs=max(maxs,tx); Damage=max(Damage,tx-ty); &#125; if ( x &lt;= maxs ) &#123; cout &lt;&lt; "1" &lt;&lt; endl; continue; &#125; if(Damage&lt;=0)&#123; cout&lt;&lt;"-1"&lt;&lt;endl; continue; &#125; int now = ( x - maxs ) / Damage; if ( now * Damage &lt; x - maxs ) now+=2; else now++; cout&lt;&lt;now&lt;&lt;endl; &#125; return 0;&#125; C.é€šè¿‡è¯»é¢˜,æˆ‘ä»¬å¯ä»¥å‘çŽ°ä¸€ä¸ªå¾ˆé‡è¦çš„ä¸œè¥¿:$\sum_{i=1}^t len_i&lt;=2*10^5$. é€šè¿‡è¿™ä¸ªæ€§è´¨,æˆ‘ä»¬å¯ä»¥å‘çŽ°,æˆ‘ä»¬åœ¨æžšä¸¾æ¯ä¸€æ¬¡çš„åŒºé—´æ—¶,è¿™ä¸ªåŒºé—´çš„æœ€é•¿é•¿åº¦ä¸º$log_2len$. ç„¶åŽå°±åšå®Œäº†?? æˆ‘ä»¬æžšä¸¾ä¸€ä¸‹æ¯ä¸ªåŒºé—´çš„å·¦/å³ç«¯ç‚¹,ç„¶åŽç›´æŽ¥æš´åŠ›ç»Ÿè®¡ç­”æ¡ˆå°±å¥½äº†. 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int N = 200000 + 10;int t,nex[N];char s[N];int main() &#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",s+1); int n=strlen(s+1); nex[n+1]=n+1; for(int i=n;i&gt;=1;i--) &#123; if(s[i]=='0') nex[i]=nex[i+1]; else nex[i]=i; &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; int now=0; for(int j=nex[i];j&lt;=min(n,nex[i]+20);j++)&#123; now=now*2+s[j]-'0'; if(now==j-i+1) ans++; &#125; &#125; printf("%d\n", ans); &#125;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round #582è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2F2019%2F09%2F11%2FRound-2%2F</url>
    <content type="text"><![CDATA[qwq A.Chips Movingé¢˜æ„å°±æ˜¯ç»™ä½ nä¸ªæ•°,ä½ æ¯æ¬¡å¯ä»¥é€‰æ‹©ä¸€ä¸ªæ•°,å¯¹ä»–è¿›è¡Œå…è´¹çš„åŠ 2æˆ–è€…å‡2.æˆ–è€…èŠ±è´¹1çš„ä»£ä»·,å¯¹æŸä¸ªæ•°è¿›è¡ŒåŠ ä¸€æˆ–è€…å‡ä¸€,æ±‚è®©æ‰€æœ‰çš„æ•°å˜æˆä¸€æ ·çš„æœ€å°ä»£ä»·. å¾ˆæ˜¾ç„¶å¯ä»¥å‘çŽ°,å¥‡æ•°å’Œå¥‡æ•°ä¹‹é—´å¯ä»¥ç›¸äº’è½¬å˜,å¶æ•°å’Œå¶æ•°ä¹‹é—´ä¹Ÿå¯ä»¥ç›¸äº’è½¬å˜,é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦è€ƒè™‘è®©å¥‡æ•°å…¨éƒ¨å˜æˆå¶æ•°æˆ–è€…è®©å¶æ•°å˜æˆå¥‡æ•°å°±å¥½äº†. 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int cnto = 0; for (int i = 0; i &lt; n; ++i) &#123; int x; cin &gt;&gt; x; cnto += x &amp; 1; &#125; cout &lt;&lt; min(cnto, n - cnto) &lt;&lt; endl; return 0;&#125; B.Bad Pricesé¢˜æ„å°±æ˜¯ç»™ä½ ä¸€ä¸ªåºåˆ—$A$,è®©ä½ æ±‚å‡ºæ‰€æœ‰$A_i$ä¸­,$\sum_{i=1}^n[A_i&gt;A_{j(i&lt;j&lt;=n)}?0:1]$ æ˜¾ç„¶å¯ä»¥ç›´æŽ¥ç»´æŠ¤ä¸€ä¸ªåŽç¼€æœ€å°å€¼,ç„¶åŽåˆ¤æ–­ä¸€ä¸‹å½“å‰$A_i$çš„å€¼å’Œå½“å‰åŽç¼€æœ€å°å€¼çš„å¤§å°å…³ç³»,å¦‚æžœ$A_i&gt;num_i$,é‚£ä¹ˆans++ 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std; const int N=150005; int n;int num[N];int mins[N]; int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(mins,0x3f3f3f3f,sizeof(mins)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;num[i]); for(int i=n-1;i&gt;=1;i--) mins[i]=min(mins[i+1],num[i+1]); int ans=0; for(int i=1;i&lt;n;i++) if(num[i]&gt;mins[i]) ans++; printf("%d\n",ans); &#125; return 0;&#125; // C.Book Readingæ˜¾ç„¶å¯ä»¥å‘çŽ°,é¢˜ç›®ä¸­è¦æ±‚çš„ä¸ªä½æ•°å­—åªå—è¦é™¤çš„æ•°çš„ä¸ªä½çš„å½±å“,æ‰€ä»¥æˆ‘ä»¬åœ¨æ±‚å‡ºæ¥äº†å€æ•°çš„ä¸ªæ•°$num$æ—¶,å¯ä»¥å‘çŽ°,ä¸ªä½æ•°å­—çš„å‡ºçŽ°æ˜¯æœ‰å‘¨æœŸçš„,è€Œè¿™ä¸ªå‘¨æœŸå’Œå‘¨æœŸä¸­çš„æ•°å­—æ˜¯ç”±è¦é™¤çš„æ•°å­—çš„ä¸ªä½å†³å®šçš„.è€Œå› ä¸ºè¦é™¤çš„æ•°å­—çš„ä¸ªä½æœ€å¤šåªæœ‰10ä¸ª,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆé¢„å¤„ç†å‡ºæ¯ä¸ªæ•°å­—çš„å‘¨æœŸä»¥åŠä»–ä»¬çš„å’Œ,å†å¯¹å¤šå‡ºæ¥çš„éƒ¨åˆ†ç›´æŽ¥æš´åŠ›å°±å¯ä»¥äº†. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define int long long using namespace std; int n,m;int ned[10],idx[10];int sum[10][10]; signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); for(int i=1;i&lt;=9;i++)&#123; int now=i; sum[i][++idx[i]]=i; now+=i; while(now!=i)&#123; if(now&gt;=10) now-=10; sum[i][++idx[i]]=now; now+=i; &#125; &#125; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=idx[i];j++) ned[i]+=sum[i][j]; int T; cin&gt;&gt;T; while(T--)&#123; int ans=0; cin&gt;&gt;n&gt;&gt;m; int numm=n/m; int tmp = m; tmp%=10; if(tmp==0||numm==0)&#123; cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; int fir = numm/idx[tmp]; ans+=fir*ned[tmp]; // cout&lt;&lt;fir&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl; int sos=0; for(int i=fir*idx[tmp]+1;i&lt;=numm;i++) ans+=sum[tmp][i-fir*idx[tmp]]; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; // D.Equalizing by Divisionæˆ‘ä»¬å¯ä»¥å‘çŽ°,å¯¹äºŽæŸä¸€ä¸ªæ•°$i$,ä»–èƒ½å˜æˆçš„æ•°çš„ä¸ªæ•°ä¸º$log_2i+1$ä¸ª,è€Œä¸”é¢˜ç›®ä¸­$i$çš„æƒå€¼ä¹Ÿä¸å¤§,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¼€ä¸€ä¸ªæ¡¶,æŒ‰ç…§ä»Žå°åˆ°å¤§çš„é¡ºåºå¤„ç†æ¯ä¸€ä¸ªæ•°å­—,æ¯æ¬¡å¤„ç†çš„æ—¶å€™å°†å®ƒèƒ½å˜æˆçš„$log_2i$ä¸ªæ•°å­—åœ¨æ¡¶ä¸­çš„æƒå€¼å…¨éƒ¨+1,åŒæ—¶èŠ±è´¹å°±æ˜¯ä»ŽåŽŸæ¥çš„iåˆ°ç›®å‰çš„æ•°å­—è¦é™¤å‡ æ¬¡äºŒ,å½“å‘çŽ°æœ‰æ¡¶ä¸­çš„æ•°å­—å¤§äºŽç»™å®šçš„$k$æ—¶,æ›´æ–°ç­”æ¡ˆ. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std; const int N = 2e5 + 10; int n,k,ans=2147483647;int num[N];struct Node&#123; int val; int now;&#125;buck[N]; int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; buck[num[i]].now++; if(buck[num[i]].now&gt;=k)&#123; cout&lt;&lt;"0"&lt;&lt;endl; return 0; &#125; &#125; sort(num+1,num+1+n); for(int i=1;i&lt;=n;i++)&#123; int idx=1,tmp=num[i]/2; while(tmp)&#123; buck[tmp].now++; buck[tmp].val+=idx; if(buck[tmp].now&gt;=k) ans=min(ans,buck[tmp].val); tmp/=2; idx++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; // å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Qualificationè§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2F2019%2F09%2F11%2FQualification%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[qwq T1:é¢˜ç›®ä¸­ç»™ä½ ä¸€ä¸ª$D$å’Œä¸€ä¸ª$M$(ä¸€å¹´æœ‰$D$ä¸ªæœˆ,ä¸€ä¸ªæœˆæœ‰$M$å¤©)è®©ä½ æ±‚å‡º: $d_1&gt;=2$ $d_{10}&gt;=2$ $d_1 \times d_{10} = m$ çš„ä¸ªæ•°.å…¶ä¸­$d_1$è¡¨ç¤ºä¸ªä½,$d_{10}$è¡¨ç¤ºåä½. å› ä¸ºæ•°æ®èŒƒå›´æ¯”è¾ƒå°,æ‰€ä»¥å¯ä»¥ç›´æŽ¥æš´åŠ›æžšä¸¾è§£å†³qwqâ€¦ 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int m,d,ans;int main(void)&#123; scanf("%d%d",&amp;m,&amp;d); for(int i=1;i&lt;=m;i++)&#123; for(int sw=22;sw&lt;=d;sw++)&#123; int g=sw%10; int s=sw/10; if(g&gt;=2&amp;&amp;s&gt;=2&amp;&amp;s*g==i) ans++; &#125; &#125; printf("%d\n",ans); return 0;&#125; T2:ç»™ä½ ä¸€ä¸ªæ•°åˆ—$A$,å°†è¿™ä¸ª$A$ä¸æ–­$copy k$æ¬¡å˜æˆæ•°åˆ—$B$.æœ€åŽè®©ä½ æ±‚å‡ºæ•°åˆ—$B$çš„é€†åºå¯¹ä¸ªæ•°.$k&lt;=10^9$ çœ‹åˆ°$k$é‚£ä¹ˆå¤§,è‚¯å®šå¯ä»¥$n^2$æš´åŠ›äº†å•Šqwq æˆ‘ä»¬è€ƒè™‘è¿™kç»„ä¸­çš„æ¯ä¸€ç»„.å¦‚æžœæˆ‘ä»¬è€ƒè™‘åŽŸæ•°åˆ—$A$ä¸­çš„æ¯ä¸€ä½$A_i$,å¦‚æžœå‡ºçŽ°äº†ä¸€ä¸ª$A_j&lt;A_i$,é‚£ä¹ˆåœ¨ä»Žç¬¬$2$ç»„å¼€å§‹,åˆ°ç¬¬$k$ç»„,è¿™äº›æ¯”$A_i$å°çš„æ•°éƒ½ä¼šå¯¹$A_i$æœ‰è´¡çŒ®,è€Œä¸”ç¬¬$3$ç»„åˆ°ç¬¬$k$ç»„ä¹Ÿä¼šå¯¹ç¬¬$2$ç»„æœ‰è´¡çŒ®,è¿™æ ·ä¸€ç›´é€’æŽ¨ä¸‹åŽ»,ä¼šå‘çŽ°æœ‰$1+(k-1)*(k-1)/2$æ¬¡è´¡çŒ®,è€Œä¸”æœ€åŽä¸è¦å¿˜äº†ä¸€ç»„ä¸­å¯¹è‡ªå·±çš„è´¡çŒ®. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=2004;const int HA=1e9+7;int n,k,ans;int num[N],dd[N];inline int ksm(int x,int y)&#123; int tmp=1; while(y)&#123; if(y&amp;1) tmp=(tmp*x)%HA; x=(x*x)%HA; y&gt;&gt;=1; &#125; return tmp%HA;&#125;signed main()&#123; scanf("%lld%lld",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;num[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; if(num[j]&lt;num[i]) dd[i]++; &#125; for(int i=1;i&lt;=n;i++)&#123; ans=(ans+k*(k-1)%HA*ksm(2,HA-2)%HA*dd[i]%HA)%HA; int tdp = 0; for(int j=i+1;j&lt;=n;j++) if(num[j]&lt;num[i]) tdp++; ans = ( ans + tdp * k ) % HA; &#125; printf("%lld\n",ans); return 0; &#125; T4:T3æˆ‘ä¸ä¼šæ¬¸qwq(æ‚è„¸) å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Atcoderé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round #573 (Div. 2)è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2F2019%2F09%2F11%2FRound-1%2F</url>
    <content type="text"><![CDATA[qwq A:æ²¡å•¥å¯è¯´çš„,ç›´æŽ¥æŒ‰ç…§$Mod 4$åˆ†ç±»ç„¶åŽè®¨è®ºå°±å¥½äº†. B:æ˜¾ç„¶å¯ä»¥å‘çŽ°ç­”æ¡ˆåªèƒ½æ˜¯0,1,2,3ä¸­çš„æŸä¸€ä¸ª,æˆ‘ä»¬åªéœ€è¦å°†è¯»å…¥è®°å½•ä¸‹æ¥,ç„¶åŽå¯¹äºŽæ¯ä¸€ç§èƒœåˆ©çš„æƒ…å†µåˆ†ç»„æžšä¸¾ä¸€ä¸‹,è®°å½•ä¸€ä¸ªæœ€å°çš„anså°±å¯ä»¥äº†. C:è€ƒè™‘æ¯ä¸€æ¬¡æ“ä½œä¸­,è¿™ä¸€é¡µçš„æœ€å³è¾¹èƒ½æ¶ˆé™¤å‡ ä¸ª.æˆ‘ä»¬å¯ä»¥è®¾æˆ‘ä»¬å·²ç»æ¶ˆé™¤äº†$sum$ä¸ªæ•°å­—,é‚£ä¹ˆå½“å‰çš„$m_i$åœ¨æ¶ˆé™¤ä¹‹åŽä¸­çš„ä¹¦ä¸­çš„ä½ç½®å°±æ˜¯$m_i-sum$,æˆ‘ä»¬å°±å¯ä»¥æŽ¨å¯¼å‡ºæ¥å½“å‰$m_i$çš„è¿™ä¸€é¡µçš„æœ€å³è¾¹çš„ä¸€ä¸ªæ•°å­—å°±æ˜¯$((m_i-sum)/k+1)*k$,æˆ‘ä»¬åªéœ€è¦å¼€ä¸€ä¸ªå…³äºŽiçš„æŒ‡é’ˆå°±å¯ä»¥äº†,æ—¶é—´å¤æ‚åº¦ä¸º$O(m)$. D:è€ƒè™‘å¿…èƒœæƒ…å†µ:åœ¨å¦å¤–ä¸€ä¸ªäººå¼€å§‹å–çš„æ—¶å€™æœ‰$2$ä¸ªæˆ–è€…ä»¥ä¸Šçš„é‡å¤ç»„.æˆ–è€…åœ¨æœ‰1ä¸ªé‡å¤ç»„æ—¶,å–å‡ºä¸€ä¸ªé‡å¤ç»„(å› ä¸ºä¸å–å°±ä¼šè¾“)ä¹‹åŽå›žå’Œå¦å¤–ä¸€ä¸ªå…ƒç´ å†ç»„æˆä¸€ä¸ªé‡å¤ç»„. æˆ‘ä»¬å†è€ƒè™‘å®Œè¿™ç§æƒ…å†µä¹‹åŽ,å¯ä»¥å‘çŽ°,æˆ‘ä»¬åœ¨å°†åŽŸæ¥çš„æ•°ç»„æŽ’åºä¹‹åŽ,å¦‚æžœä¸¤è¾¹éƒ½æŒ‰ç…§æœ€ä¼˜æ–¹å¼å–çŸ³å­,é‚£ä¹ˆæœ€åŽçš„(åœ¨å†³å®šèƒœè´Ÿä¹‹å‰),çŸ³å­çš„åºåˆ—ä¸€å®šæ˜¯$B_i=i-1$çš„è¿™æ ·çš„ä¸€ä¸ªç­‰å·®æ•°åˆ—.æ‰€ä»¥æˆ‘ä»¬éœ€è¦å¯¹åŽŸæ•°ç»„æŽ’åº,ç„¶åŽç»Ÿè®¡ä¸€ä¸ª$\sum_{i=1}^n A_i-(i-1)$,åˆ¤æ–­ä¸€ä¸‹è¿™ä¸ª$sum$çš„å¥‡å¶æ€§å°±å¯ä»¥äº†. PS:ä¸€å®šè¦å…ˆåˆ¤æ–­æœ‰æ²¡æœ‰ä¾‹å¤–çš„å¿…èƒœæƒ…å†µ(æˆ‘å°±æ˜¯è¿™ä¹ˆWAäº†4å‘qwqâ€¦.) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=1e5+10;int n,idxx;int num[N],dis[N];map&lt;int,bool&gt;mp;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; sort(num+1,num+1+n); int sum=0,dpp=0; for(int i=1;i&lt;=n;i++)&#123; if(num[i]==num[i-1]&amp;&amp;i&gt;=2)&#123; dpp++; dis[++idxx]=num[i]; &#125; sum+=num[i]-i+1; mp[num[i]]=1; &#125; if(n==1)&#123; if(sum&amp;1) cout&lt;&lt;"sjfnb"&lt;&lt;endl; else cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(dpp==1&amp;&amp;num[1]==0&amp;&amp;num[2]==0)&#123; cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(dpp==1&amp;&amp;n==2)&#123; cout&lt;&lt;"sjfnb"&lt;&lt;endl; return 0; &#125; if(dpp==1)&#123; if(mp[dis[1]-1]) cout&lt;&lt;"cslnb"&lt;&lt;endl; else &#123; if(!(sum&amp;1)) cout&lt;&lt;"cslnb"&lt;&lt;endl; else cout&lt;&lt;"sjfnb"&lt;&lt;endl; &#125; return 0; &#125; if(dpp&gt;=2)&#123; cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(!(sum&amp;1)) cout&lt;&lt;"cslnb"&lt;&lt;endl; else cout&lt;&lt;"sjfnb"&lt;&lt;endl; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round]]></title>
    <url>%2F2019%2F09%2F11%2FRound%2F</url>
    <content type="text"><![CDATA[qwq A:è¿™é“é¢˜èƒ½æƒ³åˆ°äºŒè¿›åˆ¶è½¬åè¿›åˆ¶ç„¶åŽåˆ¤æ–­æ»¡è¶³çš„ä¸ªæ•°ï¼Œä½†æ˜¯è½¬åè¿›åˆ¶èŒƒå›´å·²ç»è¶…è¿‡äº†$long long$ï¼Œç›´æŽ¥æ¨¡æ‹Ÿä¼šæº¢å‡ºå› ä¸ºæ»¡è¶³æ¡ä»¶æ•°å€¼çš„éƒ½æ˜¯4çš„æ¬¡å¹‚ï¼Œæ‰€ä»¥äºŒè¿›åˆ¶é¦–ä½1åŽè·Ÿçš„$2k$ä¸ª$0$å³ä¸º$4$çš„$k$æ¬¡å¹‚ç›´æŽ¥å¯¹$0$çš„ä¸ªæ•°åˆ†æžå³å¯ B:å¾ˆæ˜Žæ˜¾çš„ä¸€é“è´ªå¿ƒé¢˜ç›®,å½“æ±‚æœ€å°çš„$sum$æ—¶,æ˜¾ç„¶å½“$1$æœ€å¤šæ—¶,$sum$æœ€å°.å½“æ±‚$sum$æœ€å¤§æ—¶åŒç†.åˆå› ä¸ºå½“$a_i$æ˜¯ä¸€ä¸ªå¶æ•°æ—¶,$\frac{a_i}{2}$è‚¯å®šå­˜åœ¨,è€Œä¸”$a_i$çš„æœ€å°å€¼ä¸º1,æ‰€ä»¥æ˜¾ç„¶$a_i$çš„å€¼å°±åªèƒ½æ˜¯$2^j$. C:(ä¸ªäººæ„Ÿè§‰æ¯”$D$éš¾$QAQâ€¦$)è®©ä½ åœ¨ç»™å®šçš„åºåˆ—$P$ä¸­æ±‚ä¸€ä¸ªå­åºåˆ—,ä½¿å¾—åœ¨å›¾ä¸­æŒ‰ç…§è¯¥å­åºåˆ—è¿›è¡Œæœ€çŸ­è·¯å¾„ç§»åŠ¨æ—¶å¯ä»¥å®Œæ•´ç»è¿‡åŽŸåºåˆ—$P$.ä¹ä¸€çœ‹ä¸€ç‚¹æ€è·¯éƒ½æ²¡æœ‰.ä½†æ˜¯ä»”ç»†æ€è€ƒå¯ä»¥å‘çŽ°ä¸€ç‚¹ç‚¹æ€è·¯.æˆ‘ä»¬å¯ä»¥ä»Žé¢˜ç›®ä¸­ç»™å‡ºçš„èµ·ç‚¹(ä¹Ÿå°±æ˜¯ä¸€å·ç‚¹)å¼€å§‹è¿›è¡Œç§»åŠ¨,ç„¶åŽåœ¨åŽŸåºåˆ—$P$ä¸­å¦‚æžœéœ€è¦ç»è¿‡$P_{i}$å’Œ$P_{i+1}$,é‚£ä¹ˆæˆ‘ä»¬æ˜¾ç„¶å¯ä»¥å¾—åˆ°$P_i$ä¸Ž$P_{i+1}$ä¸€å®šæ˜¯ç›´æŽ¥ç›¸è¿žçš„(å› ä¸ºé¢˜ç›®ä¸­æ²¡æœ‰ç»™å‡ºæ— è§£çš„æƒ…å†µ).é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ‰©å±•ä¸€ä¸‹,å‡è®¾æˆ‘ä»¬çŽ°åœ¨åœ¨$P_j$å·ç‚¹,æˆ‘ä»¬è¦èµ°åˆ°$P_k$å·ç‚¹.é‚£ä¹ˆå¦‚æžœ$dis[P_j][P_k]==j-k$,é‚£ä¹ˆåœ¨æœ‰è§£çš„æƒ…å†µä¸‹,ä¸€å®šæ˜¯æœ‰$P_j$ç»è¿‡äº†æ‰€æœ‰çš„$j&lt;i&lt;k$çš„ç‚¹(å¯ä»¥è‡ªå·±ç”»ä¸ªå›¾è¯æ˜Žä¸€ä¸‹).åœ¨è¿™ç§æƒ…å†µä¸‹,æˆ‘ä»¬å°±å¯ä»¥é€‰æ‹©æ‰©å±•ç­”æ¡ˆäº†. (æ„Ÿè§‰è¿˜æ˜¯æ”¾ä¸€ä¸‹ä»£ç æ¯”è¾ƒå¥½qwq) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int oo = 0x3f3f3f3f;const int N = 105;const int M = 1e6 + 10;int n,m,idx;char mp[N][N];int G[N][N],point[M],ans[M];int qu[M&lt;&lt;1];int head=1,tai=0;int main()&#123; memset ( G , 0x3f3f3f3f , sizeof ( G ) ); scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%s" , mp[i] + 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= n ; j++ ) if ( mp[i][j] == '1' ) G[i][j] = 1; G[i][i] = 1; &#125; for ( int k = 1 ; k &lt;= n ; k++ ) for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) G[i][j] = min ( G[i][j] , G[i][k] + G[k][j] ); scanf("%d",&amp;m); for ( int i = 1 ; i &lt;= m ; i++ ) scanf ( "%d" , &amp;point[i] );// for(int i=1;i&lt;=n;i++)&#123;// for(int j=1;j&lt;=n;j++)// printf("%d " ,G[i][j]);// puts("");// &#125; int st=1,now=2; while(now&lt;=m)&#123; int diss=now-st; if(diss==G[point[st]][point[now]])&#123; if(head&lt;=tai) head++; qu[++tai]=now; now++; &#125; else &#123; ans[++idx]=point[st]; if(head&lt;=tai) st=qu[head++]; &#125; &#125; ans[++idx]=point[st]; if(ans[idx]!=point[m]) ans[++idx]=point[m]; printf("%d\n",idx); for(int i=1;i&lt;=idx;i++) printf ("%d ",ans[i]); return 0;&#125; D:æ„Ÿè§‰æ¯”$C$ç®€å•å•Š$QAQ$â€¦.è®©ä½ æ±‚ä¸€ä¸ªå­—ç¬¦ä¸²ä½¿å¾—è¿™ä¸ªå­—ç¬¦ä¸²å’Œç»™å®š01å­—ç¬¦ä¸²çš„æ¯ä¸€ä¸ªå­åŒºé—´çš„æœ€é•¿å•è°ƒä¸é™åŒºé—´é•¿åº¦ä¸€æ ·é•¿.æˆ‘ä»¬è‡ªå·±ç†è§£äº†ä»¥åŽå¯ä»¥å‘çŽ°,ä¸€ä¸ªåŒºé—´çš„æœ€é•¿å•è°ƒä¸é™åŒºé—´é•¿åº¦åªæ˜¯å’Œæ¯ä¸€ä¸ª$1$åŽçš„$0$æœ‰å…³ç³»,è€Œå’Œ$0$åŽçš„$1$æ— å…³.(å› ä¸ºå¯¹äºŽä¸¤ä¸ªå­ä¸²$11$å’Œ$01$,å®ƒä»¬çš„æœ€é•¿ä¸é™åŒºé—´æ˜¯ä¸€æ ·çš„).é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥è€ƒè™‘æŠŠåŽŸå­—ç¬¦ä¸²çš„ä¸€äº›$1$å˜æˆ$0$.å°±å¯ä»¥äº†. ä½†æ˜¯æ€Žä¹ˆæ”¹å˜å‘¢?æˆ‘ä»¬è€ƒè™‘åˆ°,å¯¹äºŽæŸä¸€æ®µè¿žç»­çš„$1$,é‚£ä¹ˆè¿™æ®µè¿žç»­åŒºé—´ä¸­çš„ç¬¬ä¸€ä¸ª1å¾ˆæ˜¾ç„¶æ˜¯ä¸å¿…è¦çš„(è€Œä¸”ä¸æ˜¯æœ€åŽä¸€ä¸ª1),é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æŠŠè¿™äº›ä¸ª1å˜æˆ0.(ç„¶åŽå°±åšå®Œè¾£qwq) 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int tmpp;char ss[N] , tt[N];int main()&#123; scanf ( "%s" , ss + 1 ); int len = strlen ( ss + 1 ); for ( int i = 1 ; i &lt;= len ; i++ ) tt[i] = ss[i]; for ( int i = len ; i &gt;= 1 ; i-- ) &#123; if ( ss[i] == '1' &amp;&amp; tmpp &gt;= 0 ) tt[i] = '0'; int cur=ss[i] == '1' ? 1 : -1; tmpp = min ( tmpp + cur , cur ); &#125; for ( int i = 1 ; i &lt;= len ; i++ ) printf ( "%c" , tt[i] ); return 0;&#125;// E:çŽ°åœ¨è¿˜ä¸ä¼šqwq å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForcesé¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190819æ¨¡æ‹Ÿèµ›é¢˜è§£]]></title>
    <url>%2F2019%2F09%2F11%2F20190819%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[qwq åˆæ˜¯çˆ†é›¶çš„ä¸€æ¬¡æ¯”èµ›æ¬¸qwqâ€¦ T1: è®©ä½ åœ¨ä¸€ä¸ªçŸ©é˜µä¸­,æ‰¾å‡ºä¸€æ¡è·¯å¾„,ä½¿å¾—ç»è¿‡çš„è·¯å¾„æ–¹å·®æœ€å°. æˆ‘å°±ç›´æŽ¥æ”¾é¢˜è§£äº†qwqâ€¦ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;template &lt;class T&gt;bool Reduce(T &amp;a,T const &amp;b)&#123; return a&gt;b?a=b,1:0;&#125;const int N=31,inf=1e9+7,S=59*30;int n,m,ans;int a[N][N];int f[N][N];int cnt=0;void init()&#123; std::ios::sync_with_stdio(false); freopen("path.in","r",stdin); freopen("path.out","w",stdout); std::cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) std::cin&gt;&gt;a[i][j];&#125;int calc(const int &amp;sum,const int &amp;i,const int &amp;j)&#123; return (n+m-1)*a[i][j]*a[i][j]-2*sum*a[i][j];&#125;int dp(int sum)&#123; for(int i=0;i&lt;N;++i) for(int j=0;j&lt;N;++j) f[i][j]=inf; f[1][1]=calc(sum,1,1); for(int j=2;j&lt;=m;++j) Reduce(f[1][j],f[1][j-1]+calc(sum,1,j)); for(int i=2;i&lt;=n;++i) Reduce(f[i][1],f[i-1][1]+calc(sum,i,1)); for(int i=2;i&lt;=n;++i) for(int j=2;j&lt;=m;++j)&#123; Reduce(f[i][j],f[i-1][j]+calc(sum,i,j)); Reduce(f[i][j],f[i][j-1]+calc(sum,i,j)); &#125; return sum*sum+f[n][m];&#125;int main()&#123; init(); ans=inf; for(int sum=1;sum&lt;=S;++sum) Reduce(ans,dp(sum)); std::cout&lt;&lt;ans; return 0;&#125; T2:è®©ä½ æ¯æ¬¡ä»Žä¸€ä¸ªåŒºé—´å‘å¦ä¸€ä¸ªåŒºé—´è¿žè¾¹,æœ€åŽæ±‚èµ·ç‚¹åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯. å¾ˆæ˜¾ç„¶æ˜¯çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾,å¼€ä¸¤é¢—çº¿æ®µæ ‘A,B,ç¬¬ä¸€é¢—çº¿æ®µæ ‘ä»Žå„¿å­èŠ‚ç‚¹å‘çˆ¶äº²è¿žè¾¹,å¦å¤–ä¸€æ¡çº¿æ®µæ ‘ä»Žçˆ¶äº²å‘å„¿å­è¿žè¾¹.ä½†æ˜¯ä¸€ä¸ªç‚¹ä¸€ä¸ªç‚¹çš„å‘åŒºé—´è¿žè¾¹å¤ªéº»çƒ¦äº†,æ‰€ä»¥æˆ‘ä»¬éœ€è¦å»ºä¸€ä¸ªè™šç‚¹,æ¯æ¬¡ä»ŽåŒºé—´[l1,r1]å‘ä¸€ä¸ªè™šç‚¹è¿žè¾¹,ç„¶åŽå†ç”¨è¿™ä¸ªè™šç‚¹å‘åŒºé—´[l2,r2]è¿žè¾¹,è¿™æ ·å°±å¯ä»¥äº†. (ä½†æ˜¯æˆ‘è¢«å¡å¸¸äº†) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; const int N = 500010;const int M = 2210000;int n , m , p , tot , cnt , root_f , root_s;struct edge&#123; int to; int next; int date;&#125;e[11000000];struct Node&#123; int lc; int rc;&#125;tree[N&lt;&lt;2];int head[M] , dis[M] , pos[N];bool vis[M];std :: priority_queue &lt; std :: pair &lt; int , int &gt; , std :: vector &lt; std :: pair &lt; int , int &gt; &gt; , std :: greater &lt; std :: pair &lt; int , int &gt; &gt; &gt; q; inline void add(int x,int y,int date)&#123; e[++cnt].to=y; e[cnt].next=head[x]; head[x]=cnt; e[cnt].date=date; return;&#125;void FBuild(int &amp;root,int l,int r)&#123; root=++tot; if ( l == r ) &#123; pos[l]=root; return; &#125; int mid=l+r&gt;&gt;1; FBuild(tree[root].lc,l,mid); FBuild(tree[root].rc,mid+1,r); add(tree[root].lc,root,0); add(tree[root].rc,root,0); return;&#125;void SBuild(int &amp;root,int l,int r)&#123; root=++tot; if(l==r)&#123; add(root,pos[l],0); return; &#125; int mid=l+r&gt;&gt;1; SBuild(tree[root].lc,l,mid); SBuild(tree[root].rc,mid+1,r); add(root,tree[root].lc,0); add(root,tree[root].rc,0); return;&#125;void FAdd(int root,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; add(root,tot,1); return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) FAdd(tree[root].lc,l,mid,x,y); if(y&gt;mid) FAdd(tree[root].rc,mid+1,r,x,y);&#125;void SAdd(int root,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; add(tot,root,1); return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) SAdd(tree[root].lc,l,mid,x,y); if(y&gt;mid) SAdd(tree[root].rc,mid+1,r,x,y); return;&#125;inline void Dijkstra()&#123; memset(dis,0x3f3f3f3f,sizeof(dis)); q.push(std :: make_pair(0,pos[p])); dis[pos[p]]=0; while(!q.empty())&#123; int x=q.top().second; q.pop(); if(vis[x]) continue; vis[x]=1; for(int i=head[x];i;i=e[i].next)&#123; int y=e[i].to; if(dis[x]+e[i].date&lt;dis[y])&#123; dis[y]=dis[x]+e[i].date; q.push(std ::make_pair(dis[y],y)); &#125; &#125; &#125; return;&#125;int main ( void ) &#123; freopen("road.in","r",stdin); freopen("road.out","w",stdout); n = read(); m = read(); p = read(); FBuild ( root_f , 1 , n ); SBuild ( root_s , 1 , n ); while ( m-- ) &#123; int x1 = read() , y1 = read() , x2 = read() , y2 = read(); tot++; FAdd(root_f,1,n,x1,y1); SAdd(root_s,1,n,x2,y2); tot++; FAdd(root_f,1,n,x2,y2); SAdd(root_s,1,n,x1,y1); &#125; Dijkstra(); for(int i=1;i&lt;=n;++i) printf("%d\n",dis[pos[i]]/2); return 0;&#125; T3:ç»™ä½ ä¸€ä¸ªçŸ©é˜µ,è®©ä½ æ±‚å‡ºè¿™ä¸ªçŸ©é˜µä¸­çš„ä¸€ä¸ªæœ€å¤§çš„å­çŸ©é˜µ,ä½¿å¾—è¿™ä¸ªå­çŸ©é˜µçš„æ¯ä¸€è¡Œå’Œæ¯ä¸€åˆ—éƒ½æ˜¯ç­‰å·®æ•°åˆ— æš‚æ—¶å’•å’•å’•ä¸€ä¼š,ä¸ä¼š å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ¨¡æ‹Ÿèµ›é¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é‚ªæ•™ç®—æ³•å­¦ä¹ å°ç»“]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%82%AA%E6%95%99%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[qwq äº‹å®žè¯æ˜Ž,é‚ªæ•™ç®—æ³•æ˜¯å¾ˆæœ‰ç”¨çš„qwq(ä»¥ä¸‹ææ–™å¤§å¤šæŠ„è¢­OI-wiki)qwq Part1:éšæœºå‡½æ•°:ä½†æ˜¯å¹¶æ‰¾ä¸åˆ°ä»€ä¹ˆéšæœºåŒ–å¥½é¢˜qwq,,,,,å…ˆPassäº†å†è¯´qwqâ€¦ Part2:çˆ¬å±±ç®—æ³•:ä¸ªäººç†è§£å°±æ˜¯ä¸€ä¸ªæ¯”è¾ƒè·³çš„è´ªå¿ƒ(çœŸçš„æ˜¯ä¸ªè´ªå¿ƒ)â€¦.ä¸€èˆ¬å¸¸ç”¨äºŽå•å³°å‡½æ•°çš„æ±‚è§£,ä½†æ˜¯å•å³°å‡½æ•°ä¸ºå•¥ä¸å†™ä¸‰åˆ†å‘¢? çˆ¬å±±ç®—æ³•çš„ä¸€èˆ¬æµç¨‹å…¶å®žå°±æ˜¯:é€‰å®šä¸€ä¸ªåˆå§‹ç­”æ¡ˆ,é€šè¿‡æŸç§æ–¹æ³•è®¡ç®—å‡ºå¦å¤–ä¸€ä¸ªç­”æ¡ˆ,if å¦ä¸€ä¸ªç­”æ¡ˆæ›´ä¼˜ then è½¬ç§»å¦åˆ™ä¸å˜, å¾ˆå½¢è±¡çš„å°±æ˜¯äº†çˆ¬å±±è¿™ç§ä¸œè¥¿. ä¾‹é¢˜ JSOI2008çƒå½¢ç©ºé—´äº§ç”Ÿå™¨ ç©ºé—´æ¨¡åž‹çš„çˆ¬å±±å°±æ˜¯å¾ˆæ­£å¸¸çš„æ¨¡æ¿äº†,ç›´æŽ¥ç»™ä»£ç äº†qwq 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10005;int n;double tot , f[1005][1005];double ans[N] , cans[N] , dis[N];inline void check () &#123; tot = 0; for ( int i = 1 ; i &lt;= n + 1 ; i++ ) &#123; cans[i] = 0; dis[i] = 0; for ( int j = 1 ; j &lt;= n ; j++ ) dis[i] += ( f[i][j] - ans[j] ) * ( f[i][j] - ans[j] ); dis[i] = sqrt ( dis[i] ); tot += dis[i]; &#125; tot /= ( n + 1 ); for ( int i = 1 ; i &lt;= n + 1 ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) cans[j] += ( dis[i] - tot ) * ( f[i][j] - ans[j] ) / tot; return;&#125;int main() &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n + 1 ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) &#123; scanf ( "%lf" , &amp;f[i][j] ); ans[j] += f[i][j]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) ans[i] /= ( n + 1 ); for ( double T = 10001 ; T &gt;= 0.0000001 ; T *= 0.99995 ) &#123; check (); for ( int j = 1 ; j &lt;= n ; j++ ) ans[j] += cans[j] * T; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%.3lf " , ans[i] ); return 0;&#125; Part3. æ¨¡æ‹Ÿé€€ç«ç†è§£äº†çˆ¬å±±ç®—æ³•äº†ä¹‹åŽ,å¯ä»¥å‘çŽ°çˆ¬å±±ç®—æ³•å­˜åœ¨çš„å¾ˆæ˜¾ç„¶çš„ä¸€ä¸ªå±€é™æ€§:åªèƒ½è´ªå¿ƒ,è€Œè¿™ç§åœ¨å¤„ç†ä¸€äº›å¤šå³°å‡½æ•°æ—¶å¾€å¾€ä¼šåªæ‰¾åˆ°å‡½æ•°çš„æŸä¸ªæžå¤§å€¼è€Œä¸æ˜¯æœ€å¤§å€¼.æ‰€ä»¥æˆ‘ä»¬å°±è¦å¼•å…¥æ¨¡æ‹Ÿé€€ç«è¿™ç§æ–¹æ³•.,é‚£ä¹ˆ$What is $æ¨¡æ‹Ÿé€€ç«å‘¢? (ä»¥ä¸‹å†…å®¹æ¥è‡ªWIKI) : 1234567æ¨¡æ‹Ÿé€€ç«æ¥è‡ªå†¶é‡‘å­¦çš„ä¸“æœ‰åè¯é€€ç«ã€‚é€€ç«æ˜¯å°†ææ–™åŠ çƒ­åŽå†ç»ç‰¹å®šé€ŸçŽ‡å†·å´ï¼Œç›®çš„æ˜¯å¢žå¤§æ™¶ç²’çš„ä½“ç§¯ï¼Œå¹¶ä¸”å‡å°‘æ™¶æ ¼ä¸­çš„ç¼ºé™·ã€‚ææ–™ä¸­çš„åŽŸå­åŽŸæ¥ä¼šåœç•™åœ¨ä½¿å†…èƒ½æœ‰å±€éƒ¨æœ€å°å€¼çš„ä½ç½®ï¼ŒåŠ çƒ­ä½¿èƒ½é‡å˜å¤§ï¼ŒåŽŸå­ä¼šç¦»å¼€åŽŸæ¥ä½ç½®ï¼Œè€Œéšæœºåœ¨å…¶ä»–ä½ç½®ä¸­ç§»åŠ¨ã€‚é€€ç«å†·å´æ—¶é€Ÿåº¦è¾ƒæ…¢ï¼Œä½¿å¾—åŽŸå­æœ‰è¾ƒå¤šå¯èƒ½å¯ä»¥æ‰¾åˆ°å†…èƒ½æ¯”åŽŸå…ˆæ›´ä½Žçš„ä½ç½®ã€‚æ¨¡æ‹Ÿé€€ç«çš„åŽŸç†ä¹Ÿå’Œé‡‘å±žé€€ç«çš„åŽŸç†è¿‘ä¼¼ï¼šæˆ‘ä»¬å°†çƒ­åŠ›å­¦çš„ç†è®ºå¥—ç”¨åˆ°ç»Ÿè®¡å­¦ä¸Šï¼Œå°†æœå¯»ç©ºé—´å†…æ¯ä¸€ç‚¹æƒ³åƒæˆç©ºæ°”å†…çš„åˆ†å­ï¼›åˆ†å­çš„èƒ½é‡ï¼Œå°±æ˜¯å®ƒæœ¬èº«çš„åŠ¨èƒ½ï¼›è€Œæœå¯»ç©ºé—´å†…çš„æ¯ä¸€ç‚¹ï¼Œä¹Ÿåƒç©ºæ°”åˆ†å­ä¸€æ ·å¸¦æœ‰â€œèƒ½é‡â€ï¼Œä»¥è¡¨ç¤ºè¯¥ç‚¹å¯¹å‘½é¢˜çš„åˆé€‚ç¨‹åº¦ã€‚ç®—æ³•å…ˆä»¥æœå¯»ç©ºé—´å†…ä¸€ä¸ªä»»æ„ç‚¹ä½œèµ·å§‹ï¼šæ¯ä¸€æ­¥å…ˆé€‰æ‹©ä¸€ä¸ªâ€œé‚»å±…â€ï¼Œç„¶åŽå†è®¡ç®—ä»ŽçŽ°æœ‰ä½ç½®åˆ°è¾¾â€œé‚»å±…â€çš„æ¦‚çŽ‡ã€‚å¯ä»¥è¯æ˜Žï¼Œæ¨¡æ‹Ÿé€€ç«ç®—æ³•æ‰€å¾—è§£ä¾æ¦‚çŽ‡æ”¶æ•›åˆ°å…¨å±€æœ€ä¼˜è§£ã€‚ å¬èµ·æ¥å¾ˆæ‡µé€¼æ˜¯ä¸æ˜¯qwq..æ²¡å…³ç³»,å…¶å®žå°±æ˜¯å¦‚æžœä½ é€šè¿‡çŽ°åœ¨çš„è¿™ä¸ªçŠ¶æ€,ä»¥æŸç§æ–¹å¼å¾—åˆ°äº†å¦å¤–ä¸€ä¸ªç­”æ¡ˆæ—¶,ä½ ä¸å†åƒçˆ¬å±±ç®—æ³•é‚£æ ·ç›´æŽ¥è½¬ç§»,è€Œå·²è¦åƒä¸‹å›¾: å‘ç”Ÿè½¬ç§»ä¹‹åŽ,éšç€æ¸©åº¦Tçš„ä¸æ–­é™ä½Ž,å¯ä»¥å‘çŽ°$\frac{-\Delta E}{T}$æ˜¯ä¸æ–­å‡å°çš„(å› ä¸ºåœ¨æ–°çŠ¶æ€æ›´åŠ£çš„æƒ…å†µä¸‹,$-\Delta E$ä¸€å®šä¸ºè´Ÿæ•°),é‚£ä¹ˆ$e^\frac{-\Delta E}{T}$ä¸€å®šä¹Ÿæ˜¯ä¸æ–­å‡å°çš„å¹¶ä¸”è¶‹å‘äºŽ0.å³æ¨¡æ‹Ÿé€€ç«ç®—æ³•åœ¨æ¸©åº¦è¾ƒä½Žæ—¶é€€åŒ–ä¸ºçˆ¬å±±ç®—æ³•.è¿™æ—¶åªèƒ½å¯»æ‰¾å½“å‰çš„å‡½æ•°æžå¤§å€¼,æ‰€ä»¥æ€Žä¹ˆè°ƒå‚ä½¿å¾—æ¸©åº¦$T$è¾ƒå¤§æ—¶è½¬ç§»åˆ°æ­£ç¡®çš„å³°å‡½æ•°åŒºé—´æ˜¯è§£å†³é—®é¢˜çš„å…³é”®(ä½†æ˜¯è¿˜æ˜¯åªèƒ½é è¿æ°”qwq) ä¸€èˆ¬æ¨¡æ‹Ÿé€€ç«çš„ä»£ç å¤§æ¦‚æ¡†æž¶å¦‚ä¸‹: 123456789101112inline void SA () &#123; for ( double T = StartTemplature ; T &gt;= EndTemplature ; T *= Coolingcoefficient ) &#123; Typename Newans = Getans();//æ­¤å¤„Getansä¸ºæŸä¸ªèŽ·å¾—æ–°ç­”æ¡ˆçš„å‡½æ•°. Typename delta = ans - Newans; if ( Newans &gt; ans ) //è¿™é‡Œå‡è®¾å½“å€¼å¤§æ—¶ç­”æ¡ˆæ›´ä¼˜ ans = Newans; else if ( exp ( -delta / T ) &lt; ( double ) rand () / RAND_MAX ) ans = Newans; &#125; return;&#125; å…¶å®žä¸ºäº†ä¿è¯ç­”æ¡ˆçš„æ­£ç¡®æ€§,ä¸€èˆ¬éƒ½ä¼šè·‘å¤šæ¬¡æ¨¡æ‹Ÿé€€ç«ä»Žè€Œå¢žåŠ æ±‚å¾—æœ€ä¼˜è§£çš„æ¦‚çŽ‡.(è°ƒå‚ä¹Ÿæ˜¯ä¸ªéžå¸¸ç—›è‹¦çš„è¿‡ç¨‹,å› ä¸ºæ¨¡æ‹Ÿé€€ç«æ¯”çˆ¬å±±ç®—æ³•æ›´ä¸ºçœ‹è„¸éšæœº,æ‰€ä»¥æ¯ä¸ªå‚æ•°çš„å°å·®åˆ«å¯èƒ½å¯¼è‡´ç­”æ¡ˆçš„å¤©å£¤ä¹‹åˆ«.) ä¾‹é¢˜ [TJOI2010]åˆ†é‡‘å¸ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt; #include &lt;ctime&gt;#define int long longconst int N = 1005;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int n , ans = 2147483647;int num[N];inline int get () &#123; int sum1 = 0 , sum2 = 0; for ( int i = 1 ; i &lt;= ( n + 1 ) / 2 ; i++ ) sum1 += num[i]; for ( int i = ( n + 1 ) / 2 + 1 ; i &lt;= n ; i++ ) sum2 += num[i]; return abs ( sum1 - sum2 );&#125;inline void SA () &#123; double T = 5000; while ( T &gt;= 1e-10 ) &#123; int l = rand () % n + 1 , r = rand () % n + 1; std :: swap ( num[l] , num[r] ); int sum = get (); if ( sum &lt; ans ) ans = sum; else if ( exp ( ( ans - sum ) / T ) &lt; (double(rand())/RAND_MAX) ) std :: swap ( num[l] , num[r] ); T *= 0.98; &#125; return;&#125;signed main ( void ) &#123; srand ( rand() ); int T = read (); while ( T-- ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) num[i] = read (); for ( int i = 1 ; i &lt;= 100 ; i++ ) SA (); printf ( "%lld\n" , ans ); ans = 2147483647; &#125; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å­¦ä¹ ç¬”è®°</tag>
        <tag>çŽ„å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Noip2018æ¸¸è®°]]></title>
    <url>%2F2018%2F11%2F17%2FNoip2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[çœŸæ²¡æƒ³åˆ°æˆ‘èƒ½æ´»ç€è‹Ÿåˆ°å†™æ¸¸è®°çš„ä¸€å¤©$qwq$ Day-1æœ€è¿‘å‡ å¤©æœ‰ç‚¹ç´¯ï¼Œæ—©ä¸Šå°±ä¸åŽ»å­¦æ ¡äº†ï¼ˆç„¶è€Œäº‹å®žè¯æ˜Žè¿™æ˜¯å¾ˆæ­£ç¡®çš„æŠ‰æ‹©ï¼‰ã€‚æ—©ä¸Šä¸€è§‰ç¡åˆ°äº†$8:20$ï¼Œæ—©ä¸Šèµ·æ¥æƒ³èµ·æ¥$wucstdio$å¤§ä½¬è¯´è¿‡ç«‹è¿‡çš„$flag$ä¸æ‹”åœ¨$Noip$ä¼šæŽ‰$rp$ç„¶åŽæ—©ç¡èµ·æ¥å°±å¼€å§‹è‚çŒªå›½æ€ï¼Œä¸€ç›´åˆ°$10:40$å·¦å³é‡æž„å®Œäº†ï¼ˆåŽ†æ—¶$3$å¤©ç»ˆäºŽå†™å®Œäº†ï¼‰ä¸‹åˆå›žåˆ°å­¦æ ¡ï¼Œå‘çŽ°æ—©ä¸Šæ˜¯ä¿¡å¿ƒé¼“åŠ±èµ›å¹¸å¥½æ²¡åŽ»23333ç„¶åŽä¸‹åˆ+æ™šä¸Šä¸€ç›´åœ¨å†™æ¨¡æ¿é¢˜ã€‚ï¼ˆé¡ºä¾¿å‡‘å‡ºæ¥äº†$AC520$ï¼‰ Day 0æ—©ä¸Šæ•™ç»ƒå±…ç„¶ç»™æˆ‘ä»¬è¯·å‡ä¸ç”¨æ—©æ¥äº†å“Ž$qwqâ€¦.$ä¸Šåˆå¼€å§‹èµ°ï¼Œä¸€å¼€å§‹çš„æ—¶å€™è¿˜æƒ³åœ¨è½¦ä¸ŠèƒŒä¸ªæ¿å­ä»€ä¹ˆçš„ç„¶åŽSCPçœŸå¥½çœ‹åˆé¢“äº†ä¼šçŸ¥ä¹Žç„¶åŽå°±å‘çŽ°åˆ°äº†$cyyz$äº† ä½å®¿å®‰æŽ’å®Œæˆäº†ä¹‹åŽå±…ç„¶æ‰$2:30$å¤šä¸€ç‚¹ï¼Œç„¶åŽåœ¨å®¿èˆé‡Œä¸çŸ¥é“è¯¥å¹²å•¥ã€‚ä¸è¿‡æ„Ÿè§‰$cyyz$çš„ç§»åŠ¨ä¿¡å·è²Œä¼¼æ¯”$SDSC$çš„æ—¶å€™å¿«äº†ä¸€ç‚¹ï¼ˆå¤§é›¾ï¼‰ç„¶åŽ$wucstdio$ç»™æˆ‘æ‰“ç”µè¯è¯´æ¥¼ä¸‹æœ‰å¾ˆå¤šå¤§ä½¬ï¼Œè‡ªå·±è¿…é€Ÿä¸‹æ¥¼åŽ»è†œç¥žä»™ã€‚ ç»ˆäºŽè§åˆ°äº†$rqy$å§å§æœ¬äººäº†å¥½å…´å¥‹$qwq$ï¼Œä¸è¿‡$rqy$å§å§å¥½åƒæ¯”è‡ªå·±æƒ³çš„ç¨å¾®å†…æ•›äº†ä¸€ç‚¹ã€‚ ä½†æ˜¯è¿™å¹¶æ”¹å˜ä¸äº†rqyå§å§æ˜¯äººèµ¢çš„æ€§è´¨æ®è¯´çœ‹è§ç¥žä»™å¯ä»¥rp++,ï¼ˆä½†æ˜¯rpè²Œä¼¼è¢«rqyå§å§å¸èµ°äº†QAQ) æ™šä¸Šå…¨å®¿èˆéƒ½åœ¨æ‰“æ¿å­ï¼Œä½†æ˜¯è¯•æœºçš„æ—¶å€™$wyxdrqc$å’Œ$zyp$å¤§ä½¬è¿˜æœ‰å¾ˆå¤šäººï¼ˆåŒ…æ‹¬æˆ‘ï¼‰è¯•æœºçš„æ—¶å€™çº¿æ®µæ ‘éƒ½æ‰“é”™äº†ï¼ˆå¤§é›¾ï¼‰ã€‚ç»™è‡ªå·±å–œæ¬¢çš„äººæ‰“äº†ä¸ªç”µè¯ï¼ŒåŠ æ²¹qaqâ€¦ Day 1æ—©ä¸Šèµ·æ¥ï¼Œè‡ªå·±å†·é™äº†ä¸€ä¸‹ï¼Œæ‰“å¼€é¢˜ç›®ä¸€çœ‹$T1$ï¼Œå“Žæˆ‘ä¸ºä»€ä¹ˆ$T1$åªä¼š$70$åˆ†å•Šâ€¦.ï¼Œç„¶åŽè‡ªå·±åˆæŽ¨äº†1hè¿˜æ˜¯æ²¡æœ‰æŽ¨å‡ºæ¥ï¼Œå¿ƒæ€å½“åœºçˆ†ç‚¸qwqâ€¦T2å½“æˆæ•°è®ºæŽ¨äº†åŠå¤©ï¼Œç„¶åŽè‡ªå·±å†·é™çš„å†™äº†ä¸€ä¸ªä¹±æžåšæ³•ï¼Œä¹Ÿä¸çŸ¥é“èƒ½å¾—å¤šå°‘åˆ†ã€‚T3å®Œå…¨ä¸ä¼šï¼Œæ‰“ä¸€ä¸ªç›´å¾„åˆ†æ»šç²—äº†ã€‚ å‡ºè€ƒåœºï¼šå•Šä½ ä»¬æ€Žä¹ˆéƒ½åšè¿‡åŽŸé¢˜å—ï¼Ÿå•ŠT2æ˜¯ä¸ªè£¸èƒŒåŒ…å—ï¼Ÿå•ŠT3ä½ ä»¬éƒ½ä¼šå†™70åˆ†å—ï¼Ÿå¿ƒæ€å´©äº†æˆ‘è¦å¦¹å­QWQâ€¦.. ä¸‹åˆå¿ƒæ€ä¸€ç›´REä¸­ï¼Œåœ¨å®¿èˆé‡Œé¢“äº†ä¸€ä¸‹åˆã€‚ä¸ç®¡æ€Žä¹ˆè¯´ç¬¬äºŒå¤©éƒ½æƒ³ç¿»ç›˜ã€‚ Day 2ç¬¬äºŒå¤©ç¡äº†ä¸€è§‰ï¼Œå‘çŽ°å¿ƒæƒ…ç¨å¾®å¥½äº†ä¸€ç‚¹ã€‚åˆ°äº†è€ƒåœºä¹‹åŽï¼Œçœ‹åˆ°ç¬¬ä¸€é¢˜$m=n$æˆ‘å°±æ„Ÿè§‰è¯ä¸¸â€¦. ä¸ºä»€ä¹ˆ$Noip$çš„$T1$è¦è€ƒåŸºçŽ¯æ ‘å•Šâ€¦.. å†™äº†ä¸ª$60$åˆ†çš„æ ‘ä¸Šè´ªå¿ƒï¼Œç„¶åŽå¼€å§‹æƒ³çŽ¯ä¸Šæ€Žä¹ˆåšã€‚ç„¶è€Œæˆ‘å¾ˆ$zz$çš„æ²¡æœ‰çœ‹æ•°æ®èŒƒå›´å¯ä»¥$n^2$è¿‡ï¼Œä¸€ç›´åœ¨å†™$O(n)$çš„åšæ³•ã€‚ç„¶åŽæˆ‘å°±å†™æŒ‚äº†ï¼Œè‡ªå·±è¡¥äº†åªæœ‰çŽ¯çš„åšæ³•ï¼Œ$72åˆ†æ»šäº†$ã€‚ T2çœ‹çš„æ—¶å€™ï¼šå•Šï¼Ÿè¯»é¢˜è¯»äº†$10mins$ç¡®å®šæˆ‘ä¸ä¼šï¼Œç„¶åŽå°±å†³å®šæ‰“è¡¨äº†ã€‚ T3ï¼šâ€¦â€¦ä¸ºä»€ä¹ˆ$Noip$è¦è€ƒ$ddp$å•Šã€‚ã€‚ã€‚ã€‚ å‡ºäº†è€ƒåœºå‘çŽ°å¤§å®¶éƒ½è¯´D2ä¸ä¼šåšå½“æ—¶ç”šè‡³æœ‰äº›å¼€å¿ƒã€‚ ç„¶åŽæ™šä¸Šå°±å›žåŽ»ä¸Šæ™šè‡ªä¹ äº†ã€‚ ä¸€å¹´åŠçš„OIä¸€åœºç©ºï¼Œ$D1TI$è§ç¥–å®—è¯´æˆ‘æ˜¯å†é€‚åˆä¸è¿‡çš„äº†ã€‚æœ¬æ¥è¿˜ä»¥ä¸ºè‡ªå·±èƒ½åŽ»$PKUWC$,å¥½å§ï¼Œæˆ‘è¿˜æ˜¯å¤ª$naive$äº†ï¼Œæ„Ÿè§‰è‡ªå·±è¦ä¸Žçœä¸€æ“¦è‚©è€Œè¿‡â€¦.å‰©ä¸‹ä¸€å¹´è‡ªå·±å°±å…»ç”Ÿå¥½äº†ï¼Œå†æ¥ä¸€å¹´èµ·ç è¦æ‹¿ä¸€ä¸ª$1=$å•Š$qwqâ€¦..$ å›žå®¶ä¹‹åŽå¿ƒæ€ä¸€ç›´RE,,,,ä¸è¿‡å¹¸å¥½$wucstdio$å¤§ä½¬èƒ½å’Œæˆ‘è°ˆäº†è°ˆäººç”Ÿâ€¦.çž¬é—´æ„Ÿè§‰$wucstdio$æˆäº†æˆ‘çš„äººç”Ÿå¯¼å¸ˆqaqâ€¦. ä»¥åŽçš„è·¯è‡ªå·±å°±è¦è‡ªå·±å†³å®šäº†ï¼Œä¸è¿‡è‡ªå·±å†³å®šé‚£äº›æ¯”èµ›ä¹Ÿæ˜¯è¦ä¸€èµ·å‚åŠ çš„qaqâ€¦ é‚£äº›èƒ½è¿›å…¥çœé€‰çš„$OIer$ä»¬è¦åŠ æ²¹é¸­$qaqâ€¦$æˆ‘ä¼šä¸€ç›´é™ªç€ä½ ä»¬çš„$@wyxdrqc @wucstdio @lingyuqing$ ä½ ä»¬çš„$wqyzstql$ä¹Ÿè¦å’Œä½ ä»¬ä¸€èµ·åŠªåŠ›äº†ã€‚ å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>å¹æ°´</category>
      </categories>
      <tags>
        <tag>æ¸¸è®°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è€ƒå‰æ¨¡æ¿æ•´ç†]]></title>
    <url>%2F2018%2F11%2F07%2F%E8%80%83%E5%89%8D%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[$Noip$ä¹‹å‰åœ¨è¿™é‡Œæ•´ç†ä¸€æ³¢æ¨¡æ¿â€¦.é›†æˆäº†ä¸€ä¸‹æ‰€æœ‰çš„$TG$å’Œ$PJ$åº”è¯¥ä¼šè€ƒçš„æ¨¡æ¿ PS:æ‰€æœ‰æ¨¡æ¿çº¯å±žçŽ°åœºæ‰‹æ“ï¼Œä¸ä¿è¯æ­£ç¡®æ€§ï¼ˆæ¯”å¦‚æ‰‹æŠ–æ‰“é”™å­—æ¯ä»€ä¹ˆçš„ï¼‰ï¼Œå¦‚æžœæ‰¾åˆ°é”™è¯¯è¯·åŠæ—¶å‘ŠçŸ¥æˆ‘qwq å¿«é€ŸæŽ’åºæœ€åŸºæœ¬çš„æ¿å­äº†å§,$C++$é€‰æ‰‹è¡¨ç¤ºå¼€å¿ƒ$qaq$ã€‚1234567891011121314151617#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5 + 10int n;int num[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;num[i] ); sort ( num + 1 , num + 1 + n ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , num[i] , i == n ? '\n' : ' ' ); return 0;&#125; å¹¶æŸ¥é›†12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5 + 10;int n , m;int find ( int x ) &#123; if ( x != father[x] ) father[x] = find ( father[x] ); return father[x];&#125;int main ( void ) &#123; scanf ( "%d%d" , &amp;n , &amp;m ); for ( int i = 1 ; i &lt;= n ; i++ ) father[i] = i; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x , y , z; scanf ( "%d%d%d" , &amp;z , &amp;x , &amp;y ); if ( z == 1 ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; &#125; else if ( z == 2 ) &#123; x = find ( x ) , y = find ( y ); if ( x == y ) puts ( "Y" ); else puts ( "N" ); &#125; &#125; return 0;&#125; å¿«é€Ÿå¹‚ä¸ªäººæ„Ÿè§‰è¿™ä¸ªè¿˜æ˜¯ä¸ªæŒºé‡è¦çš„æ¿å­äº†å§â€¦..12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int Fast_Power ( int x , int y ) &#123; int sum = 1; while ( y ) &#123; if ( y &amp; 1 ) sum = sum * x; x = x * x; y &gt;&gt;= 1; &#125; return sum;&#125;int main ( void ) &#123; int n , m; scanf ( "%d%d" , &amp;n , &amp;m ); printf ( "%d\n" , Fast_Power ( n , m ) ); return 0;&#125; çº¿æ€§ç­›ç´ æ•°è¿™ä¸ªå…¶å®žåªæ˜¯ç­›ç´ æ•°çš„è¯æ˜¯æŒºç®€å•çš„ï¼Œä½†æ˜¯æˆ‘å†³å®šè¿ž$\phi$ä¸€èµ·ç­›å‡ºæ¥ï¼ˆå¦‚æžœç”¨ä¸åˆ°çš„è¯å°±æŠŠ$phi$æ•°ç»„è‡ªåŠ¨å¿½ç•¥æŽ‰å°±å¥½äº†ï¼‰12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 5e5 + 10;int n , cnt;int prime[N] , phi[N];bool flag[N];int main ( void ) &#123; flag[1] = 1; phi[1] = 1; scanf ( "%d" , &amp;n ); for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; flag[i] = 1; prime[++cnt] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; for ( int i = 1 ; i &lt;= cnt ; i++ ) printf ( "%d " , prime[i] ); puts ( "" ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d " , phi[i] ); return 0;&#125; ã€æ¨¡æ¿ã€‘å †åˆæ˜¯ä¸€ä¸ª$C++$å…šçš„ç¦åˆ©$qwq$,ç›´æŽ¥ç”¨$priority_queue$æ¨¡æ‹Ÿå°±å¥½å•¦123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using std :: priority_queue;int n;priority_queue &lt; int , std :: vector &lt; int &gt; , std :: greater &lt; int &gt; &gt; qu;int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int opts; scanf ( "%d" , &amp;opts ); if ( opts == 1 ) &#123; int x; scanf ( "%d" , &amp;x ); qu.push ( x ); &#125; else if ( opts == 2 ) printf ( "%d\n" , qu.top () ); else if ( opts == 3 ) qu.pop (); &#125; return 0;&#125; å­—ç¬¦ä¸²è›¤å¸Œå…¶å®žæˆ‘ä¸ªäººæ¯”è¾ƒå€¾å‘äºŽå†™è‡ªç„¶æº¢å‡ºæˆ–è€…ç›´æŽ¥éšæœºä¸€ä¸ªè´¨æ•°$qwq$12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;typedef unsigned long long ull;const ull base = 233;const int N = 1e4;const int M = 1e3;int n;char s[N][M];ull has[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%s" , s[i] + 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int len = strlen ( s[i] + 1 ); for ( int j = 1 ; j &lt;= len ; j++ ) has[i] = has[i] * base + s[i][j]; &#125; std :: sort ( has + 1 , has + 1 + n ); int ans = 0; for ( int i = 1 ; i &lt;= n ; i++ ) if ( has[i] != has[i + 1] ) ans++; printf ( "%d\n" , ans ); return 0;&#125; æœ€å°ç”Ÿæˆæ ‘ä¸ä¼šå†™$prim$çš„è’Ÿè’»ç‘Ÿç‘Ÿå‘æŠ–â€¦.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e4 + 10;const int M = 2e5 + 10;int n , m;struct Edge &#123; int from; int to; int data;&#125;e[M];int father[N];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline bool cmp ( Edge x , Edge y ) &#123; return x.data &lt; y.data;&#125;int find ( int x ) &#123; if ( x != father[x] ) father[x] = find ( father[x] ); return father[x];&#125;void Union ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; return;&#125;inline bool Judge ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); return ( x == y ) ? true : false;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) father[i] = i; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); e[i].from = x; e[i].to = y; e[i].data = z; &#125; std :: sort ( e + 1 , e + 1 + m , cmp ); int NowEdge = 0 , NowVal = 0; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int l = e[i].from , r = e[i].to; if ( Judge ( l ,r ) ) continue; Union ( l , r ); NowEdge++; NowVal += e[i].data; if ( NowEdge == n - 1 ) break; &#125; if ( NowEdge == n - 1 ) printf ( "%d\n" , NowVal ); else puts ( "orz" ); return 0;&#125; å•æºæœ€çŸ­è·¯ ï¼ˆæœ‰è´Ÿæƒè¾¹ï¼‰è¿™å¼ å›¾æœ‰è´Ÿæƒè¾¹ï¼Œæ‰€ä»¥åªèƒ½å†™æŸå·²ç»æ­»æŽ‰çš„$SPFA$äº†123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N = 1e4 + 10;const int M = 1e5 + 10;using std :: queue;int n , m , t;struct Edge &#123; int to; int data; int next;&#125;e[M];int head[N] , dis[N];bool inque[N];inline int read () &#123; int s = 0; bool flag = 0; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '0' ) flag = 1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return ( flag ) ? -s : s;&#125;void Spfa ( int x ) &#123; memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[x] = 1;dis[x] = 0; qu.push ( x ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].data ) &#123; dis[k] = dis[j] + e[i].data; if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; return;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); add ( x , y , z ); &#125; Spfa ( 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , dis[i] == 0x3f3f3f3f ? 2147483647 : dis[i] , i == n ? '\n' : ' ' ); return 0;&#125; å•æºæœ€çŸ­è·¯ ï¼ˆæ— è´Ÿæƒè¾¹ï¼‰åœ¨é¢˜ç›®æ˜Žç¡®è¯´æ²¡æœ‰è´Ÿæƒè¾¹çš„æƒ…å†µä¸‹ï¼Œè·‘å †ä¼˜åŒ–çš„$Dijkstra$ä¸€å®šæ˜¯æœ€ç¨³çš„å…¶å®žä»£ç é•¿å¾—éƒ½å·®ä¸å¤š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define F(i,a,b) for ( int i = a ; i &lt;= b ; i++ )#define MP std::make_pair#define se second#define fi firsttypedef std::pair &lt; int , int &gt; pll;const int N = 1e5 + 10; const int M = 4e5 + 20;std::priority_queue &lt; pll , std::vector &lt; pll &gt; , std::greater &lt; pll &gt; &gt; qu;int n , m , s , t;struct Edge &#123; int to; int data; int next;&#125;e[M];int head[N] , dis[N];bool inque[N];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void Heap_Dijkstra ( int x ) &#123; memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); dis[x] = 0; qu.push ( MP ( dis[x] , x ) ); while ( !qu.empty () ) &#123; int j = qu.top ().se; qu.pop (); if ( inque[j] ) continue; inque[j] = 1; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].data ) &#123; dis[k] = dis[j] + e[i].data; qu.push ( MP ( dis[k] , k ) ); &#125; &#125; &#125; return;&#125;int main ( void ) &#123; n = read (); m = read (); s = read (); F ( i , 1 , m ) &#123; int x = read () , y = read () , z = read (); add ( x , y , z ); &#125; Heap_Dijkstra ( s ); F ( i , 1 , n ) printf ( "%d " , dis[i] ); return 0;&#125; å°±å…ˆæ•´ç†è¿™äº›å§â€¦ç•™ä¸ªå‘ç­‰ç€å¡«â€¦. å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>å¹æ°´</category>
      </categories>
      <tags>
        <tag>å­¦ä¹ ç¬”è®°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2010] æ‰€é©¼é—¨çŽ‹çš„å®è—]]></title>
    <url>%2F2018%2F11%2F05%2Fi-t%2F</url>
    <content type="text"><![CDATA[ä¸€é“æ€ç»´éš¾åº¦å¾ˆç®€å•ï¼Œä»£ç å®žçŽ°éš¾åº¦éžå¸¸$mmp$çš„æ¯’ç˜¤é¢˜â€¦..(è¿™å¾ˆ$SDOIâ€¦..$) é¢˜ç›®è¿žæŽ¥ï¼šSDOI2010 æ‰€é©¼é—¨çŽ‹çš„å®è— å¥½ï¼Œæˆ‘ä»¬ç›´æŽ¥è·³è¿‡é¢˜ç›®èƒŒæ™¯ã€‚ ç„¶åŽæˆ‘ä»¬ä¼šå‘çŽ°ï¼Œå¦‚æžœè¿™é“é¢˜èƒ½æŠŠå›¾å»ºå‡ºæ¥ï¼Œé‚£ä¹ˆç›´æŽ¥ä¸€é$DAG$ä¸Š$DP$å°±è¿‡äº†ã€‚ è’½ï¼Œè¿™ä¸æ˜¯$sb$é¢˜å—ï¼Ÿ ç„¶åŽè®©æˆ‘ä»¬çœ‹æ•°æ®èŒƒå›´ï¼š$1&lt;=n&lt;=1000000$ ç¬‘å®¹é€æ¸æ¶ˆå¤± ä½†æ˜¯æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹ï¼Œæ—¢ç„¶æˆ‘ä»¬è¦å»ºä¸€å¼ $DAG$ã€‚é‚£ä¹ˆï¼Œæˆ‘ä»¬å®Œå…¨æ²¡æœ‰å¿…è¦å¯¹æ‰€æœ‰çš„ç‚¹è¿›è¡Œä¸¤ä¸¤è¿žè¾¹ã€‚æˆ‘ä»¬åªéœ€è¦å¯¹æ¯ä¸€è¡Œå’Œæ¯ä¸€åˆ—è¿›è¡Œè¿žè¾¹ï¼ŒæŠŠä»–ä»¬è¿žæˆä¸€ä¸ªçŽ¯ï¼Œè¿™æ ·çš„è¯ï¼Œå»ºè¾¹å¤æ‚åº¦å°±ä¼šä»Ž$O(n^2)$å˜æˆ$O(n)$äº†ã€‚ ç„¶åŽå¯¹äºŽè‡ªç”±é—¨çš„æƒ…å†µï¼Œå¯¹ä¸èµ·ï¼Œæˆ‘ä¸çŸ¥é“æ€Žä¹ˆä¼˜åŒ–ï¼Œæ‰€ä»¥æˆ‘å†³å®šæš´åŠ›å»ºè¾¹ã€‚ ï¼ˆåˆ†æžå¯ä»¥å‘çŽ°å³ä½¿å…¨æ˜¯è‡ªç”±é—¨ï¼Œä½ æš´åŠ›å»ºè¾¹ä¹Ÿä¸ä¼š$TLE$ï¼‰ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;map&gt;const int N = 1e6 + 10;const int M = 5e6 + 10;using std :: map;using std :: stack;int ans = -0x3f3f3f3f;int n , r , c , t;int dx[] = &#123; 0 , 0 , 1 , 1 , 1 , -1 , -1 , -1 &#125;;int dy[] = &#123; 1 , -1 , 1 , 0 , -1 , 1 , 0 , -1 &#125;;struct Node &#123; int x; int y; int opts; int id;&#125;p[N];struct Edge &#123; int from; int to; int next; &#125;e[M];int idx , Bcnt;int head[N] , dfn[N] , low[N];int Belong[N] , size[N] , f[N];int degree[N];bool instack[N];map &lt; std :: pair &lt; int , int &gt; , int &gt; mp;map &lt; std :: pair &lt; int , int &gt; , int &gt; mat;stack &lt; int &gt; st;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].from = x; e[t].next = head[x]; head[x] = t; return;&#125;bool cmp1 ( Node a , Node b ) &#123; if ( a.x != b.x ) return a.x &lt; b.x; if ( a.opts == 1 ) return 1; if ( b .opts == 1 ) return 0; return a.y &lt; b.y;&#125;bool cmp2 ( Node a , Node b ) &#123; if ( a.y != b.y ) return a.y &lt; b.y; if ( a.opts == 2 ) return 1; if ( b.opts == 2 ) return 0; return a.x &lt; b.x;&#125;void Tarjan ( int cur ) &#123; dfn[cur] = low[cur] = ++idx; instack[cur] = 1; st.push ( cur ); for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( !dfn[j] ) &#123; Tarjan ( j ); low[cur] = min ( low[cur] , low[j] ); &#125; else if ( instack[j] ) low[cur] = min ( low[cur] , dfn[j] ); &#125; int k; if ( low[cur] == dfn[cur] ) &#123; Bcnt++; do &#123; k = st.top ();; st.pop (); instack[k] = 0; Belong[k] = Bcnt; size[Bcnt]++; &#125; while ( k != cur ); &#125; return;&#125;void dfs ( int cur , int father ) &#123; if ( f[cur] &gt; size[cur] ) return; f[cur] = size[cur]; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == father ) continue; dfs ( j , cur ); f[cur] = max ( f[cur] , f[j] + size[cur] ); &#125; return;&#125;int main ( void ) &#123; n = read () , r = read () , c = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; p[i].x = read (); p[i].y = read (); p[i].opts = read (); p[i].id = i; mp[std::make_pair ( p[i].x , p[i].y )] = i; &#125; std :: sort ( p + 1 , p + n + 1 , cmp1 ); int first = 1 , last = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( p[i].x != p[i + 1].x ) &#123; if ( first != last ) add ( p[last].id , p[first].id ); last = first = i + 1; &#125; else &#123; if ( p[last].opts == 1 ) add ( p[last].id , p[i + 1].id ); if ( p[i + 1].opts == 1 ) last = i + 1; if ( p[first].opts != 1 ) last = first = i + 1; &#125; &#125; first = last = 1; std :: sort ( p + 1 , p + 1 + n , cmp2 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( p[i].y != p[i + 1].y ) &#123; if ( first != last ) add ( p[last].id , p[first].id ); last = first = i + 1; &#125; else &#123; if ( p[last].opts == 2 ) add ( p[last].id , p[i + 1].id ); if ( p[i + 1].opts == 2 ) last = i + 1; if ( p[first].opts != 2 ) last = first = i + 1; &#125; &#125; //printf ( "%d\n" , t ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( p[i].opts == 3 ) for ( int j = 0 ; j &lt; 8 ; j++ ) &#123; int xx = p[i].x + dx[j]; int yy = p[i].y + dy[j]; if ( mp[std :: pair &lt; int , int &gt; ( xx , yy )] ) add ( p[i].id , mp[std :: pair &lt; int , int &gt; ( xx , yy )] ); &#125; // printf ( "%d\n" , t ); // for ( int i = 1 ; i &lt;= t ; i++ ) // printf ( "%d %d\n" , e[i].from , e[i].to ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( !Belong[i] ) Tarjan ( i ); for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = head[i] ; j ; j = e[j].next ) &#123; int k = e[j].to; if ( Belong[i] != Belong[k] ) mat[std :: make_pair ( Belong[i] , Belong[k] )] = 1; &#125; t = 0; memset ( head, 0 , sizeof ( head ) ); for ( auto it = mat.begin () ; it != mat.end() ; it++ ) &#123; add ( it -&gt; first.first , it -&gt; first.second ); degree[it -&gt; first.second]++; &#125; // for ( int i = 1 ; i &lt;= Bcnt ; i++ ) // printf ( "%d " , degree[i] ); for ( int i = 1 ; i &lt;= Bcnt ; i++ ) if ( degree[i] == 0 ) &#123; dfs ( i , 0 ); ans = max ( ans , f[i] ); &#125; printf ( "%d\n" , ans ); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å›¾è®º</tag>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qbxt D2T2 Code é¢˜è§£]]></title>
    <url>%2F2018%2F11%2F04%2F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[çœ‹äº†ä¸€çœ¼ä¹‹åŽå®Œå…¨å°±æ˜¯ä¸€è„¸æ‡µé€¼çš„é¢˜â€¦. é¦–å…ˆå…ˆè¯»é¢˜$qaq$â€¦..é¢˜ç›®çš„å¤§è‡´æ„æ€å°±æ˜¯ç»™ä½ ä¸€ä¸ªçŸ©é˜µï¼Œç„¶åŽé—®ä½ æŠŠè¿™ä¸ªçŸ©é˜µæ¨ªç«–å¡«æˆå¼‚æˆ–å€¼ä¸º$1$çš„çŸ©é˜µçš„æ–¹æ¡ˆæ•°ã€‚ å¾ˆæ˜Žæ˜¾ï¼Œè¿™é“é¢˜æ²¡æœ‰ä»€ä¹ˆæžšä¸¾ä¸Šç•Œï¼Œæ‰€ä»¥ä½ æƒ³ç›´æŽ¥æžšä¸¾çš„è¯æ˜¯ä¸å¤ªå¯èƒ½çš„ã€‚é‚£ä¹ˆæˆ‘ä»¬æ€Žä¹ˆåŠžå‘¢$?$ æˆ‘ä¹Ÿä¸çŸ¥é“ æ—¢ç„¶æžšä¸¾è¡¥æ˜Ÿï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ç”¨ä¸€ä¸ªæ¯”è¾ƒå¸¸è§çš„æ­£éš¾åˆ™åçš„æ€æƒ³ã€‚å¯¹äºŽè¿™é“é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥å®¹æ–¥çš„åŽ»åš é‚£ä¹ˆï¼Œé¦–å…ˆï¼Œæ‰€æœ‰çš„æ–¹æ¡ˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ All = 2^{n*m}ä¸ºä»€ä¹ˆå‘¢ï¼Ÿä¸€å…±æœ‰n+mä¸ªæ ¡éªŒç ï¼Œæˆ‘ä»¬æŒ‰ä½æ•°è€ƒè™‘ï¼Œåœ¨åªæœ‰1ä½çš„æƒ…å†µä¸‹ï¼Œé‚£ä¹ˆè¿™ä¸€ä½å¯èƒ½æ˜¯$0$æˆ–è€…$1$ã€‚é‚£ä¹ˆå°±æ˜¯$(2^n)^m$çš„æ–¹æ¡ˆæ•°äº†ã€‚ ç„¶åŽæˆ‘ä»¬è€ƒè™‘å¯¹äºŽæ¯ä¸€ä½åˆ æŽ‰ä¸åˆæ³•çš„æƒ…å†µï¼šå› ä¸ºå¼‚æˆ–èµ·æ¥æ˜¯$1$ï¼Œé‚£ä¹ˆå¯¹äºŽæ²¡ä¸€è¡Œæˆ–è€…æ¯ä¸€åˆ—ï¼Œ$1$çš„ä¸ªæ•°æ€»æ˜¯å¥‡æ•°ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥æ ¹æ®è¿™ä¸ªä¸œè¥¿æ¥è¿›è¡Œåˆ é™¤ä¸åˆæ³•çŠ¶æ€çš„æ“ä½œäº† æœ€åŽç»Ÿè®¡å‡ºæ¥ç­”æ¡ˆ æˆ‘ä»¬å‘çŽ°ï¼Œå› ä¸ºæœ‰$k$ä½ï¼Œè€Œæˆ‘ä»¬æ˜¯æŒ‰ä½è€ƒè™‘çš„ã€‚æ‰€ä»¥æˆ‘ä»¬æœ€åŽè¦å–ç­”æ¡ˆçš„$k$æ¬¡æ–¹ã€‚ ä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define int long longconst int N = 505;const int MOD = 1e9 + 7;int c[N][N];int n , m , k , t , ans;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int Fast_Power ( int x , int y ) &#123; int sum = 1; while ( y ) &#123; if ( y &amp; 1 ) sum = sum * x % MOD; x = x * x % MOD; y &gt;&gt;= 1; &#125; return sum;&#125;signed main() &#123; for ( int i = 1 ; i &lt;= 500 ; i++ ) c[i][i] = c[i][0]=1; for ( int i = 2 ; i &lt;= 500 ; i++ ) for ( int j = 1 ; j &lt; i ; j++ ) c[i][j] = ( c[i - 1][j] + c[i - 1][j - 1] ) %MOD; t = read(); while ( t-- ) &#123; n = read () , m = read() , k = read (); int ans = Fast_Power ( 2 , n * m ); for ( int i = 0 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) &#123; if ( i == 0 &amp;&amp; j == 0 ) continue; if ( ( i + j ) &amp; 1 ) ans = ( ans + MOD - Fast_Power ( 2 , ( n - i ) * ( m - j ) ) * c[n][i] % MOD * c[m][j] % MOD ) % MOD; else ans = ( ans + Fast_Power ( 2 , ( n - i ) * ( m - j ) ) * c[n][i] % MOD * c[m][j] % MOD ) % MOD; &#125; ans = Fast_Power ( ans , k ); printf ( "%lld\n" , ans ); &#125; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ€ç»´</tag>
        <tag>æ•°å­¦</tag>
        <tag>å®¹æ–¥åŽŸç†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[é¢˜è§£] Noip2016D1T3 æ¢æ•™å®¤]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%8D%A2%E6%95%99%E5%AE%A4%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ä¸€é“è¢«å¤©å¤©çˆ±è·‘æ­¥æŠ¢å°½äº†é£Žå¤´çš„æœ€æ²¡æœ‰æŽ’é¢çš„$T3â€¦..$è¯´å®žè¯ï¼Œè¿™é“é¢˜æˆ‘åˆšå¼€å§‹æ˜¯ä¸ä¼šçš„ï¼Œç„¶åŽæˆ‘çœ‹äº†L_Y_Tå¤§çˆ·çš„$Blog$ä¹‹åŽæ‰æç„¶å¤§æ‚Ÿï¼ˆ$Blog$å†™çš„å¾ˆå¥½ï¼Œèµžä¸€ä¸ªï¼‰å…ˆå®‰åˆ©å®Œ$Blog$å†è¯´L_Y_Tå¤§çˆ·çš„Blog çœ‹äº†$Blog$ä¹‹åŽ,çªç„¶å‘çŽ°ï¼Œè¿™ä¸œè¥¿è¦æ±‚çš„æ¦‚çŽ‡çŸ¥è¯†ç‚¹æˆ‘éƒ½æ˜¯ä¼šçš„ï¼Œåªæ˜¯DPå¼å­æƒ³ä¸å‡ºæ¥è€Œå·²$qaqâ€¦$(æˆ‘å¥½èœå•Š) å› ä¸ºé¢˜ç›®ä¸­è¯´ï¼Œæˆ‘ä»¬æœ€å¤šå¯ä»¥æ¢$m$æ¬¡ï¼Œè€Œé¢˜ç›®ä¸­è¯´çš„ä½ åªèƒ½åœ¨å¼€å§‹ä¹‹å‰é€‰æ‹©æ–¹æ¡ˆçš„è¯´æ³•å®Œå…¨æ²¡ç”¨ï¼Œæ¯•ç«Ÿè°ä¼šçŸ¥é“ä½ æ˜¯é¢„æµ‹äº†æœªæ¥å‘¢ï¼ˆé€ƒ ç„¶åŽï¼Œå› ä¸ºæœ‰$n$ä¸ªè¯¾ç¨‹ï¼Œæ‰€ä»¥æˆ‘ä»¬è®¾$f[i][j][0/1]$æ¥è¡¨ç¤ºç¬¬iä¸ªç‚¹,ç¬¬jæ¬¡æ¢,æ¢ä¸æ¢ ç„¶åŽæˆ‘ä»¬åˆ†æƒ…å†µæ¥è¡¨ç¤ºè½¬ç§»ï¼šæ¯ä¸ªæ•™å®¤åˆ†ä¸ºä¸¤ç§æƒ…å†µ 1.æ¢2.ä¸æ¢è¿™ä¸ªæ˜¯æŒºå¹³å¸¸çš„ç„¶åŽå¤æ‚åœ¨æ¢ä¸Žä¸æ¢çš„åˆ†æƒ…å†µä¸Šäº†~~~ä¸æ¢:ä¸æ¢æ˜¯åˆ†ä¸ºè¿™æ ·å‡ ç§æƒ…å†µ:ä¸Šä¸€ä¸ªä¹Ÿä¸æ¢ , ä¸Šä¸€ä¸ªæ¢ ä¸”æˆåŠŸ,ä¸Šä¸€ä¸ªæ¢ä½†å¤±è´¥åŒç†,æ¢ä¹Ÿæœ‰å¥½å¤šç§æƒ…å†µ:ä¸Šä¸€ä¸ªç‚¹ä¸æ¢,è¿™ä¸ªç‚¹å¤±è´¥ä¸Šä¸€ä¸ªç‚¹ä¸æ¢,è¿™ä¸ªç‚¹æˆåŠŸä¸Šä¸€ä¸ªç‚¹æ¢æˆåŠŸ,è¿™ä¸ªç‚¹æˆåŠŸä¸Šä¸€ä¸ªç‚¹æ¢æˆåŠŸ,è¿™ä¸ªç‚¹å¤±è´¥ä¸Šä¸€ä¸ªç‚¹æ¢å¤±è´¥,è¿™ä¸ªç‚¹æˆåŠŸä¸Šä¸€ä¸ªç‚¹æ¢å¤±è´¥,è¿™ä¸ªç‚¹ä¹Ÿå¤±è´¥ ç„¶åŽæ–¹ç¨‹å¥½å¤æ‚çš„ï¼Œæ˜¯ï¼š1234567891011121314151617181920212223242526 ä¸Šä¸€ç‚¹ä¸æ¢:f[i-1][j-1][0]è¿™ä¸€ç‚¹æ¢1.å¤±è´¥æ¶ˆè€—ä½“åŠ›: dis[c[i-1]][c[i]] åˆ†æž: ç”±äºŽä¸Šä¸€ä¸ªç‚¹ä¸æ¢,æ‰€ä»¥ä¸Šä¸€ä¸ªç‚¹ä¸€å®šæ˜¯åœ¨c[]ä¸­çš„;å‡å®šè¿™æ¬¡å¤±è´¥,é‚£ä¹ˆè¿™æ¬¡ä¹Ÿåªèƒ½åŽ»c[]ä¸­çš„æ•™å®¤;2.æˆåŠŸæ¶ˆè€—ä½“åŠ›: dis[c[i-1]][d[i]]åˆ†æž: ç”±äºŽä¸Šä¸€ä¸ªç‚¹ä¸æ¢,æ‰€ä»¥ä¸Šä¸€ä¸ªç‚¹ä¸€å®šæ˜¯åœ¨c[]ä¸­çš„;å‡å®šè¿™æ¬¡æˆåŠŸ,é‚£ä¹ˆè¿™æ¬¡èƒ½åŽ»d[]ä¸­çš„æ•™å®¤;é‚£ä¹ˆ,å¤±è´¥çš„æ¦‚çŽ‡æ˜¯1-k[],æˆåŠŸçš„æ¦‚çŽ‡æ˜¯k[].ç»¼ä¸Š,è¿™ç§æƒ…å†µå°±æ˜¯:f[i-1][j-1][0]+dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1.0-k[i]) åŒç†,ä¸Šä¸€ç‚¹æ¢,è¿™ä¸€ç‚¹æ¢1.ä¸Šä¸€ç‚¹å¤±è´¥,è¿™ä¸€ç‚¹å¤±è´¥(ä»¥åŽçœä¸€ç‚¹å“ˆ)æ¶ˆè€—ä½“åŠ›: dis[c[i-1]][c[i]]æ¦‚çŽ‡:éƒ½å¤±è´¥è¿™è¿æ°”ä¹Ÿæ²¡è°äº†!!!! æ¦‚çŽ‡:(1.0-k[i-1])*(1.0-k[i])2.å¤±è´¥,æˆåŠŸæ¶ˆè€—ä½“åŠ›: dis[c[i-1]][d[i]]æ¦‚çŽ‡ : (1.0-k[i-1])*k[i]3.æˆåŠŸ,å¤±è´¥æ¶ˆè€—ä½“åŠ› : dis[d[i-1]][c[i]]æ¦‚çŽ‡: k[i-1]*(1.0-k[i])4.æˆåŠŸ,æˆåŠŸæ¶ˆè€—ä½“åŠ›: dis[d[i-1]][d[i]] æ¦‚çŽ‡: k[i-1]*k[i] ç„¶åŽå¯¹äºŽä¸æ¢çš„æ–¹ç¨‹ï¼š12f[i][j][0] = min(f[i-1][j][0]+dis[c[i-1]][c[i]],f[i-1][j][1]+dis[c[i-1]][c[i]]*(1.0-k[i-1])+dis[d[i-1]][c[i]]*k[i-1]) ; ä¹‹å‰éœ€è¦Floydé¢„å¤„ç†ä¸€ä¸‹ï¼Œç„¶åŽå°±å¥½å•¦(è¿™é“é¢˜çš„ç¡®æ¯”å¤©å¤©çˆ±è·‘æ­¥ç®€å•23333)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 2050;const int M = 350;int n , m , v , e;int c[N] , d[N] ;double G[M][M] , f[N][N][2];double k[N];template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;int main ( void ) &#123; scanf ( "%d%d%d%d" , &amp;n , &amp;m , &amp;v , &amp;e ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;c[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;d[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%lf" , &amp;k[i] ); for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) f[i][j][0] = f[i][j][1] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= v ; i++ ) G[i][i] = 0 ; for ( int i = 1 ; i &lt;= e ; i++ ) &#123; int x , y; double z; scanf ( "%d%d%lf" , &amp;x , &amp;y , &amp;z ); if ( G[x][y] &gt; z ) G[x][y] = G[y][x] = z; &#125; for ( int l = 1 ; l &lt;= v ; l++ ) for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = min ( G[i][j] , G[i][l] + G[l][j] ); f[1][0][0] = f[1][1][1] = 0.0000; for ( int i = 2 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= min ( i , m ) ; j++ ) &#123; f[i][j][0] = min ( f[i - 1][j][0] + G[c[i - 1]][c[i]] , f[i - 1][j][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1] ); if(j &gt;= 1) &#123; f[i][j][1] = min ( f[i - 1][j - 1][0] + G[c[i - 1]][d[i]] * k[i] + G[c[i - 1]][c[i]] * ( 1.0 - k[i] ) , f[i - 1][j - 1][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) * ( 1.0 - k[i] ) + G[c[i - 1]][d[i]] *k[i] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1]* ( 1.0 - k[i] ) + G[d[i - 1]][d[i]] * k[i - 1] * k[i] ); &#125; &#125; double ans = 0x7fffffff; for ( int i = 0 ; i &lt;= m ; i++ ) for ( int j = 0 ; j &lt;= 1 ; j++ ) ans = min ( ans , f[n][i][j] ); printf ( "%.2lf\n" , ans ) ; return 0 ;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>æ¦‚çŽ‡æœŸæœ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¦‚çŽ‡å…¥é—¨]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%A6%82%E7%8E%87%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[å…¶å®žè¿™é“åˆèµ›é¢˜æ˜¯æˆ‘ç¬¬ä¸€æ¬¡åšçš„æ¦‚çŽ‡é¢˜ æˆ‘ä»¬æ¥çœ‹ä¸€çœ¼è¿™é“æ¯’ç˜¤é¢˜ï¼š é¢˜é¢å…¶å®žå·²ç»å¾ˆæ¸…æ¥šäº†ï¼Œæˆ‘ä»¬å¯ä»¥å‘çŽ°ï¼Œå½“è¿™ä¸ªé’è›™åœ¨ç¬¬$1$å—çŸ³å¤´æ—¶ï¼Œé‚£ä¹ˆè¿™åªé’è›™å®Œå…¨å¯ä»¥ä¸ç”¨è·³ï¼Œæˆ‘ä»¬è®¾$f(k)$è¡¨ç¤ºè¿™åªé’è›™åœ¨$k$å·è·å¶ä¸Šï¼ŒæœŸæœ›éœ€è¦$f(k)$æ¬¡è·³åˆ°$1$å·è·å¶ï¼Œé‚£ä¹ˆæˆ‘ä»¬æœ‰ï¼š f(1)=0æˆ‘ä»¬æŽ¥ç€æ¥è€ƒè™‘å½“è¿™åªé’è›™åœ¨$2$å·è·å¶æ—¶çš„æƒ…å†µï¼Œå®ƒå¯ä»¥è·³åˆ°$1$å·å’Œ$2$å·è·å¶ï¼Œå½“å®ƒè·³åˆ°$1$å·è·å¶æ—¶ï¼Œå®ƒå®Œæˆäº†ä»»åŠ¡ï¼Œè·³äº†ä¸€æ­¥ã€‚å½“å®ƒè·³åˆ°$2$å·æ—¶ï¼Œå®ƒè¿˜æœ‰$f(2)$æ­¥ï¼Œå› ä¸ºæ¯ä¸€æ¬¡è·³è·ƒæ—¶ï¼Œè·³è·ƒåˆ°æ¯ä¸€ä¸ªè·å¶ä¸Šçš„å‡ çŽ‡æ˜¯ç›¸ç­‰çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰ï¼š f(2)=[1+(1+f(2))]/2åŒç†ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ï¼š f(3)=[1+(1+f(2))+(1+f(3))]/3æŽ¨å¹¿åˆ°ä¸€èˆ¬å½¢å¼åˆ™æœ‰: f(k)=[\sum_{i=1}^k{f(i)+1}]/kæˆ‘ä»¬åŒ–ç®€ä¸€ä¸‹ï¼Œæœ‰ï¼š f(k)=1+\frac {1}{k}\sum_{i=1}^kf(i) æˆ‘ä»¬çœ‹åˆ°è¿™ä¸ªå¼å­ï¼š$f(k)=1+\frac {1}{k}\sum_{i=1}^kf(i)$ å½“$i==k$çš„æ—¶å€™,æˆ‘ä»¬ä¼šå‘çŽ°å¼å­é‡Œå‡ºçŽ°äº†ä¸€ä¸ª$f(k)$â€¦.. è¿™å’‹æ±‚å•Š æˆ‘ä»¬å±•å¼€è¿™ä¸ªå¼å­ï¼Œä¼šå‘çŽ°åŽŸæ¥çš„å¼å­ç­‰ä»·äºŽï¼š f(k)=1+\frac {1}{k}\sum_{i=1}^{k-1}f(i)+\frac 1kf(k)è¿™æ—¶å€™å¦‚æžœæŠŠ$f(k)$çœ‹ä½œä¸€ä¸ªæœªçŸ¥æ•°çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥å‘çŽ°$f(k)$çš„è¿™ä¸€é¡¹æ˜¯å¯ä»¥åˆå¹¶çš„ã€‚ä½†æ˜¯æˆ‘ä»¬å…ˆä¸¤è¾¹åŒä¹˜ä¸€ä¸ª$k$ï¼ŒæŠŠåˆ†æ¯åŽ»æŽ‰ï¼Œå°±ä¼šæœ‰ï¼š k*f(k)=k+\sum_{i=1}^{k-1}f(i)+f(k)è¿™æ ·ç­”æ¡ˆå°±å¾ˆæ˜¾ç„¶äº†ï¼Œåˆå¹¶æŽ‰ç­‰å¼ä¸¤è¾¹ç›¸ç­‰çš„$f(k)$ï¼Œä¼šå¾—åˆ°ï¼š (k-1)*f(k)=k+\sum_{i=1}^{k-1}f(i)æœ€åŽï¼Œä¸¤è¾¹åŒé™¤$(k-1)$ï¼Œæœ‰æœ€åŽç­”æ¡ˆä¸Šçš„å…¬å¼ï¼š f(k)=\frac{k}{k-1}(1+\frac {\sum_{i=1}^{k-1}f(i)}{k-1})é€šè¿‡è¿™ä¸ªå¼å­è®¡ç®—å¯ä»¥å¾—åˆ°$f(5)=\frac{37}{12}$,ä¹Ÿå°±æ˜¯ç­”æ¡ˆ åšå®Œäº†QAQ(å†™Markdownå¥½ç´¯å•Šqwqâ€¦)å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å­¦ä¹ ç¬”è®°</tag>
        <tag>æ¦‚çŽ‡æœŸæœ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2015]WIL-Wilczeé¢˜è§£]]></title>
    <url>%2F2018%2F11%2F02%2FPOI2015-WIL-Wilcze%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[å…¶å®žè¿™æœ¬æ¥æ˜¯$QBXT$çš„$T2$ï¼Œä½†æ˜¯ç”±äºŽæ¯’ç˜¤$zhw$è·‘å¾—å¿«ï¼ˆé›¾ï¼‰ï¼Œå¯¼è‡´æˆ‘ä»¬å‘çŽ°è¿™æ˜¯æŸ$poi$åŽŸé¢˜ã€‚ é¦–å…ˆçœ‹é¢˜é¢:é¢˜ç›®é“¾æŽ¥ è¯¦ç»†è¯»äº†ä¸€éä¹‹åŽï¼Œå…¶å®žå¯¹äºŽè¿™é“é¢˜ï¼Œæˆ‘çš„ç¬¬ä¸€ååº”æ˜¯è´ªå¿ƒï¼ˆä¹Ÿè®¸æ˜¯å› ä¸ºæˆ‘å¤ªèœäº†ï¼‰ã€‚ç„¶åŽæ‰“äº†ä¸€éï¼Œå°æ ·ä¾‹è¿‡äº†ï¼Œç„¶åŽè¢«å¤§æ ·ä¾‹$hack$ã€‚ ä¹‹åŽæˆ‘åˆç”¨å‘½åˆ†æžäº†ä¸€ä¸‹ã€‚å¯ä»¥å‘çŽ°ï¼Œå› ä¸ºé¢˜ç›®ä¸­ä¿è¯æ¯ä¸ªæ•°çš„å€¼å…¨éƒ¨$&gt;=0$ï¼Œå³æ¯ä¸ªæ•°éƒ½æ˜¯æ­£æ•´æ•°ã€‚æ‰€ä»¥æˆ‘ä»¬ä¸Žå…¶é€‰é•¿åº¦ä¸åˆ°$d$çš„åŒºé—´åˆ é™¤ï¼Œä¸å¦‚ç›´æŽ¥é€‰æ‹©é•¿åº¦ä¸º$d$çš„åŒºé—´åˆ é™¤ã€‚ é‚£ä¹ˆåœ¨ä¸€æ®µé•¿åº¦å·²çŸ¥çš„åºåˆ—ä¸­ï¼Œé•¿åº¦ä¸º$d$çš„å­åºåˆ—ä¸ªæ•°æ˜¯å·²çŸ¥çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é¢„å¤„ç†å‡ºæ¯ä¸€æ®µé•¿åº¦ä¸º$d$çš„å­åºåˆ—ã€‚ç„¶åŽæˆ‘ä»¬åˆå‘çŽ°ï¼Œé¢˜ç›®ä¸­è¦æ±‚åŒºé—´çš„é•¿åº¦ä¸è¶…è¿‡pï¼Œé‚£ä¹ˆæˆ‘ä»¬å¾ˆæ˜Žæ˜¾çš„å¯ä»¥æƒ³åˆ°å°ºå–æ³•ã€‚ ç„¶åŽæˆ‘ä»¬å°±å¯ä»¥ç”¨å•è°ƒé˜Ÿåˆ—æ¥ç»´æŠ¤æˆ‘ä»¬é¢„å¤„ç†å‡ºçš„è¿™äº›é•¿åº¦ä¸º$d$çš„å­åºåˆ—ã€‚ç„¶åŽå¯¹äºŽåŒºé—´é•¿åº¦å–$max$å°±æ˜¯ç­”æ¡ˆäº†ã€‚ æœ€åŽæ€’æ–¥ä¸€æ³¢å‡ºåŽŸé¢˜çš„å‡ºé¢˜äºº$qaq$â€¦.(è™½ç„¶$zhw$å¾ˆå¸…) ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;deque&gt;typedef long long ll;using std::deque;const ll N=2000010;ll n,p,d;ll a[N];ll sum[N];ll hea[N];struct Node&#123; ll pos,val; Node(ll pos,ll val):pos(pos),val(val)&#123;&#125; Node()&#123;&#125;&#125;;inline void read(ll &amp;x)&#123; ll s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; x=s*w; return;&#125;deque&lt;Node&gt;q;int main()&#123; read(n);read(p);read(d); for(int i=1;i&lt;=n;i++)read(a[i]),sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n-d;i++) hea[i]=sum[i+d]-sum[i]; for(int i=n-d+1;i&lt;=n;i++) hea[i]=sum[n]-sum[i]; ll ans=0; int l=0; for(int i=d+1;i&lt;=n;i++) &#123; while(!q.empty()&amp;&amp;q.back().val&lt;hea[i-d])q.pop_back(); q.push_back(Node(i-d,hea[i-d])); while(l&lt;i-d&amp;&amp;sum[i]-sum[l]-q.front().val&gt;p) &#123; l++; while(l&gt;q.front().pos)q.pop_front(); &#125; ans=std::max(ans,(ll)i-l); &#125; printf("%lld",ans); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å•è°ƒé˜Ÿåˆ—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¤èµ›å†²åˆºDay1R1-Coloré¢˜è§£]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%A4%8D%E8%B5%9B%E5%86%B2%E5%88%BADay1R1-Colory%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[è¿™é“é¢˜æ˜¯è€ƒè¯•æ—¶çš„$T2$ï¼Œæˆ‘æ„Ÿè§‰è¿™é“é¢˜å‡ºçš„ç‰¹åˆ«å¥½ï¼ˆè™½ç„¶å½“æ—¶å¹¶ä¸ä¼šåš é¦–å…ˆçœ‹é¢˜ç›®:$emmmmmâ€¦..$ä»€ä¹ˆé¬¼å•Šè¿™ä¸ªé¢˜æ˜¯$QAQ$ å½“æ—¶ç›´æŽ¥ä¸€è„¸æ‡µé€¼ï¼Œç„¶åŽåªä¼šå†™2^n æžšä¸¾æ¯ä¸€ç§å¡«å……æ–¹å¼ï¼Œç„¶åŽå†æ£€æµ‹çš„æ–¹æ³•â€¦ç„¶è€Œè¿™é“é¢˜è¿™ä¹ˆåšåªæœ‰10åˆ†å•Š$qaqâ€¦.$ ç„¶åŽèµ›åŽé¢˜è§£å‘Šè¯‰æˆ‘ï¼šè¿™é¢˜TMæ˜¯ä¸ªæ¬§æ‹‰å›žè·¯ï¼ï¼ï¼ï¼å½“æ—¶æˆ‘å°±æ‡µé€¼äº†â€¦.ç„¶åŽå½“dalaoä»¬ç»™æˆ‘æŠŠè¿™é“é¢˜è®²æ˜Žç™½äº†ä¹‹åŽï¼Œæˆ‘æ‰å‘çŽ°è¿™é“é¢˜æ€è·¯çš„å¥‡å¦™ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬å‘çŽ°ï¼Œå¯¹äºŽä¸€ä¸ªç‚¹ï¼Œå®ƒå¯¹åº”ç€ä¸€ä¸ªæ¨ªåæ ‡å’Œä¸€ä¸ªçºµåæ ‡ã€‚è’½â€¦.ä¸€ä¸ªç‚¹å¯¹åº”ç€ä¸¤ä¸ªæ•°å€¼ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬åº”è¯¥æƒ³åˆ°ä»€ä¹ˆï¼ŸäºŒåˆ†å›¾ï¼Ÿå¯¹äº†ï¼Œè¿™ä¸œè¥¿è¿˜çœŸçš„å°±æ˜¯è¦ä½ ç”¨äºŒåˆ†å›¾çš„æ€æƒ³æ¥å»ºå›¾â€¦.(å¿ƒæ€å´©äº†æˆ‘è¦å¦¹å­$QAQ$) æˆ‘ä»¬å»ºå›¾ï¼Œç„¶åŽæˆ‘ä»¬å‘çŽ°ï¼Œå› ä¸ºä¸€ä¸ªç‚¹å¯¹åº”ç€ä¸€ä¸ªæ¨ªåæ ‡å’Œä¸€ä¸ªçºµåæ ‡ï¼Œé‚£ä¹ˆæˆ‘ä»¬æƒ³åˆ°ï¼šåœ¨äºŒåˆ†å›¾ä¸­ï¼Œæ¯ä¸€æ¡è¾¹ä¹Ÿæ˜¯å¯¹åº”ç€ä¸¤ç§ç‚¹ã€‚é‚£ä¹ˆå—åˆ°è¿™æ ·çš„å¯å‘ï¼Œæˆ‘ä»¬å°±å¯ä»¥å»ºå›¾äº†ï¼šæˆ‘ä»¬æŠŠæ¨ªåæ ‡å’Œçºµåæ ‡åˆ†åˆ«çœ‹æˆä¸€ç§ç‚¹ï¼Œç„¶åŽå°†é¢˜ç›®ä¸­ç»™ä½ çš„ç‚¹çœ‹æˆè¿™å¼ å›¾ä¸Šçš„è¾¹ï¼Œé‚£ä¹ˆå› ä¸ºé¢˜ç›®ä¸­è¦æ±‚ï¼šé»‘ç‚¹å’Œç™½ç‚¹çš„ç»å¯¹å€¼å·®ä¸å¤§äºŽ1â€¦..ï¼Œé‚£ä¹ˆæˆ‘ä»¬èƒ½æƒ³åˆ°ä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬è¦å¯¹è¿™äº›è¾¹è¿›è¡Œé»‘ç™½æŸ“è‰²ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä¸€ä¸ªç‚¹å‡ºå‘ï¼Œä¸€ç›´èµ°ä¸€æ¡æ¬§æ‹‰å›žè·¯ï¼Œè¿™æ ·èƒ½èµ°éæ‰€æœ‰çš„è¾¹ã€‚ ä½†æ˜¯è¿™æ ·åšï¼Œæˆ‘ä»¬ä¼šå‘çŽ°ä¸€ä¸ªé—®é¢˜ï¼šåªæœ‰$subtask4$çš„$30$åˆ†æ•°æ®å‘Šè¯‰ä½ æ˜¯å¶æ•°ã€‚è€Œå­˜åœ¨æ¬§æ‹‰å›žè·¯çš„å›¾çš„ç‰¹ç‚¹æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæ¯ä¸ªç‚¹çš„åº¦æ•°éƒ½æ˜¯å¶æ•°ï¼Œé‚£ä¹ˆå½“ç‚¹çš„åº¦æ•°æ˜¯å¥‡æ•°çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ€Žä¹ˆåŠžå‘¢ï¼Ÿ æˆ‘åœ¨è¿™é‡Œé€‰æ‹©äº†åº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹å‘ä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹è¿žè¾¹ï¼Œç„¶åŽå½“æ‰€æœ‰ç‚¹çš„åº¦æ•°éƒ½æ˜¯å¶æ•°æ—¶ï¼Œè¿™æ—¶å€™æ²¡æœ‰å…¶ä»–ç‚¹å‘è¿™ä¸ªç‚¹è¿žè¾¹æ‰€ä»¥è¿™æ—¶å€™è¿™ä¸ªè™šæ‹ŸèŠ‚ç‚¹å¯¹ç­”æ¡ˆæ²¡æœ‰å½±å“ã€‚ ç„¶åŽï¼Œæˆ‘ä»¬å°±ç›´æŽ¥å¯¹è¾¹è¿›è¡ŒæŸ“è‰²å°±å¯ä»¥äº†ã€‚ æˆ‘åªæƒ³è¯´ï¼Œè¿™é“é¢˜å‡ºçš„çœŸçš„å¥½ï¼Œä½©æœå‡ºé¢˜äººã€‚ ä»£ç ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt; const int N = 5e5 + 10; struct Data &#123; int v; int p;&#125;data[N];struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int n , m , t = 1 , num;int head[N] , d[N];int x[N] , y[N] , ans[N];bool flag[N]; inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline bool cmp ( Data x , Data y ) &#123; return x.v&lt;y.v;&#125;void lisanhua () &#123; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = x[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; x[data[i].p] = num; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = y[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; y[data[i].p] = num; &#125; return;&#125;void dfs ( int cur , bool last ) &#123; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; if ( flag[i &gt;&gt; 1] ) continue; int j = e[i].to; flag[i &gt;&gt; 1] = 1; d[cur]--; d[j]--; ans[i &gt;&gt; 1] = !last; dfs ( j , !last ); &#125; return;&#125; int main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; x[i] = read (); y[i] = read (); &#125; lisanhua(); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; d[x[i]]++; d[y[i]]++; add ( x[i] , y[i] ); add ( y[i] , x[i] ); &#125; for ( int i = 1 ; i &lt;= num ; i++ ) if ( d[i] &amp; 1 ) &#123; d[i]++; d[num + 1]++; add ( i , num + 1 ); add ( num + 1 , i ); &#125; num++; memset ( ans , -1 , sizeof ( ans ) ); for ( int i = 1 ; i &lt;= num ; i++ ) while ( d[i] ) dfs ( i , 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , ans[i] , i == n ? '\n' : ' ' ); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ¨¡æ‹Ÿèµ›é¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¤èµ›å†²åˆºDay1R1-Counté¢˜è§£]]></title>
    <url>%2F2018%2F11%2F01%2FqbxtD1T1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[å…¶å®žæˆ‘æ„Ÿè§‰è¿™é“æ•°è®ºé¢˜è¿˜æ˜¯æŒºç®€å•çš„ï¼ˆè™½ç„¶æˆ‘ä¸ä¼šï¼‰ è¿™é“æ•°è®ºé¢˜ï¼Œæˆ‘åˆçœ‹çš„æ—¶å€™æ˜¯æŒºä¸€è„¸æ‡µé€¼çš„ï¼Œç„¶åŽæ®$wucstdio$å¤§çˆ·æä¾›çš„æ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥å‘çŽ°ï¼šé¢˜æ„æ±‚çš„æ˜¯$x$,$y$åœ¨$mod P$ä¸‹çš„é€†å…ƒï¼Œå­˜åœ¨è§£çš„æ¡ä»¶æ˜¯$gcd(x,p)==1$ï¼Œå³x,päº’è´¨ã€‚æ‰€ä»¥ç”±é¢˜è§£æœ‰è®¾ 1 åˆ° P âˆ’ 1 ä¸­ä¸Ž P äº’è´¨çš„æ•°æœ‰ s ä¸ªï¼Œè€ƒè™‘è¿™ s ä¸ªæ•°ä¸Žå®ƒä»¬çš„é€†å…ƒç»„æˆçš„äºŒå…ƒç»„ï¼Œè¿™äº›äºŒå…ƒç»„ä¸€å®šç¬¦åˆæ¡ä»¶ï¼Œé‚£ä¹ˆåªè¦è€ƒè™‘åŽ»é‡çš„é—®é¢˜ æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦çŸ¥é“ä»Ž$1$åˆ°$n$ä¸­å’Œ$n$äº’è´¨çš„æ•°çš„ä¸ªæ•°è¿™ä¸ªä¸œè¥¿æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿè¿™ä¸ªä¸œè¥¿å¾ˆæ˜Žæ˜¾æ˜¯$phi$å‡½æ•°ã€‚æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦æ±‚å‡º$\phi(p)$ï¼Œå†åŠ ä¸Š$x^2\equiv1\pmod{p}$çš„æ•°ï¼Œæœ€åŽé™¤$2$å°±å¥½äº†ã€‚ ä»£ç ï¼š123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e7 + 10;int n;int tot , prime[N] , phi[N];bool flag[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); flag[1] = 1; phi[1] = 1; for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; prime[++tot] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] *prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; long long ans = phi[n]; for ( long long i = 1 ; i &lt;= n ; i++ ) if ( i * i % n == 1 ) ans++; printf ( "%lld\n" , ( long long ) ( ans ) / 2 ); return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ¨¡æ‹Ÿèµ›é¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A*å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2018%2F10%2F19%2FA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ä¾‹é¢˜ï¼š$LuoguP2324$:éª‘å£«ç²¾ç¥ž $A*$å˜›ï¼Œå¾ˆæ—©æ—¶å€™å°±å¬è¯´è¿‡ï¼Œè²Œä¼¼æ˜¯ä¸€ç§å¾ˆç¥žå¥‡çš„ç®—æ³•ã€‚å¬é•¿è€…è®²è¿‡ä¸€éï¼Œä¸€ç›´éƒ½æƒ³è‡ªå·±æ‰“ä¸€éã€‚ä½†æ˜¯ä¸€ç›´æ²¡æœºä¼šã€‚æ‰€ä»¥æ¥è‡ªå·±å†™ä¸€éå°±å¥½å•¦ã€‚ $A*$çš„é‡ç‚¹å°±æ˜¯ä¸€ä¸ªå«åšä¼°ä»·å‡½æ•°çš„ä¸œè¥¿ï¼Œä½†æ˜¯è¿™ä¸ªå«ä¼°ä»·å‡½æ•°çš„ä¸œè¥¿ä½ å¿…é¡»è¦å¥½å¥½å†™ï¼Œä¸ç„¶ä½ ä¼šæœå‡ºæ¥$WA$çš„å¥½æˆç»©å¯¹äºŽè¿™é“é¢˜ï¼Œæˆ‘å°±æ˜¯å°†çŽ°åœ¨çš„æ£‹ç›˜å’Œç›®æ ‡æ£‹ç›˜ä¸åŒæ£‹å­æ•°çš„å·®å½“ä½œä¼°ä»·å‡½æ•°ï¼ˆå…¶å®žæ˜¯æ­£ç¡®çš„)ã€‚ç„¶åŽï¼Œæˆ‘ä»¬å°±å¯ä»¥åŠ ä¸€ä¸ªç±»ä¼¼äºŽå‰ªæžçš„ä¸œè¥¿ï¼šå¦‚æžœçŽ°åœ¨çš„æ­¥æ•°$+$ä¼°ä»·å‡½æ•°ä¼°è®¡çš„å€¼$&gt;$çŽ°åœ¨çš„$max$ï¼Œç›´æŽ¥$return$å°±å¥½ã€‚å‰©ä¸‹çš„ä¸œè¥¿å°±æ˜¯ä¸ªå¤§çˆ†æœäº†ï¼Œ ä»¥ä¸‹æ˜¯ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int goal[7][7] = &#123; &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;, &#123; 0 , 1 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 2 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;&#125;;char mp[6][6];int now[6][6];bool flag;int dx[] = &#123; 0 , 1 , 1 , -1 , -1 , 2 , 2 , -2 , -2 &#125;;int dy[] = &#123; 0 , 2 , -2 , 2 , -2 , 1 , -1 , 1 , -1 &#125;;inline int calcu () &#123; int tmp = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) &#123; if ( now[i][j] != goal[i][j] ) tmp++; &#125; return tmp;&#125;inline void swap ( int &amp;x , int &amp;y ) &#123; int t = x; x = y; y = t; return;&#125;void A_Star ( int x , int y , int dep , int MaxStep ) &#123; if ( flag ) return; if ( dep == MaxStep ) &#123; if ( calcu () == 0 ) &#123; flag = 1; printf ( "%d\n" , MaxStep ); return; &#125; return; &#125; for ( int i = 1 ; i &lt;= 8 ; i++ ) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if ( xx &gt; 5 || xx &lt; 1 || yy &gt; 5 || yy &lt; 1 ) continue; swap ( now[x][y] , now[xx][yy] ); if ( calcu () + dep &lt;= MaxStep ) A_Star ( xx , yy , dep + 1 , MaxStep ); swap ( now[x][y] , now[xx][yy] ); &#125; return;&#125;int main ( void ) &#123; int ttt; scanf ( "%d" , &amp;ttt ); while ( ttt-- ) &#123; flag = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) scanf ( "%s" , mp[i] + 1 ); int st_x , st_y; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) if ( mp[i][j] == '*' ) &#123; st_x = i; st_y = j; now[i][j] = 2; &#125; else now[i][j] = mp[i][j] - '0'; if ( calcu () == 0 ) &#123; puts ( "0" ); return 0; &#125; for ( int i = 1 ; i &lt;= 15 ; i++ ) if ( !flag ) A_Star ( st_x , st_y , 0 , i ); if ( !flag ) puts ( "-1" ); &#125; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>å­¦ä¹ ç¬”è®°</tag>
        <tag>çŽ„å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wucstdioçš„æ¯’ç˜¤æ¨¡æ‹Ÿèµ›]]></title>
    <url>%2F2018%2F10%2F18%2Fwucstdio%E7%9A%84%E6%AF%92%E7%98%A4%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[$wucstdio$å¤§çˆ·çš„Flagè¿˜æ˜¯æ²¡æœ‰å€’â€¦. T1: åæ­£æˆ‘åˆšå¼€å§‹å¯¹è¿™é“é¢˜æ˜¯å®Œå…¨æ²¡æœ‰ä»€ä¹ˆä¿¡å¿ƒçš„qaqï¼ˆæ‰ä¸ä¼šå‘Šè¯‰ä½ æˆ‘ç›´æŽ¥åŽ»çœ‹çš„$T2$ï¼‰è€ƒè™‘$50$åˆ†çš„æƒ…å†µï¼šä¸€æ¡é“¾ã€‚æ‰€ä»¥å°±æ˜¯ä¸€ä¸ªç­‰å·®æ•°åˆ—äº†qwqè€ƒè™‘å‰©ä½™çš„æ­£è§£ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸€æ­¥çš„æœŸæœ›å€¼å½“æˆè¿™æ£µæ ‘çš„æƒå€¼ï¼Œç„¶åŽå› ä¸ºä»Žä¸Šå‘ä¸‹å’Œä»Žä¸‹å‘ä¸Šçš„æœŸæœ›å€¼å¯èƒ½ä¸å¤ªä¸€æ ·ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸¤ä¸ªå‡½æ•°æ¥è¡¨ç¤ºï¼šï¼ˆç›¸å½“äºŽä¸¤æ¡è¾¹ï¼‰ã€‚æˆ‘ä»¬è®¾$f(x) g(x)$åˆ†åˆ«è¡¨ç¤ºä»Žä¸‹å‘ä¸Šå’Œä»Žä¸Šå‘ä¸‹çš„æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬è€ƒè™‘æ±‚å‡º$f(x)$æ—¶ï¼Œæˆ‘ä»¬è¦è€ƒè™‘ä»¥ä¸‹æƒ…å†µï¼šç›´æŽ¥èµ°åˆ°è¿™ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œæ‰€ä»¥è¿™ç§æƒ…å†µä¸‹ï¼Œå¯¹è¿™ä¸ªèŠ‚ç‚¹å¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯$\frac {1}{d[x]}äº†$è¿˜æœ‰ä¸€ç§æƒ…å†µå°±æ˜¯è¿™ä¸ªèŠ‚ç‚¹å…ˆè·³åˆ°ä»–çš„å„¿å­ï¼Œå†è·³å›žè¿™ä¸ªèŠ‚ç‚¹ï¼Œå†è·³è¿‡åŽ»ã€‚è¿™ä¸ªæ—¶å€™ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦ä¸€æ­¥æ¥è·³è¿‡åŽ»ï¼Œæ‰€ä»¥è¿™ç§æƒ…å†µå¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯:$\sum_{j=son} \frac {1}{d[x]}[1 + f(x) + f(j) ]$æˆ‘ä»¬ç»¼åˆè€ƒè™‘ä¸€ä¸‹è¿™ä¸¤ç§æƒ…å†µå¯¹ç­”æ¡ˆçš„è´¡çŒ®å€¼ï¼Œå°†è¿™ä¸¤ä¸ªå¼å­åŠ èµ·æ¥ï¼Œæˆ‘ä»¬å°±ä¼šå¾—åˆ°ä¸‹è¾¹çš„è¿™ä¸ªå¼å­ï¼š f(x) = \frac{1}{d} + \sum_{j=son}\frac{1}{d}\times[1 +f(x) + f ( j )]æˆ‘ä»¬å®‰ç½®æˆ‘ä»¬åšæœŸæœ›çš„ä¸€è´¯æ€è·¯ï¼ˆå¥½åƒæˆ‘åšè¿‡å¤šå°‘æœŸæœ›ä¸€æ ·QwQï¼‰ï¼Œå› ä¸º$num[son]=p-1$ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¾—åˆ°è¿™æ ·ä¸€ä¸ªå¼å­ï¼š d\times f(x)=1+d-1+(d-1)f(x)+\sum_{j}f(j)åŒ–ç®€ä¸€ä¸‹ä¹‹åŽæœ‰ï¼š f(x)=d+\sum_{j}f(j)ç„¶åŽæˆ‘ä»¬æ¥è€ƒè™‘ä¸€ä¸‹$g(x)$è¿™ä¸ªä¸œè¥¿æ€Žä¹ˆæ±‚ï¼Œå½“æˆ‘ä»¬ç»è¿‡è§‚å¯Ÿä¹‹åŽï¼Œæˆ‘ä»¬å¯ä»¥å‘çŽ°è¿™ä¸ªå¼å­æœ‰ä¸‰ç§æƒ…å†µï¼šä»–çš„çˆ¶äº²ç›´æŽ¥è·³åˆ°ä»–è¿™é‡Œï¼Œè¿™ç§æƒ…å†µå¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯$\frac{1}{d[father]}$ä»–çš„çˆ¶äº²å…ˆè·³åˆ°ä»–çš„çˆ·çˆ·ï¼Œç„¶åŽå†è·³å›žæ¥ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œå¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯ï¼š$\frac{1}{d[father]}\times (1 + g(p) +g(x) )$ä»–çš„çˆ¶äº²è·³åˆ°ä»–çš„å…„å¼Ÿç„¶åŽå†è·³åˆ°ä»–è‡ªå·±ã€‚æˆ‘ä»¬æŠŠè¿™ä¸‰ç§æƒ…å†µåŠ èµ·æ¥ï¼Œå°±ä¼šæœ‰ï¼š g(x)=\dfrac {1}{d[father]} \times(1+g(p)+g(x))+\dfrac {1}{d[father]}+\sum_{pa_j=pa_x\&\&j\not=x}\dfrac {1}{d[father]} (1+f(j)+g(x))ç»§ç»­åŒ–ç®€æœ‰ï¼š g(x)=g(p)+f(p)-f(x)é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬å°±å¯ä»¥æŠŠ$g(x) f(x)$ç®—å‡ºæ¥ï¼Œç›¸å½“äºŽè¾¹é•¿ã€‚ ç®—å‡ºè¾¹é•¿åŽï¼Œè¿™ä¸ªé—®é¢˜å°±è½¬åŒ–æˆäº†ï¼šç»™ä½ ä¸€é¢—æ ‘ï¼Œæ±‚æ ‘çš„ç›´å¾„ã€‚æˆ‘é€‰æ‹©äº†DPæ±‚ç›´å¾„ï¼Œå°±å¾ˆç®€å•äº†ã€‚ ä»£ç ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;const int N = 2e5 + 10;int n , m , t;struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int head[N];int now_ans;int f[N] , g[N] , p[N];int LongDis[N][2] , SecondDis[N][2];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline int min ( int x , int y ) &#123; return x &lt; y ? x : y;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;void Find_f ( int root , int fa ) &#123; f[root] = p[root]; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Find_f ( j , root ); f[root] += f[j]; &#125; return;&#125;void Find_g ( int root , int fa ) &#123; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; g[j] = f[root] + g[root] - f[j]; Find_g ( j , root ); &#125; return;&#125;void Work ( int root , int fa ) &#123; int Frist = 0 , Second = 0; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Work ( j , root ); if ( LongDis[j][0] + g[j] &gt; LongDis[root][0] ) &#123; SecondDis[root][0] = LongDis[root][0]; LongDis[root][0] = LongDis[j][0] + g[j]; Frist = j; &#125; else if ( LongDis[j][0] + g[j] &gt; SecondDis[root][0] ) SecondDis[root][0] = LongDis[j][0] + g[j]; if ( LongDis[j][1] + f[j] &gt; LongDis[root][1] ) &#123; SecondDis[root][1] = LongDis[root][1]; LongDis[root][1] = LongDis[j][1] + f[j]; Second = j; &#125; else if ( LongDis[j][1] + f[j] &gt; SecondDis[root][1] ) SecondDis[root][1] = LongDis[j][1] + f[j]; &#125; if ( Frist != Second ) now_ans = max ( LongDis[root][0] + LongDis[root][1] , now_ans ); else if ( Frist == Second ) now_ans = max ( now_ans , max ( SecondDis[root][1] + LongDis[root][0] , SecondDis[root][0] + LongDis[root][1] ) ); return;&#125;int main ( void ) &#123; freopen ( "tree.in" , "r" , stdin ); freopen ( "tree.out" , "w" , stdout ); n = read (); for ( int i = 1 ; i &lt; n ; i++ ) &#123; int x = read () , y = read (); add ( x , y ); add ( y , x ); p[x]++; p[y]++; &#125; Find_f ( 1 , 0 ); Find_g ( 1 , 0 ); Work ( 1 , 0 ); printf ( "%d.00000\n" , now_ans ); return 0;&#125; T2:å…¶å®žæš´åŠ›è¿˜æ˜¯æŒºæ˜¾ç„¶çš„ å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ¨¡æ‹Ÿèµ›é¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å‰æŽ’æ‰“å‡ºé¢˜äººçš„ä¸€å¥—é¢˜]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%89%8D%E6%8E%92%E6%89%93%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E4%B8%80%E5%A5%97%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ä¸ç®¡æ€Žä¹ˆæ ·ï¼Œå…ˆæ‰“æ­»å‡ºé¢˜äººå†è¯´qaqâ€¦ T1:äººè´©å­$LLFZ$ é¢˜æ„å¾ˆæ˜¾ç„¶å°±æ˜¯æœ€ä¼˜è´¸æ˜“å•Šâ€¦. ä¸€çœ¼çœ‹å‡ºæ¥æ˜¯ç¼©ç‚¹+DPâ€¦.ä½†æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä¹‹å‰æ˜¯SPFAè¿‡çš„å•ŠQAQâ€¦å†™SPFAæ¯”è¾ƒç¨³â€¦.ç„¶åŽâ€¦.å°±å†™äº†â€¦. ä¸Šä»£ç å§â€¦. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int N = 1e5 + 10;const int M = 1e6 + 10;const int INF = 2147483647;#define G(i,a,b,c) for ( int i = b[a] ; i ; i = c[i].next )int n , m , t , cnt;struct Edge &#123; int to; int data; int next;&#125;e[M] , e_[M];int head[N] , head_[N];int maxs[N] , mins[N];int dis[N] , value[N];bool inque[N];std :: queue &lt; int &gt; qu;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void add_ ( int x , int y , int z ) &#123; e_[++cnt].to = y; e_[cnt].data = z; e_[cnt].next = head_[x]; head_[x] = cnt; return;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;void Heap_Dijkstra () &#123; std :: memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[1] = 1 , dis[1] = value[1]; qu.push ( 1 ); while ( !qu.empty () ) &#123; int j = qu.front (); inque[j] = 0; qu.pop (); G ( i , j , head , e ) &#123; int k = e[i].to; if ( dis[k] &gt; min ( dis[j] , e[i].data ) ) &#123; dis[k] = min ( dis[j] , e[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) mins[i] = dis[i]; std :: memset ( dis , -0x3f3f3f3f , sizeof ( dis ) ); inque[n] = 1 , dis[n] = value[n]; qu.push ( n ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; G ( i , j , head_ , e_ ) &#123; int k = e_[i].to; if ( dis[k] &lt; max ( dis[j] , e_[i].data ) ) &#123; dis[k] = max ( dis[j] , e_[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) maxs[i] = dis[i]; return;&#125; int main ( void ) &#123; freopen ( "child.in" , "r" , stdin ); freopen ( "child.out" , "w" , stdout ); n = read (); m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) value[i] = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); if ( z == 1 ) &#123; add ( x , y , value[y] ); add_ ( y , x , value[x] ); &#125; else if ( z == 2 ) &#123; add ( x , y , value[y] ); add ( y , x , value[x] ); add_ ( y , x , value[x] ); add_ ( x , y , value[y] ); &#125; &#125; Heap_Dijkstra (); int ans = -INF; for ( int i = 1 ; i &lt;= n ; i++ ) ans = max ( ans , maxs[i] - mins[i] ); printf ( "%d\n" , ans ); return 0;&#125; T2 : food å†æ¥æ‹¿å‡ºé¢˜äººç¥­å¤©ç¥­ä¸€æ³¢â€¦ è¯è¯´æˆ‘ç›´æŽ¥è¯»é¢˜è¯»é”™äº†ç„¶åŽå†™äº†ä¸ªé”™è¯¯çš„DPç„¶åŽè¿˜Aäº†æ˜¯ä»€ä¹ˆé¬¼å•Šâ€¦. è¯è¯´æˆ‘è€ƒè™‘äº†å‰ç¼€å’Œï¼Œé‚£ä¹ˆæˆ‘è¿˜è¿‡äº†ï¼Œè¯´æ˜Žç›´æŽ¥åŠ èµ·æ¥ç„¶åŽé™¤å°±å¯ä»¥? 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int N = 15;int n , ans = -1;int A , B , C;int p1 , p2 , p3;int MaxTime[N];int f[N][105][105][105];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;int main ( void ) &#123; freopen ( "food.in" , "r" , stdin ); freopen ( "food.out" , "w" , stdout ); A = read () , B = read () , C = read (); p1 = read () , p2 = read () , p3 = read (); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; MaxTime[i] = read (); MaxTime[i] = MaxTime[i - 1] + MaxTime[i]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = A ; j * p1 &lt;= MaxTime[i] &amp;&amp; j&lt;=100 ; j++ ) for ( int k = B; j * p1 + k * p2 &lt;= MaxTime[i] &amp;&amp; k &lt;= 100 ; k++ ) for ( int l = C ; j * p1 + k * p2 + l * p3 &lt;= MaxTime[i] &amp;&amp; l &lt;=100 ; l++ ) &#123; f[i][j][k][l] = max ( f[i][j][k][l] , max ( f[i - 1][j - A][k - B][l - C] + 1 , f[i][j - A][k - B][l - C] + 1 ) ); ans = max ( ans , f[i][j][k][l] ); &#125; printf ( "%d\n" , ans ); return 0;&#125; T3: Happy å†åæ§½ä¸€æ³¢ä¸ºä»€ä¹ˆNoipæ¨¡æ‹Ÿèµ›ä¼šè€ƒç¦»æ•£å¯¹æ•°ï¼ˆç„¶è€Œæˆ‘å¹¶ä¸ä¼šâ€¦.ï¼‰ å…¶å®žåº”è¯¥æ˜¯ä¸€é“ç­¾åˆ°é¢˜å§ã€‚ã€‚ã€‚ æš´åŠ›æ°´è¿‡â€¦. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int P , A , B;bool app[50005];int main ( void ) &#123; freopen ( "happy.in" , "r" , stdin ); freopen ( "happy.out" , "w" , stdout ); int T = read (); while ( T-- ) &#123; int now = 1; memset ( app , false , sizeof ( app ) ); P = read () , A = read () , B = read (); for ( int i = 1 ; ; i++ ) &#123; now = ( now * A ) % P; if ( now == B ) &#123; printf ( "%d\n" , i ); break; &#125; if ( app[now] ) &#123; puts ( "Couldn't Produce!" ); break; &#125; app[now] = 1; &#125; &#125; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>æ¨¡æ‹Ÿèµ›é¢˜è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My_Code_Style]]></title>
    <url>%2F2018%2F10%2F13%2FMy_Code_Style%2F</url>
    <content type="text"><![CDATA[ä»‹ç»ä¸‹æœ¬è’Ÿè’»çš„ä¸‘æ­»çš„ç é£Ž$qwq$â€¦(ç é£Žå¤§æ¦‚æ˜¯é­”æ”¹äº†ç¥žçŠ‡$Menci$çš„) åœ¨æ‰“CFæ—¶å¹¶ä¸æ˜¯è¿™ä¸ªç é£Ž ç é£Žæ¦‚è¿°ï¼š æ‰€æœ‰çš„#includeåŽå¿…é¡»æœ‰ä¸€ä¸ªç©ºæ ¼,ä¾‹å¦‚#include æ— è®ºä»€ä¹ˆæ ·å­çš„ç¨‹åºï¼Œéƒ½å¿…é¡»å†™cstdio cstring algorithm iostreamè¿™å››ä¸ªå¤´æ–‡ä»¶ã€‚ åœ¨ä¸»ç¨‹åºçš„int main()ä¸­è¦åŠ $void$ï¼Œå³ä¸ºint main(void) ä¸€èˆ¬ä¸å†™using namespace std; æ‰€æœ‰çš„å˜é‡å¿…é¡»å®šä¹‰åœ¨ç¬¬ä¸€ä¸ªè‡ªå®šä¹‰å‡½æ•°ä¹‹å‰ï¼Œä¸”å˜é‡å’Œç¬¬ä¸€ä¸ªè‡ªå®šä¹‰å‡½æ•°ï¼Œæœ€åŽä¸€ä¸ªè‡ªå®šä¹‰å‡½æ•°å’Œ$main$ä¹‹é—´å¿…é¡»æœ‰ä¸€ä¸ªæ¢è¡Œ æ¯ä¸ªå‡½æ•°ä¹‹åŽå°½å¯èƒ½æœ‰$return$ï¼Œ åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œåœ¨èŠ±æ‹¬å·å†…çš„å†…å®¹ä¸åŠ é€—å· ç¼©è¿›ï¼š å¯¹äºŽæ¯ä¸ªä»£ç å—ï¼Œä½¿ç”¨4ç©ºæ ¼æˆ–è€…ç­‰é•¿çš„Tabç¼©è¿›ã€‚ æ‹¬å·ï¼š å¤§æ‹¬å·ä¸æ¢è¡Œ ç©ºæ ¼ï¼š ä¸ªäººæ„Ÿè§‰è‡ªå·±çš„ç©ºæ ¼æ¯”è¾ƒçš„æ¯’ç˜¤ã€‚ 1.åœ¨æ¯ä¸ªå‡½æ•°å£°æ˜Žæ—¶ï¼Œå‡½æ•°ååŽçš„æ‹¬å·ä¸Žå‡½æ•°åä¹‹é—´å¿…é¡»æœ‰ä¸€ä¸ªç©ºæ ¼,è€Œä¸”æ‹¬å·å†…å¦‚æžœéœ€è¦å£°æ˜Žå˜é‡ï¼Œåˆ™è¦å…ˆæœ‰ä¸€ä¸ªç©ºæ ¼ï¼Œä¸”é€—å·çš„å‰åŽéƒ½å¿…é¡»æœ‰ä¸€ä¸ªç©ºæ ¼ã€‚ 2.åœ¨forå¾ªçŽ¯çš„å£°æ˜Žä¸­ï¼Œæ¯ä¸€ä¸ªå­—ç¬¦ï¼ˆå˜é‡åé™¤å¤–ï¼‰ï¼Œéƒ½è¦ç”¨ç©ºæ ¼éš”å¼€ã€‚ 3.æ•°ç»„å†…ä¸€èˆ¬ä¸åŠ ç©ºæ ¼ï¼Œä½†æ˜¯å¦‚æžœæœ‰è¿ç®—ç¬¦åˆ™è¿ç®—ç¬¦å‰åŽå¿…é¡»æœ‰ç©ºæ ¼ã€‚ 4.æ¯ä¸ªå¯ä»¥å‰åŽåŒ¹é…çš„æ‹¬å·å‰åŽå¿…é¡»æœ‰ç©ºæ ¼ã€‚ å˜é‡ï¼š 1.åŸºæœ¬æ‰€æœ‰å˜é‡éƒ½æ˜¯å…¨å±€å˜é‡ï¼Œä½†æœ‰äº›ans,sumæœ€åŽç»Ÿè®¡ç­”æ¡ˆæ—¶ä½¿ç”¨çš„å˜é‡å¯ä»¥å®šä¹‰ä¸ºå±€éƒ¨å˜é‡ã€‚ 2.æ‰€æœ‰çš„å˜é‡åç§°éƒ½å¿…é¡»ä¸Žè¦å­˜å‚¨çš„ä¸œè¥¿çš„ä¸­æ–‡æ„æ€æœ‰æ²¾è¾¹ï¼Œæ¯”å¦‚æ ‘ç›´æŽ¥å®šä¹‰ä¸ºtreeè€Œä¸æ˜¯Tã€‚ï¼ˆæžåº¦ä¸èƒ½å®¹å¿å˜é‡åç›´æŽ¥ä¸ºa,b,c,d,e,f,g,çš„æƒ…å†µã€‚ 3.å®šä¹‰N,Mç­‰æ—¶ä¸€èˆ¬åªç”¨N,Mä¸ºåç§°è€Œä¸æ˜¯MAXN,MAXM. 4.å®šä¹‰çš„ç»“æž„ä½“ç±»åž‹åœ¨å®šä¹‰å˜é‡æ—¶å¿…é¡»ç´§æŽ¥ç€å£°æ˜Žå®Œæˆç»“æž„ä½“åŽï¼Œå¹¶ä¸”ç»“æž„ä½“ä¸­å˜é‡éœ€è¦å®šä¹‰ä¸€ä¸ªåŠ ä¸€ä¸ªæ¢è¡Œã€‚ 5.åœ¨å˜é‡å‘½åæ—¶è¾ƒé•¿çš„å˜é‡åå¯ä»¥ç”¨_æ¥è¿žæŽ¥ï¼Œå¹¶ä¸”å¤§å°å†™äº¤æ›¿ä½¿ç”¨ï¼Œå¦‚Add_Tree_Val æŠŠä¸Šè¾¹æ‰€æœ‰æ¯’ç˜¤çš„ç é£Žç»“åˆèµ·æ¥ä¹‹åŽä»£ç å¤§æ¦‚é•¿è¿™ä¸ªæ ·å­qwq.. update:è¿˜æ˜¯åŠ ä¸Šæ¨¡æ¿èˆ’æœqwq ä¸è¦åæ§½æˆ‘çš„ä¸‘é€¼$Splayâ€¦..$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register inttemplate &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt;typename T&gt; void write(T x) &#123;if (x &lt; 0) x = -x, putchar('-');if (x &gt; 9) write(x / 10);putchar(x % 10 + 48);return;&#125;template &lt;typename T&gt; void writeln(T x) &#123; write(x); printf ("\n"); &#125;/**********************************************************************************************************************************************************************************************************************************************************************/const int N = 1e6 + 5;int root , tot , n;struct Tree &#123; int ch[2]; int val; int father; int size; int cnt;&#125;tree[N];void pushup ( int cur ) &#123; tree[cur].size = tree[tree[cur].ch[0]].size + tree[tree[cur].ch[1]].size + tree[cur].cnt; return;&#125;void rotate ( int x ) &#123; int y = tree[x].father; int z = tree[y].father; int k = tree[y].ch[1] == x; tree[z].ch[tree[z].ch[1] == y] = x; tree[x].father = z; tree[y].ch[k] = tree[x].ch[k ^ 1]; tree[tree[x].ch[k ^1]].father = y; tree[x].ch[k ^ 1] = y; tree[y].father = x; pushup ( x ); pushup ( y ); return;&#125;void Splay ( int x , int goal ) &#123; while ( tree[x].father != goal ) &#123; int y = tree[x].father; int z = tree[y].father; if ( z != goal ) ( tree[y].ch[0] == x ) ^ ( tree[z].ch[0] == y ) ? rotate ( x ) : rotate ( y ); rotate ( x ); &#125; if ( goal == 0 ) root = x; return;&#125;void insert ( int x ) &#123; int cur = root , father = 0; while ( cur &amp;&amp; tree[cur].val != x ) &#123; father = cur; cur = tree[cur].ch[x &gt; tree[cur].val]; &#125; if ( cur ) tree[cur].cnt++; else &#123; cur = ++tot; if ( father ) tree[father].ch[x &gt; tree[father].val] = cur; tree[cur].ch[0] = tree[cur].ch[1] = 0; tree[cur].father = father; tree[cur].val = x; tree[cur].cnt = 1; tree[cur].size = 1; &#125; Splay ( cur , 0 ); return;&#125;void Find ( int x ) &#123; int cur = root; if ( !cur ) return; while ( tree[cur].ch[x &gt; tree[cur].val] &amp;&amp; x != tree[cur].val ) cur = tree[cur].ch[ x &gt; tree[cur].val]; Splay ( cur , 0 ); return;&#125;int Next ( int x , int f )&#123; Find ( x ); int cur = root; if ( tree[cur].val &gt; x &amp;&amp; f ) return cur; if ( tree[cur].val &lt; x &amp;&amp; !f ) return cur; cur = tree[cur].ch[f]; while ( tree[cur].ch[f ^ 1] ) cur = tree[cur].ch [f ^ 1]; return cur;&#125;void Delete ( int x ) &#123; int last = Next ( x , 0 ); int next = Next ( x , 1 ); Splay ( last , 0 ); Splay ( next , last ); int del = tree[next].ch[0]; if ( tree[del].cnt &gt; 1 ) &#123; tree[del].cnt--; Splay ( del , 0 ); &#125; else tree[next].ch[0] = 0; return;&#125;int kth ( int x ) &#123; int cur = root; if ( tree[cur].size &lt; x ) return 0; while ( 1 ) &#123; int y = tree[cur].ch[0]; if ( x &gt; tree[y].size + tree[cur].cnt ) &#123; x -= tree[y].size + tree[cur].cnt; cur = tree[cur].ch[1]; &#125; else if ( tree[y].size &gt;= x ) cur = y; else return tree[cur].val; &#125;&#125;int main ( void ) &#123; n = read (); insert ( 2147483647 ); insert ( -2147483647 ); while ( n-- ) &#123; int opt = read (); if ( opt == 1 ) &#123; int x = read (); insert ( x ); &#125; else if ( opt == 2 ) &#123; int x = read (); Delete ( x ); &#125; else if ( opt == 3 ) &#123; int x = read (); Find ( x ); printf ( "%d\n" , tree[tree[root].ch[0]].size ); &#125; else if ( opt == 4 ) &#123; int x = read (); printf ( "%d\n" , kth ( x + 1 ) ); &#125; else if ( opt == 5 ) &#123; int x = read (); printf ( "%d\n" , tree[Next ( x , 0 )].val ); &#125; else if ( opt == 6 ) &#123; int x = read (); printf ( "%d\n" , tree[Next ( x , 1 )].val ); &#125; &#125; return 0;&#125; å› ä¸ºçŸ¥é“äº†è‡ªå·±æ˜¯å¤šä¹ˆçš„èœ,æ‰€ä»¥æ‰è¦æ›´åŠ åŠªåŠ›åŽ»è¿½æ±‚é‚£ä¸ªæ°¸è¿œä¹Ÿä¸å¯èƒ½å®žçŽ°çš„æ¢¦æƒ³]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeStyle</tag>
      </tags>
  </entry>
</search>
