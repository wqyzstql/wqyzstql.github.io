<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多项式学习笔记]]></title>
    <url>%2F2020%2F11%2F02%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[开始跳楼了 多项式部分简介定义简介一个以$x$为变量的定义在代数域$F$上,将函数$A(x)$表示为: A(x)=\sum_{j=0}^{n-1}a_jx^j其中我们称$a_0,a_1,\dots,a_{n-1}$为系数,如果一个多项式的最高次的非零系数为$a_k$,那么称$A(x)$的次数为$k$,记为$degree(A)=k$,任何一个大于该多项式次数的整数都是这个多项式的次数界. 多项式的表示 系数表达 :对一个次数界为$n$的多项式$A(x)=\sum_{j=0}^{n-1}a_jx^j$而言,其系数表达是一个由系数组成的向量$\text{a}=(a_0,a_1,\dots,a_{n-1})$.在给定系数求值时,采用霍纳法则(秦九邵算法)可以实现在$O(n)$的复杂度内完成求值运算. A(x_0)=a_0+x_0(a_1+x_0(a_2+\dots+x_0(a_{n-1})))扩充:霍纳法则: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265 void Horner ()&#123; for(int i=n-1;i&gt;=1;i--) ans*=x,ans+=a[i]; &#125; ``` 2. 点值表达 一个次数界为$n$的多项式$A(x)$的点值表达就是一个由$n$个点值对组成的集合 $$\&#123;(x_0,y_0),(x_1,y_1),\dots,(x_&#123;n-1&#125;,y_&#123;n-1&#125;)\&#125;$$ 使得对$k=0,1,\dots,n-1$,所有$x_k$各不相同 $$y_k=A(x_k)=a_0x_k+a_1x+k+\dots+a_&#123;n-1&#125;x_k$$ 则$A(x)=\sum_&#123;j=0&#125;^&#123;n-1&#125;A(x_j)$ ## 多项式的乘法 这是多项式**最核心**的操作 即给定两个多项式$f(x)$和$g(x)$ $$f(x)=a_0+a_1x+a_2x^2+\dots+a_nx^&#123;n&#125;$$ $$g(x)=b_0+b_1x+b_2x^2+\dots+b_mx^m$$ 要计算多项式$Q(x)=f(x).g(x):$ $$Q(x)=\sum_&#123;i=0&#125;^n\sum_&#123;j=0&#125;^ma_ib_jx_&#123;i+j&#125;=c_0+c_1x+\dots+c_&#123;n+m&#125;x^&#123;n+m&#125;$$ 常规系数表达的计算是$O(n^2)$的,可以通过快速傅里叶变换在$O(nlogn)$下计算## 多项式的逆元 对于多项式$f(x)$,若存在$g(x)$满足: $$f(x)g(x)\equiv1 \ (mod \ x^n)$$ $$degree(x) \leq degree(f) $$ 则称$g(x)$为$f(x)$在模$x^n$下的逆元,记作$f^&#123;-1&#125;(x)$ ## 多项式的余数和商 对于多项式$f(x),g(x)$ ,存在**唯一**的$Q(x)$满足: $$f(x)=Q(x)g(x)+R(x)$$ $$degree(Q)=degree(f)-degree(g)$$ $$degree(R) &lt; degree(g) $$ 则称$Q(x)$为$f(x)$除$g(x)$的商,$R(x)$为$f(x)$除$g(x)$的余数.亦可记作 $$f(x)\equiv R(x) \ (mod \ g(x))$$ ## 多项式的对数函数与指数函数 1. 对数 对于一个多项式 $f(x),$ 可以将其对数函数看作其与麦克劳林级数的复合: $$ \begin&#123;aligned&#125; \ln (1-f(x)) &amp;=-\sum_&#123;i=1&#125;^&#123;+\infty&#125; \frac&#123;f^&#123;i&#125;(x)&#125;&#123;i&#125; \\ \ln (1+f(x))=&amp; \sum_&#123;i=1&#125;^&#123;+\infty&#125; \frac&#123;(-1)^&#123;i-1&#125; f^&#123;i&#125;(x)&#125;&#123;i&#125; \end&#123;aligned&#125; $$ 注意这里常数项必须为$1$,也就是说求对数的多项式必须满足 $A(x)=1+\sum_&#123;i=1&#125;^&#123;\infty&#125; a_&#123;i&#125; z^&#123;i&#125;$ 。2. 多项式exp 其指数函数同样可以这样定义： $$ \exp f(x)=e^&#123;f(x)&#125;=\sum_&#123;i=0&#125;^&#123;+\infty&#125; \frac&#123;f^&#123;i&#125;(x)&#125;&#123;i !&#125; $$ 看到这种 $e^&#123;A(x)&#125;$ 的指数形式显然非常不好处理, 于是采用等式两边同时 $\ln$ 的方式。设 $F(x)=e^&#123;f(x)&#125;,$ 则有 $\ln F(x)-f(x) \equiv 0 \quad\left(\bmod x^&#123;n&#125;\right)$ 。构造函数 $G(F(x))=\ln F(x)-f(x),$ 牛顿迭代即可。 3. 多项式的$k$次幂 注意这里的$k$可以是一个实数,对于$k$的整数部分显然可以直接用快速幂优化,而对于$k$的小数部分,我们可以运用$A^k(x)=e^&#123;k \ ln A(x)&#125;$进行求解.事实上当 $A(x)$的常数项不为$1$的时候我们是可以进行这样的运算的,可以直接把$C^&#123;-1&#125;$乘到前面去 $\left(C^&#123;-1&#125;\right.$ 为 $A(x)$ 的常数项的逆$)$，于是可以用 $A^&#123;k&#125;(x)=C^&#123;k&#125;\left(C^&#123;-1&#125; A\right)^&#123;k&#125;(x)=C^&#123;k&#125; e^&#123;k \ln \left(C^&#123;-1&#125; A(x)\right)&#125;$ 来进行求解。但是注意到如果仅仅是求In的 话是不能乘上逆元的, 因为把 $\ln \left(C^&#123;-1&#125; A(x)\right)$ 拆开来之后变成了 $\ln C^&#123;-1&#125;+\ln A(x),$ 而$\ln C^&#123;-1&#125;$ 本身就是没有定义的。### 多项式的对数一般求法 我们设$f(x)$是一个平静的多项式,我们要求$ln[f(x)]$ 则我们设$g(x)=ln[f(x)]$,那么$g^&#123;\prime&#125;(x)=\frac&#123;f^&#123;\prime&#125;(x)&#125;&#123;f(x)&#125;$,$\ln g(x)=\int \frac&#123;g^&#123;\prime&#125;(x)&#125;&#123;g(x)&#125; \mathrm&#123;d&#125; x$### 麦克劳林级数 1. 基本介绍: 对于一个给定的函数 $f(x),$ 如果能找到一个幂级数 $\sum_&#123;n=0&#125;^&#123;\infty&#125; a_&#123;n&#125; x^&#123;n&#125;,$ 使 $$f(x)=\sum_&#123;n=0&#125;^&#123;\infty&#125; a_&#123;n&#125; x^&#123;n&#125;=a_&#123;0&#125;+a_&#123;1&#125; x+a_&#123;2&#125; x^&#123;2&#125;+\ldots+a_&#123;n&#125; x^&#123;n&#125;+\ldots(-R&lt;x&lt;R) \ (1) $$ 成立，则称$f(x)$可展开成$x$的幂级数。 $$\begin&#123;array&#125;&#123;c&#125;f^&#123;\prime&#125;(x)=a_&#123;1&#125;+2 a_&#123;2&#125; x+3 a_&#123;3&#125; x^&#123;2&#125;+\ldots+n a_&#123;n&#125; x^&#123;n-1&#125;+\ldots \\f^&#123;\prime \prime&#125;(x)=2 a_&#123;2&#125;+3 \times 2 a_&#123;3&#125; x+\ldots+n(n-1) a_&#123;n&#125; x^&#123;n-2&#125;+\ldots \\f^&#123;(n)&#125;(x)=n ! a_&#123;n&#125;+(n+1) ! a_&#123;n+1&#125; x+\frac&#123;(n+2) !&#125;&#123;2&#125; a_&#123;n+2&#125; x^&#123;2&#125;+\ldots\end&#123;array&#125;$$ 把$x=0$代入式$(1)$及上述各式，得 $$ f(0)=a_&#123;0&#125;, f^&#123;\prime&#125;(0)=a_&#123;1&#125;, f^&#123;\prime \prime&#125;(0)=2 ! a_&#123;2&#125;, \ldots, f^&#123;(n)&#125;(0)=n ! a_&#123;n&#125;, \ldots $$ 于是 $$ a_&#123;0&#125;=f(0), a_&#123;1&#125;=\frac&#123;f^&#123;\prime&#125;(0)&#125;&#123;1 !&#125;, a_&#123;2&#125;=\frac&#123;f^&#123;\prime \prime&#125;(0)&#125;&#123;2 !&#125;, \ldots, a_&#123;n&#125;=\frac&#123;f^&#123;(n)&#125;(0)&#125;&#123;n !&#125;, \ldots $$ 把它们代回式$(1)$，得 $$ f(x)=f(0)+\frac&#123;f^&#123;\prime&#125;(0)&#125;&#123;1 !&#125; x+\frac&#123;f^&#123;\prime \prime&#125;(0)&#125;&#123;2 !&#125; x^&#123;2&#125;+\ldots+\frac&#123;f^&#123;(n)&#125;(0)&#125;&#123;n !&#125; x^&#123;n&#125;+\ldots(-R&lt;x&lt;R) \ (2)$$ 通常称式$(2)$为$f(x)$的麦克劳林展开式或$f(x)$在$x=0$处的幂级数展开式。式$(2)$中等号右端的级数称为$f(x)$的麦克劳林级数或$f(x)$展开成$x$的幂级数。 可见,当$a_n=\frac&#123;1&#125;&#123;n!&#125;f^&#123;(n)&#125;(0)$求得系数的幂级数在它的收敛域内的和函数就是$f(x)$ 2. 麦克劳林级数展开的条件及方法 定理$1$: 设函数$f(x)$的麦克劳林级数的收敛半径$R&gt;0$，当$n→∞$时，如果函数$f(x)$在任一固定点$x$处的$n$阶导数$f^&#123;(n)&#125;(x)$有界，则函数$f(x)$在收敛区间$(-R，R)$内能展开成麦克劳林级数.即 $$ f(x)=\sum_&#123;n=0&#125;^&#123;\infty&#125; \frac&#123;f^&#123;(n)&#125;(0)&#125;&#123;n !&#125; x^&#123;n&#125;(-R&lt;x&lt;R) $$ 把函数$f(x)$展开成幂级数，有直接展开法和间接展开法 #### 直接展开法 利用麦克劳林级数公式将函数$f(x)$展开成$x$的幂级数的方法，称为直接展开法。步骤可归纳为： 1. 求出 $f(x)$ 的各阶导数 $f^&#123;\prime&#125;(x), f^&#123;\prime \prime&#125;(x), \ldots, f^&#123;(n)&#125;(x), \ldots,$ 令 $x=0$ 得 $f(0), f^&#123;\prime&#125;(0), f^&#123;\prime \prime&#125;(0), \ldots, f^&#123;(n)&#125;(0), \ldots$ 2. 写出$f(x)$的麦克劳林级数并求出收敛半径$R$ $$ f(0)+\frac&#123;f^&#123;\prime&#125;(0)&#125;&#123;1 !&#125; x+\frac&#123;f^&#123;\prime \prime&#125;(0)&#125;&#123;2 !&#125; x^&#123;2&#125;+\ldots+\frac&#123;f^&#123;(n)&#125;(0)&#125;&#123;n !&#125; x^&#123;n&#125;+\ldots $$ #### 间接展开法 利用麦克劳林级数展开函数，需要求高阶导数，比较麻烦，如果能利用已知函数的展开式，根据幂级数在收敛域内的性质，将所给的函数展开成幂级数，这种方法称为间接展开法 ## 多项式的多点求值和插值 多项式的多点求值 $(Multi-point evaluation)$ 即给出一个多项式 $f(x)$ 和 $n$ 个点 $x_&#123;1&#125;, x_&#123;2&#125;, \ldots, x_&#123;n&#125;$ 求$$f\left(x_&#123;1&#125;\right), f\left(x_&#123;2&#125;\right), \ldots, f\left(x_&#123;n&#125;\right)$$多项式的插值 $(Interpolation)$ 即给出 $n+1$ 个点$$\&#123;\left(x_&#123;0&#125;, y_&#123;0&#125;\right),\left(x_&#123;1&#125;, y_&#123;1&#125;\right), \ldots,\left(x_&#123;n&#125;, y_&#123;n&#125;\right)\&#125;$$求一个 $n$ 次多项式 $f(x)$ 使得这 $n+1$ 个点都在 $f(x)$ 上。这两种操作的实质就是将多项式在 系数表示 和 点值表示间转化。# 拉格朗日插值 [这里是题目传送门](https://www.luogu.com.cn/problem/P4781) ## 题目大意 给出$n$个点$P(x_i,y_i)$,将过这$n$个点的最多$n-1$次多项式记为$f(x)$,求$f(k)$的值. ## 方法1:牛顿插值法 1. 差商的定义： 函数$f(x)$在两个互异点$x_i,x_j$处的一阶差商定义为： $$ f\left[x_&#123;i&#125;, x_&#123;j&#125;\right]=\frac&#123;f\left(x_&#123;i&#125;\right)-f\left(x_&#123;j&#125;\right)&#125;&#123;x_&#123;i&#125;-x_&#123;j&#125;&#125;\left(i \neq j, x_&#123;i&#125; \neq x_&#123;j&#125;\right) $$ 二阶差商: $$ f\left[x_&#123;i&#125;, x_&#123;j&#125;, x_&#123;k&#125;\right]=\frac&#123;f\left[x_&#123;i&#125;, x_&#123;j&#125;\right]-f\left[x_&#123;j&#125;, x_&#123;k&#125;\right]&#125;&#123;x_&#123;i&#125;-x_&#123;k&#125;&#125;(i \neq k) $$ $k+1$阶差商: $$ \begin&#123;aligned&#125; f\left[x_&#123;0&#125;, \ldots, x_&#123;k+1&#125;\right]=\frac&#123;f\left[x_&#123;0&#125;, x_&#123;1&#125;, \ldots x_&#123;k&#125;\right]-f\left[x_&#123;1&#125;, \ldots, x_&#123;k&#125;, x_&#123;k+1&#125;\right]&#125;&#123;x_&#123;0&#125;-x_&#123;k+1&#125;&#125;=\frac&#123;f\left[x_&#123;0&#125;, \ldots, x_&#123;k-1&#125;, x_&#123;k&#125;\right]-f\left[x_&#123;0&#125;, \ldots, x_&#123;k-1&#125;, x_&#123;k+1&#125;\right]&#125;&#123;x_&#123;k&#125;-x_&#123;k+1&#125;&#125; \end&#123;aligned&#125; $$ 2. 差商的性质 ([参考连接](https://blog.csdn.net/littlely_ll/article/details/71107092)) 1. $k$阶差商可以表示为函数值$f(x_0),f(x_1),\dots,f(x_k)$的线性组合,即 $$ f[x_0,x_1,\dots,x_k]=\sum_&#123;j=0&#125;^&#123;k&#125; \frac&#123;f\left(x_&#123;j&#125;\right)&#125;&#123;\prod_&#123;i=0,i\not =&#123;j&#125;&#125;^&#123;k&#125;\left(x_&#123;j&#125;-x_&#123;i&#125;\right)&#125; $$ 差商具有对称性,即差商与节点的排列顺序无关. 2. 若函数$f(x)$在包含节点区间$[a,b]$上存在$k$ 阶导数,则$k$阶差商与导数的关系为 $$ f[x_0,x_1,\dots,x_k]=\frac&#123;f^&#123;(k)&#125;(\xi)&#125;&#123;k!&#125;,\xi \in [a,b] $$ 即$k$次多项式的$k$阶差商为常数,低于$k$次多项式的差商为$0$(推了一会柿子之后发现对于多项式$A(x)=a_0+a_1x^1+\dots+a_kx^k$,他的$k$阶差商就是$a_k$) 3. 牛顿插值多项式 1. 牛顿插值多项式的推导 $$f[x,x_0]=\frac&#123;f(x)-f(x_0)&#125;&#123;x-x_0&#125;\Rightarrow f(x)=f\left(x_&#123;0&#125;\right)+f\left[x, x_&#123;0&#125;\right]\left(x-x_&#123;0&#125;\right) \ (a)$$ $$f[x,x_0,x_1]=\frac&#123;f[x,x_0]-f[x_0,x_1]&#125;&#123;x-x_1&#125;\Rightarrow f[x,x_0]=f[x_0,x_1]+f[x,x_0,x_1](x-x_1) \ (b)$$ $$f[x,x_0,x_1,x_2] = \frac&#123;f[x,x_0,x_1]-f[x_0,x_1,x_2]&#125;&#123;x-x_2&#125;\Rightarrow f[x,x_0,x_1]=f[x_0,x_1,x_2]+f[x,x_0,x_1,x_2](x-x_2) \ (c)$$ $$\dots$$ $$f[x,x_0,\dots,x_n]=\frac&#123;f[x,x_0,\dots,x_&#123;n-1&#125;]-f[x_0,x_1,\dots,x_n]&#125;&#123;x-x_n&#125;\Rightarrow f[x,x_0,\dots,x_&#123;n-1&#125;]=f[x_0,x_1,\dots,x_n]+f[x,x_0,x_1,\dots,x_n](x-x_n) \ (d)$$ 然后我们由$a,b,c,d$柿子可以得到 $$f(x)=f\left(x_&#123;0&#125;\right)+f\left[x, x_&#123;0&#125;\right]\left(x-x_&#123;0&#125;\right)$$ $$f[x,x_0]=f[x_0,x_1]+f[x,x_0,x_1](x-x_1)$$ $$f[x,x_0,x_1]=f[x_0,x_1,x_2]+f[x,x_0,x_1,x_2](x-x_2)$$ $$\dots$$ $$f[x,x_0,\dots,x_&#123;n-1&#125;]=f[x_0,x_1,\dots,x_n]+f[x,x_0,x_1,\dots,x_n](x-x_n)$$ 我们从上到下把柿子分别标为$(1),(2),\dots,(n)$柿,然后我们发现 $$(1)+(x-x_0) \times (2) +(x-x_0) \times (x-x_1) \times ( 3 ) + \dots + (x-x_0)\times \dots \times (x-x_&#123;n-1&#125;) \times (n + 1)$$ $$\Rightarrow f(x)=f(x_0)+f[x_0,x_1](x-x_0)+f[x_0,x_1,x_2](x-x_0)(x-x_1)+\dots+f[x_0,\dots,x_n](x-x_0)\dots(x-x_&#123;n-1&#125;)$$ $$+f\left[x, x_&#123;0&#125;, \ldots, x_&#123;n&#125;\right]\left(x-x_&#123;0&#125;\right) \ldots\left(x-x_&#123;n-1&#125;\right)\left(x-x_&#123;n&#125;\right)$$ 然后我们把这个大柿子的上边的部分称为牛顿插值公式$N_n(x)$,下边的部分称为插值余项$R_n(x)$(懒得写latex了直接扔图了) ![1e37ef766fec2a86f6d42d8cffd06ff4](https://picbeddd.oss-cn-qingdao.aliyuncs.com/img/1e37ef766fec2a86f6d42d8cffd06ff4.png) 2. 求值 说了这么多,我们来考虑怎么使用这个玩意求多项式的插值.我们发现,对于给定的$n$个点,我们可以在$O(n^2)$的复杂度内递推出他们的差商.而对于求值来说,我们发现也可以在$O(n^2)$的时间复杂度内求出.即首先要递推出$(x-x_0)\times(x-x_1)\times \dots \times (x-x_n)$然后再用我们之前预处理的差商相乘再求和即可. 3. 代码 ```cpp #include &lt;iostream&gt; #include &lt;cstdlib&gt; #define int long long #define HA 998244353 using namespace std; int count , num; int dataX[2005]; int lovivd[2005][2005]; int ksm ( int x , int y ) &#123; long long tmp = 1; while ( y ) &#123; if ( y &amp; 1 ) tmp = 1ll * tmp * x % HA; x = 1ll * x * x % HA; y &gt;&gt;= 1; &#125; return tmp % HA; &#125; void init()&#123; double x , y; cin &gt;&gt; count &gt;&gt; num; for ( int i = 0 ; i &lt; count ; i++ ) &#123; cin &gt;&gt; x &gt;&gt; y; dataX[i] = x; lovivd[i][0] = y; &#125; return; &#125; void pre () &#123; int dis = 1; for ( int i = 0 ; i &lt; count ; i++ ) &#123; for ( int j = i ; j &lt; count ; j++ ) &#123; int tmp = ( ( lovivd[j + 1][i] - lovivd[j][i] ) * ksm ( dataX[j+1] - dataX[j + 1 - dis] , HA - 2 ) )%HA; lovivd[j + 1][i + 1] = tmp; &#125; dis += 1; &#125; return; &#125; int work() &#123; long long calcValue = 0,temp = 1; for ( int i = 0 ; i &lt; count ; i++ ) &#123; temp = 1; for ( int j = 0 ; j &lt; i ; j++ ) //计算(X-X0)*(X-X1).....*(X-Xn-1) temp = 1ll * temp * ( num - dataX[j] + HA ) % HA; //计算f(X0,X1,....,Xn)*(X-X0)*(X-X1).....*(X-Xn-1) temp = 1ll * temp % HA * lovivd[i][i] % HA; //计算f(X0,X1,....,Xn)*(X-X0)*(X-X1).....*(X-Xn-1)的和 calcValue = ( calcValue + temp + HA ) % HA; &#125; return calcValue; &#125; signed main()&#123; init(); pre(); cout &lt;&lt; work () &lt;&lt;endl; return 0; &#125; 方法2:待定系数法快速傅里叶变换(FFT)因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈论训练]]></title>
    <url>%2F2020%2F10%2F22%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[感觉更多的还是要靠思维…. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数分训练]]></title>
    <url>%2F2020%2F10%2F19%2F%E6%95%B0%E5%88%86%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[啥都不会啊QAQ 1.实数集与函数1.实数1.1.1设$a,b,c \in R^+$,证明$|\sqrt{a^2+b^2} - \sqrt{a^2+c^2}| \leq |b - c|$ 证明:首先两边同时乘以$|\sqrt{a^2+b^2}+\sqrt{a^2+c^2}|$后有 |a^2+b^2-a^2-c^2| \leq |b - c| \times |\sqrt{a^2+b^2}+\sqrt{a^2+c^2}|化简之后可以得到 |b + c| \leq |\sqrt{a^2+b^2}+\sqrt{a^2+c^2}|又$|b + c| \leq |b| + |c|$ ,则只需证明$|b| + |c| \leq |\sqrt{a^2+b^2}+\sqrt{a^2+c^2}|$ 又$\sqrt{x}$显然大于$0$,则$\sqrt{a^2+b^2}$显然大于$|b|$,同理,$\sqrt{a^2+c^2}$显然大于$|c|$ 得证. $QED$ 下面我们来讨论这个柿子的几何意义 我们将这个柿子做一个简简单单的变换 \sqrt{a^2+b^2} = \sqrt{(a-0)^2+(b-0)^2 }即这个柿子可以看成点$(a,b)$到原点的距离,同理,后边的那个柿子可以看成点$(a,c)$到原点的距离.那么那个大柿子就可以看作两点到原点距离之差,而我们又发现这两点之间的距离就等于$|b-c|$.而这两个点与原点又可以构成三角形.所以几何意义显然 三角形两边之差小于第三边. 1.1.2不会了xd 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ABC178]]></title>
    <url>%2F2020%2F10%2F09%2FABC178%2F</url>
    <content type="text"><![CDATA[ABC只会E人从来都是笑着面对生活 D.Redistribution 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ABC179]]></title>
    <url>%2F2020%2F10%2F08%2FARC179%2F</url>
    <content type="text"><![CDATA[既然是ABC就只看DEF了…. D.- Leaping Tak 我们用推的方法可以发现我们对于每个位置$i$,可以枚举每个$i$能到的位置然后$dp$转移.然后发现对于每次转移,等价与将$k$段连续区间的$dp$值加一个相同的数.然后我们最后要的就是$dp_n$.对于这种区间修改单点求值的问题我们显然可以用树状数组来维护.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 2e5 + 10;const int HA = 998244353;int n , k;long long tree[N];struct Seq &#123; int ll , rr;&#125; se[15];inline int lowbit ( int x ) &#123; return x &amp; -x;&#125;inline void add ( int pos , int v ) &#123; while ( pos &lt;= n ) &#123; tree[pos] = ( tree[pos] + v + HA ) % HA; pos += lowbit ( pos ); &#125; return;&#125;inline long long query ( int pos ) &#123; long long tmp = 0; while ( pos ) &#123; tmp = ( tmp + tree[pos] + HA ) % HA; pos -= lowbit ( pos ); &#125; return tmp % HA;&#125;int main ( void ) &#123; n = read () , k = read (); for ( int i = 1 ; i &lt;= k ; i++ ) &#123; se[i].ll = read (); se[i].rr = read (); &#125; tree[1] = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= k ; j++ ) &#123; int l = i + se[j].ll , r = i + se[j].rr; add ( l , query ( i ) ); add ( r + 1 , -query ( i ) ); &#125; &#125; // for ( int i = 1 ; i &lt;= n ; i++ ) // printf ( "%d " , tree[i] ); printf ( "%lld\n" , query ( n ) % HA ); return 0;&#125; E.Sequence Sum我们发现$n$的值很大,所以不能直接去算.但是我们发现$M$的值只有$1e5$的级别.所以我们由抽屉原理可知,我们至多只需要枚举$m+1$个数字,就一定可以找到一个和之前重复的数字,而假设我们现在枚举到的重复的位置为$j$,这个数字之前出现过的位置为$i$,那么剩余的数字一定都是位置$i$到位置$j$的数字的重复. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std; #define rep(i, a, b) for(int i = a; i &lt; (b); ++i)#define all(x) begin(x), end(x)#define sz(x) (int)(x).size()typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi; const ll MX = 1e6; ll n, x, m;bool inCycle;int endi, starti, cstart;ll sum, cycle[MX];set&lt;ll&gt; found; int main() &#123; cin.tie(0)-&gt;sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; x &gt;&gt; m; cycle[0] = x; found.insert(x); rep(i, 1, MX) &#123; ll nxt = cycle[i - 1] * cycle[i - 1] % m; if (found.find(nxt) != found.end()) &#123; cstart = nxt; endi = i - 1; break; &#125; else &#123; cycle[i] = nxt; found.insert(nxt); &#125; &#125; rep(i, 0, endi + 1) &#123; if (cycle[i] == cstart) &#123; starti = i; break; &#125; else if (n) &#123; sum += cycle[i]; --n; &#125; &#125; int cycleLen = endi - starti + 1; rep(i, 0, cycleLen) sum += max(0ll, (ll)ceil((n - i) / (long double)cycleLen) * cycle[i + starti]); cout &lt;&lt; sum;&#125; F. Simplified Reversi 发现$n$和$q$都是$2 \times 10^5$级别,所以直接模拟显然不太核里… 发现每一次操作都最多只会删掉一行最靠左上的部分.我们设现在的最左上方的长宽分别为$c$和$k$.刚开始的时候$c=k=n-2$,我们进行任何一次操作之后黑色棋子的个数都会减掉$n-2$.假设我们进行了$1$操作在坐标为$(1,xx)$的位置,那么我们在(1,xx)以后的位置再进行一次一操作的话,黑色棋子的个数都一定会只减少$n-2$.所以我们对于列的情况,对于刚开始的$n-2$列,我们把这$n-2$列的值都设为$n-2$,表示对这$n-2$列操作时,都会将黑色棋子的个数减少$$n-2$.然后在进行某一次$2$操作时,假设进行的$2$操作是第$yy$行,那么我们发现,从第$yy$行往下的所有白棋子都不会再被$1$操作所染白. 而从左到第一个$1$操作的所有列上再进行$1$操作都会只染白$[2,yy)$这个区间的棋子 那么解法就很显然了:我们对于行和列,分别去维护$1$和$2$操作能减少的黑色棋子个数即可. 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=2e5+5;int n,x,y,q,op,k;int r[N],c[N];int main ( void ) &#123; cin&gt;&gt;n&gt;&gt;q; x=y=n; ll ans=(n-2LL)*(n-2LL); while ( q-- ) &#123; cin&gt;&gt;op&gt;&gt;k; if(op==1) &#123; if (k &lt; y) &#123; ans -= x - 2; while (y &gt; k) c[y--] = x - 2; &#125; else ans -= c[k]; &#125; else&#123; if (k &lt; x) &#123; ans -= y - 2; while (x &gt; k) r[x--] = y - 2; &#125; else ans -= r[k]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[209191110模拟赛题解]]></title>
    <url>%2F2019%2F11%2F11%2F209191110%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$FPX$牛逼! kyouko$70$分做法:我们发现我们可以枚举每个数字,然后统计这个数字的$i$次方.然后随便开个$set$去个重之类的就$70$了.而对于$100$分的做法,我们考虑枚举$k$次方中有多少数字在$[1….n]$之内.首先发现这个东西是可以二分的.然后我们就能二分出来对答案有多少贡献.但是发现很显然这个东西会算重复,我们考虑怎么去重,我们发现,如果一个次方数$k$,它有平方因子的话,那么它显然可以不被统计进去,而如果一个数有可以被分解成奇数个数的乘积,那么显然这奇数个数都会把他算进去.而我们发现这个容斥系数就是莫比乌斯函数,所以直接容斥即可.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#ifdef unix#define LL "%lld"#else#define LL "%I64d"#endiflong long n;int mu(int x)&#123; int res=-1; for (int a=2;a*a&lt;=x;a++) if (x%a==0)&#123; int cnt=0; while (x%a==0)&#123; x/=a; cnt++; &#125; if (cnt&gt;1) return 0; res=-res; &#125; if (x!=1) res=-res; return res;&#125;int main()&#123; freopen("kyouko.in","r",stdin); freopen("kyouko.out","w",stdout); scanf(LL,&amp;n); long long ans=1; for (int a=2;;a++)&#123; int l=1,r=1000000001; while (l+1!=r)&#123; int m=(l+r)&gt;&gt;1; if (pow((double)m,a)&lt;=(double)n) l=m; else r=m; &#125; ans+=mu(a)*(l-1); if (l==1) break; &#125; printf(LL "\n",ans); return 0;&#125; nanami发现可以二分这个最小值,然后考虑怎么$check$.我们发现对于我们当前二分的这个$x$,如果有$high_i$小于$x$的话,那么我们为了让这个达到我们二分的值,我们就必须使这个点被浇水浇到$x$那么高.但是因为如果这个点之前没有比$x$小的点的话,为了向后延申更多被浇水浇到的位置,显然从$x$这个位置开始浇水更优.然后我们模拟这个浇水的过程,不难发现如果暴力修改的话那么时间复杂度最坏是$O(n^2)$的,显然不行.但是我们想一下我们要做什么处理,我们要把单点求出一个数,然后进行区间加.显然这是树状数组可以解决的问题.所以我们可以用树状数组来优化这个暴力的过程,时间复杂度为$O(n \times log_2n \times log_2V)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define int long longinline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;using namespace std;const int N = 1e5 + 10;int n , m , l;int high[N] , nep[N] , tmp[N];int tree[N];inline int lowbit ( int x ) &#123; return x &amp; -x;&#125;inline void add ( int x , int pos ) &#123; while ( pos &lt;= n ) &#123; tree[pos] += x; pos += lowbit ( pos ); &#125; return;&#125;inline int query ( int pos ) &#123; int res = 0; while ( pos ) &#123; res += tree[pos]; pos -= lowbit ( pos ); &#125; return res;&#125;inline bool check ( int x ) &#123; memset ( nep , 0 , sizeof ( nep ) ); memset ( tree , 0 , sizeof ( tree ) ); int las = 0; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; high[i] = tmp[i]; add ( high[i] - las , i ); las = high[i]; &#125; int use = 0; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int hhh = query ( i ); if ( hhh &lt; x ) &#123; nep[i] = x - hhh; use += nep[i]; if ( use &gt; m ) return false; add ( nep[i] , i ); add ( -nep[i] , i + l ); &#125; &#125; if ( use &lt;= m ) return true; else return false;&#125;signed main ( void ) &#123; freopen ( "nanami.in" , "r" , stdin ); freopen ( "nanami.out" , "w" , stdout ); n = read () , m = read () , l = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; high[i] = read (); tmp[i] = high[i]; &#125; int l = 0 , r = 1e9 + 7 , ans; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( check ( mid ) ) &#123; l = mid + 1; ans = mid; &#125; else r = mid - 1; &#125; printf ( "%lld\n" , ans ); return 0;&#125; chisa能直接暴力爆过去的题为什么要想正解. 首先这道题的正解是从前缀做一遍背包,再从后缀做一遍背包,然后对于不能选物品$i$的情况,我们从$f_{1…..i-1,j}$中取一个$max$再从$g_{i+1….n,j}$中取一个$max$即为答案.但是你看数据范围只有$1000$说明暴力也是可以做的嘛.我们设$ans_{i,j}$表示我们在不用$i$这个物品时,最多用$j$的空间最多能拿多少价值的物品.显然$ans_{i,j}=max(ans_{i,j-1},ff_{i,j}$.其中$ff$是我们在不选择第$i$件物品时,填满$j$的空间最多的价值.那么我们直接预处理是跑满$O(n^3)$的.有个小的技巧就是我们发现我们每次不选的物品移动时(假设是$ignore$),那么我们在枚举$i$时不用从$1$开始,直接从$ignore-1$开始即可.这样可以有一个$\frac{1}{2}$的常数.输出优化有奇效.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;struct ios &#123; inline char gc()&#123; static const int IN_LEN=1&lt;&lt;18|1; static char buf[IN_LEN],*s,*t; return (s==t)&amp;&amp;(t=(s=buf)+fread(buf,1,IN_LEN,stdin)),s==t?-1:*s++; &#125; template &lt;typename _Tp&gt; inline ios &amp; operator &gt;&gt; (_Tp&amp;x)&#123; static char ch,sgn; ch = gc(), sgn = 0; for(;!isdigit(ch);ch=gc())&#123;if(ch==-1)return *this;sgn|=ch=='-';&#125; for(x=0;isdigit(ch);ch=gc())x=x*10+(ch^'0'); sgn&amp;&amp;(x=-x); return *this; &#125;&#125; io;using namespace std;const int N = 1005;int ff[N][N];int f[N][N] , ans[N][N];int n , m;struct Node &#123; int v , w;&#125; nd[N];inline void writeln ( int x ) &#123; if ( x / 10 &gt; 0 ) writeln ( x / 10 ); char s = x % 10 + '0'; putchar ( s );&#125;int main ( void ) &#123; freopen ( "chisa.in" , "r" , stdin ); freopen ( "chisa.out" , "w" , stdout ); io &gt;&gt; n; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; io &gt;&gt; nd[i].v &gt;&gt; nd[i].w; int five; io &gt;&gt; five; &#125; for ( int ignore = 1 ; ignore &lt;= n ; ignore++ ) &#123; for ( int i = max ( 1 , ignore - 1 ) ; i &lt;= n ; i++ ) &#123; for ( int j = 0 ; j &lt;= 1000 ; j++ ) &#123; f[i][j] = f[i - 1][j]; if ( j - nd[i].v &gt;= 0 &amp;&amp; i != ignore ) f[i][j] = max ( f[i][j] , f[i - 1][j - nd[i].v] + nd[i].w ); ff[ignore][j] = max ( ff[ignore][j] , f[i][j] ); &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 1 ; j &lt;= 1000 ; j++ ) ans[i][j] = max ( ans[i][j - 1] , ff[i][j] ); io &gt;&gt; m; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int vp , MaxV; io &gt;&gt; vp &gt;&gt; MaxV; vp++; writeln ( ans[vp][MaxV] ); puts ( "" ); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形DP小结]]></title>
    <url>%2F2019%2F11%2F10%2F%E6%A0%91%E5%BD%A2DP%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[我真的菜死了啊/(ㄒoㄒ)/~~ 没有上司的舞会传送门首先一个显然的状态就是一个节点和他的父亲节点不能同时被选中,又因为我们进行树形$DP$的时候合并是以每个点为根的子树合并,所以只能从下向上合并.所以我们设$f_{i,j}$表示以$i$为根的节点,其中$j$代表这个节点的子节点选了/没选时,最多的欢乐值是多少.那么转移的时候,我们枚举每个非叶节点的子节点$k$,然后转移比较显然.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define ll long long#define MP make_pair#define max(a,b) (a&gt;b)?a:b#define F(i,a,b) for(int i=a;i&lt;=b;i++)#define D(i,a,b) for(int i=a;i&gt;=b;i--)#define PB push_backinline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 6005;int n , t , root;int val[N] , degree[N] , head[N];int f[N][2];struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 2];inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;void dfs ( int x , int fa ) &#123; f[x][0] = 0; f[x][1] = val[x]; for ( int i = head[x] ; i ; i = e[i].next ) &#123; int y = e[i].to; if ( y == fa ) continue; dfs ( y , x ); f[x][0] += max ( f[y][0] , f[y][1] ); f[x][1] += f[y][0]; &#125; return;&#125;int main ( void ) &#123; n = read (); F ( i , 1 , n ) val[i] = read (); int x = read () , y = read (); while ( x &amp;&amp; y ) &#123; add ( y , x ); degree[x]++; x = read () , y = read (); &#125; F ( i , 1 , n ) if ( !degree[i] ) &#123; root = i; break; &#125; dfs ( root , 0 ); printf ( "%d\n" , max ( f[root][0] , f[root][1] ) ); return 0;&#125; computer传送门发现这个东西可以在求直径的时候顺便求出来,所以这道题等价于用$DP$求一遍树的直径…..然后我们来重点剖析一下怎么用$DP$的方法去求树的直径.我们设$f_{x,0}$表示在$x$这颗子树中,由$x$向下最长能延申的距离是多少.同时我们再设$f_{x,1}$表示在$x$这颗子树中,由$x$向下走次长的链的长度为多少.但是发现我们还需要解决在$x$的子树中最长的链不经过$x$的情况,所以我们设$f_{x,2}$表示$x$通过它的父亲最长能向上延申多少距离.不难发现,前两个$f$数组可以在一次从下向上的$dfs$中求出,而第三个$f$数组则单独需要一个从上向下的$dfs$求出.那么对于某个$f_{x,2}$,转移方程有$f_{y,2}=max(f_{x,2},f_{y,0}+e_i.date==f_{x,0}?f_{x,1}:f_{x,0})+e_i.date$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10005;int n , t;int head[N] , f[N][3];struct Edge &#123; int to; int date; int next;&#125;e[N &lt;&lt; 2];inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].date = z; e[t].next = head[x]; head[x] = t; return;&#125; void dfs1 ( int x , int fa ) &#123; for ( int i = head[x] ; i ; i = e[i].next ) &#123; int y = e[i].to; if ( y == fa ) continue; dfs1 ( y , x ); int temp = f[y][0] + e[i].date; if ( temp &gt;= f[x][0] ) &#123; f[x][1] = f[x][0]; f[x][0] = temp; &#125; else if ( temp &gt; f[x][1] ) f[x][1] = temp; &#125; return;&#125;void dfs2 ( int x , int fa ) &#123; for ( int i = head[x] ; i ; i = e[i].next ) &#123; int y = e[i].to; if ( f[x][0] == f[y][0] + e[i].date ) f[y][2] = max ( f[x][2] , f[x][1] ) + e[i].date; else f[y][2] = max ( f[x][2] , f[x][0] ) + e[i].date; dfs2 ( y , x ); &#125; return;&#125;int main ( void ) &#123; while ( scanf ( "%d" , &amp;n ) != EOF ) &#123; t = 0; memset ( f , 0 , sizeof ( f ) ); memset ( head , 0 , sizeof ( head ) ); for ( int i = 2 ; i &lt;= n ; i++ ) &#123; int x , y; scanf ( "%d%d" , &amp;x , &amp;y ); add ( x , i , y ); &#125; dfs1 ( 1 , 0 ); dfs2 ( 1 , 0 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d\n" , max ( f[i][0] , f[i][2] ) ); &#125; return 0;&#125; 最优连通子集传送门20年前的Noi题目题目大意大概为给定一个平面整点集，点与点间在$|x_1-x_2|+|y_1-y_2|=1$时相邻，且形成的图没有回路，每个点有一个可正可负的权值，求最大权和连通子图。有了题目大意,发现就是给你一颗树.让你在这棵树中选择一个联通的点集,使得这个联通的点集的权值最大,求出这个最大值.发现显然是个树形背包嘛,我们设$f_{x,j}$表示在以$x$为根的子树中选/不选$x$这个节点时最大的权值和.然后我们可以直接从下往上转移.我们转移的时候发现,如果$i$这个点被选了,那么对于它所有的子树,如果$f_{y,1}$的值大于$0$,那么答案加上这颗子树一定会更优.而在我们转移$f_{x,0}$时,因为$x$这个节点不能选,所以我们就只能去选择这个节点的某一颗子树作为这个$f$的值.而最后的答案就是$max(f_{root,0},f_{root,1})$.12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt; #include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int inf = 1&lt;&lt;28;int n,m;struct Point&#123; int x,y,c;&#125;p[1010]; vector&lt;int&gt; con[1010];int dp[1010][2],mark[1010]; void dfs(int v)&#123; mark[v]=1; dp[v][0]=0,dp[v][1]=p[v].c; int j; for (int i=0;i&lt;con[v].size();i++) if (!mark[con[v][i]])&#123; j=con[v][i]; dfs(j); dp[v][0]=max(dp[v][0],max(dp[j][0],dp[j][1])); if (dp[j][1]&gt;0) dp[v][1]+=dp[j][1]; &#125; return;&#125; int main ( void ) &#123; scanf("%d",&amp;n); for (int i=0;i&lt;n;i++) scanf("%d%d%d",&amp;p[i].x,&amp;p[i].y,&amp;p[i].c); for (int i=0;i&lt;n;i++) for (int j=i+1;j&lt;n;j++) if (abs(p[i].x-p[j].x)+abs(p[i].y-p[j].y)==1)&#123; con[i].push_back(j); con[j].push_back(i); &#125; dfs(0); printf("%d\n",max(dp[0][0],dp[0][1])); return 0;&#125; The more, The Better传送门简单背包即可…. 选课传送门首先一个思路就是我们设$f_{i,j,0 \vert 1}$来表示以$i$为根节点的子树中,选择了$j$个物品,其中$i$选/不选时最大的价值.但是我们发现如果$i$不能选,那么$i$这颗子树一定就不能选,第三维没有什么必要,所以我们强制初始时$f_{i,1}=v_i$,然后转移的时候,用类似背包的思路.即枚举容量即可. f_{x,j+k}=max(f_{x,j+k},f_{x,j}+f_{y,k})1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define ll long long#define MP make_pair#define max(a,b) ( a &gt; b ) ? a : b #define F(i,a,b) for(int i=a;i&lt;=b;i++)#define D(i,a,b) for(int i=a;i&gt;=b;i--)#define PB push_backinline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 305;int n , m , t;int head[N] , f[N][N] , siz[N];struct Edge &#123; int to; int next;&#125; e[N &lt;&lt; 2];inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;void dfs ( int x , int fa ) &#123; siz[x] = 1; for ( int i = head[x] ; i ; i = e[i].next ) &#123; int y = e[i].to; if ( y == fa ) continue; dfs ( y , x ); for ( int j = siz[x] ; j ; j-- ) for ( int k = 0 ; k &lt;= siz[y] ; k++ ) f[x][j + k] = max ( f[x][j + k] , f[x][j] + f[y][k] ); siz[x] += siz[y]; &#125; return;&#125;int main ( void ) &#123; n = read () , m = read (); F ( i , 1 , n ) &#123; int fa = read (); add ( fa , i ); add ( i , fa ); f[i][1] = read (); &#125; dfs ( 0 , -1 ); printf ( "%d\n" , f[0][m + 1] ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普及五联测附加赛]]></title>
    <url>%2F2019%2F11%2F09%2F%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8B%E9%99%84%E5%8A%A0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开. 摆花首先一眼看到这道题你会怀疑这是不是普及组$t1$…然后考虑每个区间,你发现对于某两个区间,他们的关系可能是包含/相交/不相交.而对于这三种情况分别验证之后会发现你每次的答案最优的情况下总是最短的区间长度$+1$.然后考虑怎么证明这个东西,你发现它和暴力过拍了就对了.显然,你对于每个区间,我们设这个区间的长度为$i$的话,那么这个区间的$mex$值显然最大就是$i$.而又因为有许多区间.如果我们选择了某个长度较大的区间来放$0…..i-1$的话,那么对于其他的长度小于它的不相交区间显然答案会更小一些.而对于区间包含的情况,可以发现,长度更大的区间的$mex$一定会大于等于长度小的区间的$mex$,而又因为我们要求最小的$mex$最大,所以就要使这个最小的区间的$mex$最大即可.而对于剩下的两个区间相交的情况,发现和不相交的情况没有啥区别. 打饭首先考虑一个贪心,我们把区间按照$mod$ $k$的值分类,然后发现只有同一类的数才会互相有贡献,所以我们把数字从小到大的顺序扔到区间中统计答案.这样会错因为那些数字相对较少的区间不一定会丢进哪些数.而并不是那些最大的数丢进去就更优.而又因为你往一个组里丢的数字,如果排序之后他们的$pos$连续的话,答案会更小,这点是可以贪心的.所以我们考虑$DP$,我们发现,对于两种区间,我们都有一定的数量,而且每一种物品都有一种权值.所以我们显然可以用类似背包的东西来转移,我们设$f_{i,j}$表示两种区间,第一种用了$i$种,第二种用了$j$种时的最小的花费,转移时枚举是把这连续的几个数放到第一个区间内还是第二个区间内即可. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191107模拟赛题解]]></title>
    <url>%2F2019%2F11%2F08%2F20191107%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[德州扑克真好玩.jpg 德州扑克思路模拟有啥思路其实可以考虑把所有的手牌的类型开一个桶存起来,然后再从大顺到单牌挨个判断牌型,同牌型比较大小的时候可以考虑把贡献大的乘以一个比较大的数,然后直接比较分数即可. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &lt;bits/stdc++.h&gt;using namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 1e5 + 10;int n;struct Player &#123; int id; int point; string name; char card[12]; int num[6]; int buck[14];&#125; player[N];inline void FindCard () &#123; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) printf ( "%d%c" , player[i].num[j] , j == 5 ? '\n' : ' ' ); return;&#125;inline void DefHandCard ( int now ) &#123; int len = strlen ( player[now].card + 1 ); int cnt = 0; for ( int i = 1 ; i &lt;= len ; i++ ) &#123; if ( player[now].card[i] == '0' ) continue; if ( player[now].card[i] == '1' &amp;&amp; player[now].card[i + 1] == '0' ) player[now].num[++cnt] = 10; else if ( player[now].card[i] == 'A' ) player[now].num[++cnt] = 1; else if ( player[now].card[i] &gt;= '2' &amp;&amp; player[now].card[i] &lt;= '9' ) player[now].num[++cnt] = player[now].card[i] - '0'; else if ( player[now].card[i] == 'J' ) player[now].num[++cnt] = 11; else if ( player[now].card[i] == 'Q' ) player[now].num[++cnt] = 12; else if ( player[now].card[i] == 'K' ) player[now].num[++cnt] = 13; &#125; return;&#125;inline void PreKind ( int now ) &#123; for ( int i = 1 ; i &lt;= 5 ; i++ ) player[now].buck[player[now].num[i]]++; return;&#125;#define NowPlayer player[now] inline int FindStraight ( int now ) &#123; int flag = 0; for ( int i = 1 ; i &lt;= 9 ; i++ ) if ( NowPlayer.buck[i] &amp;&amp; NowPlayer.buck[i + 1] &amp;&amp; NowPlayer.buck[i + 2] &amp;&amp; NowPlayer.buck[i + 3] &amp;&amp; NowPlayer.buck[i + 4] ) &#123; flag = i + i + 1 + i + 2 + i + 3 + i + 4; break; &#125; if ( flag ) return flag; else return false;&#125;inline int FindFour ( int now ) &#123; int flag = 0; Player tmp = NowPlayer; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 4 ) &#123; tmp.buck[i] = 0; flag = i; break; &#125; if ( !flag ) return 0; flag *= 10000; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] ) &#123; flag += i; break; &#125; return flag;&#125;inline int FindHouse ( int now ) &#123; int flag = 0; Player tmp = NowPlayer; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 3 ) &#123; tmp.buck[i] = 0; flag = i; break; &#125; if ( !flag ) return 0; int ff = 0; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 2 ) &#123; tmp.buck[i] = 0; ff = i; break; &#125; if ( !ff ) return 0; return flag * 10000 + ff;&#125;inline int FindThree ( int now ) &#123; int flag = 0; Player tmp = NowPlayer; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 3 ) &#123; tmp.buck[i] = 0; flag = i; break; &#125; if ( !flag ) return 0; flag *= 10000; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] ) flag += i; return flag;&#125;inline int FindTwo ( int now ) &#123; int flag[3] , num = 0; Player tmp = NowPlayer; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 2 ) &#123; tmp.buck[i] = 0; flag[++num] = i; &#125; if ( num != 2 ) return 0; int ans = max ( flag[1] , flag[2] ) * 50000 + min ( flag[1] , flag[2] ) * 200; int tdp = 0; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] ) &#123; tmp.buck[i] = 0; tdp = i; break; &#125; return ans + tdp;&#125;inline int FindPair ( int now ) &#123; int flag = 0; Player tmp = NowPlayer; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] == 2 ) &#123; flag = i; break; &#125; if ( !flag ) return 0; flag *= 10000; for ( int i = 1 ; i &lt;= 13 ; i++ ) if ( tmp.buck[i] ) &#123; tmp.buck[i] = 0; flag += i; &#125; return flag;&#125;inline int FindOne ( int now ) &#123; int flag = 0; for ( int i = 1 ; i &lt;= 13 ; i++ ) while ( NowPlayer.buck[i] ) &#123; NowPlayer.buck[i]--; flag += i; &#125; return flag;&#125;inline bool cmp ( Player x , Player y ) &#123; if ( x.id != y.id ) return x.id &gt; y.id; if ( x.point != y.point ) return x.point &gt; y.point; return x.name &lt; y.name;&#125;int main ( void ) &#123; freopen ( "dezhou.in" , "r" , stdin ); freopen ( "dezhou.out" , "w" , stdout ); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; cin &gt;&gt; player[i].name; scanf ( "%s" , player[i].card + 1 ); DefHandCard ( i ); &#125; for ( int i = 1 ; i &lt;= n ; i++ ) PreKind ( i ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( player[i].buck[10] &amp;&amp; player[i].buck[11] &amp;&amp; player[i].buck[12] &amp;&amp; player[i].buck[13] &amp;&amp; player[i].buck[1] ) player[i].id = 8; else if ( FindStraight ( i ) ) player[i].point = FindStraight ( i ) , player[i].id = 7; else if ( FindFour ( i ) ) player[i].point = FindFour ( i ) , player[i].id = 6; else if ( FindHouse ( i ) ) player[i].point = FindHouse ( i ) , player[i].id = 5; else if ( FindThree ( i ) ) player[i].point = FindThree ( i ) , player[i].id = 4; else if ( FindTwo ( i ) ) player[i].point = FindTwo ( i ) , player[i].id = 3; else if ( FindPair ( i ) ) player[i].point = FindPair ( i ) , player[i].id = 2; else player[i].point = FindOne ( i ) , player[i].id = 1; &#125; sort ( player + 1 , player + 1 + n , cmp ); for ( int i = 1 ; i &lt;= n ; i++ ) cout &lt;&lt; player[i].name &lt;&lt; endl;; return 0;&#125; 三元组思路首先考虑$O(n^2)$怎么做:我们枚举一下每个三元组的中间值,对于每个$i$,我们考虑所有的$j$小于$i$中$val_j$大于$val_i$的个数和$val_j$小于$val_i$的个数.然后对于所有的$j&gt;i$也考虑一下.发现只要$val_k$大于$val_j$,$val_j$大于$val_i$那么$val_k$一定大于$val_i$.所以我们可以用$O(n^2)$的复杂度来统计出对于每个$i$中前边/后边的大于/小于它的个数.这样可以得到$50$分.然后我们想一下怎么优化这个过程.我们注意到倒数第二档部分分,它的权值非常的小.所以我们考虑怎么在权值上进行操作.然后对于所有的情况,我们离散化即可.我们发现,如果我们把权值看成一个序列,那么我们在某个$val_i$,查询大于它的数或者小于它的数,就相当于这个权值序列某段区间的和.然后每次扫过去时在这段区间中$val_i$加一.这个操作需要我们动态的单点修改区间求和.显然可以树状数组(或者其他什么数据结构).而因为我们这个树状数组是权值树状数组,所以还需要离散化一下即可通过该题. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int HA = 1e9 + 7;const int N = 200005;int n;int high[N] , tree[N];struct Lsh &#123; int val; int pos;&#125; lsh[N];inline bool cmp ( Lsh x , Lsh y ) &#123; return x.val &lt; y.val;&#125;inline void Pre () &#123; int cnt = 0; lsh[0].val = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( lsh[i].val != lsh[i - 1].val ) cnt++; high[lsh[i].pos] = cnt; &#125; return;&#125;inline int lowbit ( int x ) &#123; return x &amp; -x;&#125;inline void add ( int x , int pos ) &#123; while ( pos &lt;= n ) &#123; tree[pos] += x; pos += lowbit ( pos ); &#125; return;&#125;inline int query ( int pos ) &#123; int res = 0; while ( pos ) &#123; res += tree[pos]; pos -= lowbit ( pos ); &#125; return res;&#125;int fromin[N] , fromax[N] , behmin[N] , behmax[N];signed main ( void ) &#123; freopen ( "triple.in" , "r" , stdin ); freopen ( "triple.out" , "w" , stdout ); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; lsh[i].val = read (); lsh[i].pos = i; &#125; sort ( lsh + 1 , lsh + 1 + n , cmp ); Pre (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; fromin[i] = query ( high[i] - 1 ); fromax[i] = query ( n ) - query ( high[i] ); add ( 1 , high[i] ); &#125; memset ( tree , 0 , sizeof ( tree ) ); for ( int i = n ; i &gt;= 1 ; i-- ) &#123; behmin[i] = query ( high[i] - 1 ); behmax[i] = query ( n ) - query ( high[i] ); add ( 1 , high[i] ); &#125; int ans = 0; for ( int i = 1 ; i &lt;= n ; i++ ) ans = ( ans + ( behmin[i] * fromax[i] ) % HA + ( behmax[i] * fromin[i] ) % HA ) % HA; printf ( "%lld\n" , ans );// for ( int i = 1 ; i &lt;= n ; i++ ) // printf ( "%d %d %d %d\n" , fromin[i] , fromax[i] , behmin[i] , behmax[i] ); return 0;&#125; 多边形思路听说是在环上DP,真的不会x 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191106模拟赛]]></title>
    <url>%2F2019%2F11%2F07%2F20191106%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[给我也整一个这样的评测环境 A思路考虑两个人的答案,发现如果这对于某个特定的问题,如果这两个人的答案相同的话,那么他们可以将分数同时$+1$或者无变化.而若两个人的答案不同的话,显然我们选择分数相对较少的人加分更优.但是需要注意一个问题,我们需要先判断两个人答案相同的情况,因为若先判断答案不同的情况的话,发现可能会出现一个人已经到达了目标分数,而另一个人没到,这时候再判断答案一样的话显然两个人都不能再加分了. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;using namespace std; const int N = 1e5 + 10;int n , x , y;char A[N] , B[N]; int main ( void ) &#123; freopen ( "A.in" , "r" , stdin ); freopen ( "A.out" , "w" , stdout ); int T = read (); while ( T-- ) &#123; n = read () , x = read () , y = read (); scanf ( "%s%s" , A + 1 , B + 1 ); int tmp = 0; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( A[i] == B[i] ) tmp++; &#125; int NowScoreA = 0 , NowScoreB = 0; NowScoreA = min ( tmp , min ( x , y ) ); NowScoreB = min ( tmp , min ( x , y ) ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( NowScoreB == y &amp;&amp; NowScoreA == x ) break; if ( A[i] != B[i] ) &#123; if ( NowScoreB &lt; NowScoreA ) &#123; if ( NowScoreB &lt; y ) NowScoreB++; else if ( NowScoreA &lt; x ) NowScoreA++; &#125; else if ( NowScoreA &lt;= NowScoreB ) &#123; if ( NowScoreA &lt; x ) NowScoreA++; else if ( NowScoreB &lt; y ) NowScoreB++; &#125; &#125; &#125; //printf ( "%d %d %d %d\n" , x , y , NowScoreA , NowScoreB ); if ( NowScoreA == x &amp;&amp; NowScoreB == y ) puts ( "Yes" ); else puts ( "No" ); &#125; return 0; &#125; B思路首先,我们可以发现,大多数的数字一定为$1$.我们假设现在数列里只有$1,2$这两种数字的话,那么为了满足题目中要求的条件,那么非一的数字的个数一定是最多的.我们设 2^k]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191105模拟赛题解]]></title>
    <url>%2F2019%2F11%2F06%2F20191105%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[🐮🍻🐮 Work思路题目等价于找到一个数量最小的排列,使得对于这个排列里的任何一个$k$都有$\sum_{i=1}^{size}work_i - work_k &gt;= sleep_k$.然后我们移项之后有$\sum_{i=1}^{size}&gt;=work_k+sleep_k$.所以我们可以令$x_i=sleep_i+work_i$,然后对于$x_i$从小到大排序.然后我们枚举每一个$x_i$,然后同时把所有遍历过的$work_i$从大到小排序,我们需要找到一个长度最小的区间使得$\sum work_j &gt;= sleep_i$.首先想一下暴力怎么维护这个东西:我们每读进来某个$w_i$,我们把这个元素连同之前的元素按照$work_i$为关键字从小到大排序,并且我们每次都重新记录一下$work$数组的前缀和,使用二分的方法找到这个最小的区间长度.然后我们考虑怎么优化这个过程,我们发现我们可以维护一个小根堆,然后判断时,每次都弹出一个最小值.然后判断现在的$sum$是否还大于$sleep$.而且如果现在的$sum$本来就小于$sleep$时,我们也没必要再往堆里扔东西,因为如果要扔东西的话答案一定不会更优.所以直接忽略即可. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define int long long using namespace std; const int N = 5e5 + 10; int n;struct Worker &#123; int work; int sleep;&#125; w[N];int fro[N]; inline bool cmp1 ( Worker x , Worker y ) &#123; return x.sleep + x.work &lt; y.sleep + y.work;&#125;inline bool cmp2 ( Worker x , Worker y ) &#123; return x.work &lt; y.work;&#125; inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; priority_queue &lt; int , vector &lt; int &gt; , greater &lt; int &gt; &gt; qu; signed main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) w[i].work = read () , w[i].sleep = read (); sort ( w + 1 , w + 1 + n , cmp1 ); int ans = 2147483647 , sum = 0 , size = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( w[i].sleep &lt;= sum ) &#123; while ( sum - qu.top() &gt;= w[i].sleep ) &#123; sum -= qu.top(); qu.pop(); size--; &#125; ans = min ( ans , size ); &#125; qu.push ( w[i].work ); sum += w[i].work; size++; &#125; if ( ans == 2147483647 ) puts ( "-1" ); else cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Seq思路我们首先考虑暴力怎么$DP$,我们可以设$f_{i,j,0/1}$表示现在对于串$A$我们考虑了前$i$位,对于串$B$我们考虑了前$j$位,其中现在比上一位大/小时,最长的公共波浪子序列的长度是多少.那么我们可以$O(n^2)$枚举状态后再$O(n^2)$枚举转移,这样复杂度是$O(n^4)$的,可以过$40$分(其实可以过$60$).然后我们发现,我们可以把转移拆分成$(i,j)-&gt;(i,y)$,然后再由$(i,y)-&gt;(x,y)$.然后我们可以对于每一位分别转移即可. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;queue&gt; #define N 5005#define M 8000005 #define ls (t&lt;&lt;1)#define rs ((t&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1) #define mk make_pair#define pb push_back#define fi first#define se second using namespace std; int i,j,m,n,p,k,A[N],B[N],ans,a[N],b[N]; int f[N][N][2],g[N][N][2]; int Work()&#123; memset(f,0,sizeof(f)); for (i=1;i&lt;=n;++i) for(j=1;j&lt;=m;++j)&#123; f[i][j][0]=max(f[i-1][j][0],f[i][j-1][0]); if(a[i]==b[j]) f[i][j][0]=max(f[i][j][0],f[i-1][j-1][0]+1); &#125; return f[n][m][0];&#125; int main()&#123; scanf("%d",&amp;n); for (i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); scanf("%d",&amp;m); for (i=1;i&lt;=m;++i) scanf("%d",&amp;b[i]); for (i=1;i&lt;=n;++i) for (j=1;j&lt;=m;++j) if (a[i]==b[j]) f[i+1][j][0]=f[i+1][j][1]=1; for (i=1;i&lt;=n;++i) for (j=1;j&lt;=m;++j)&#123; //k==0 if (a[i]&gt;b[j]) g[i][j+1][0]=max(g[i][j+1][0],f[i][j][0]); f[i+1][j][0]=max(f[i+1][j][0],f[i][j][0]); if (a[i]==b[j]&amp;&amp;g[i][j][0]) f[i+1][j][1]=max(f[i+1][j][1],g[i][j][0]+1); g[i][j+1][0]=max(g[i][j+1][0],g[i][j][0]); //k==1 if (a[i]&lt;b[j]) g[i][j+1][1]=max(g[i][j+1][1],f[i][j][1]); f[i+1][j][1]=max(f[i+1][j][1],f[i][j][1]); if (a[i]==b[j]&amp;&amp;g[i][j][1]) f[i+1][j][0]=max(f[i+1][j][0],g[i][j][1]+1); g[i][j+1][1]=max(g[i][j+1][1],g[i][j][1]); &#125; for (i=1;i&lt;=n+1;++i) for (j=1;j&lt;=m+1;++j) ans=max(ans,max(f[i][j][0],f[i][j][1])); printf("%d\n",max(min(2,Work()),ans));&#125; Jump只会$60$暴力,咕咕咕了x 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20191104模拟赛题解]]></title>
    <url>%2F2019%2F11%2F05%2F20191104%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么老是考原题啊😥 快乐传递政治正确版找到一个规律,发现对于每一个人$i$,它能使所有和它的编号mod $gcd$相同的数字变的快乐.所以我们可以按照$gcd$分组,先求出$n,m,k$三个人的$gcd$,然后对于每一个快乐的人,标记一下它所在的分组即$i$ $mod$ $gcd$.最后我们只需要判断一下是不是所有的分组都被标记了即可.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int M = 1e6 + 10;int n , m , k , b , g , t;long long base;bool used[M];int main ( void ) &#123; freopen ( "happy2.in" , "r", stdin ); freopen ( "happy2.out" ,"w",stdout); int T; scanf ( "%d" , &amp;T ); while ( T-- ) &#123; memset ( used , 0 , sizeof ( used ) ); scanf ( "%d%d%d" , &amp;n , &amp;m, &amp;k); base = __gcd ( n * 1ll , __gcd ( m * 1ll , k * 1ll ) ); if ( base &gt;= 10 * N ) &#123; puts ( "No" ); continue; &#125; scanf ( "%d" , &amp;b ); for ( int i = 1 ; i &lt;= b ; i++ ) &#123; int x; scanf ( "%d" , &amp;x ); used[x % base] = 1; &#125; scanf ( "%d" , &amp;g ); for ( int i = 1 ; i &lt;= g ; i++ ) &#123; int x; scanf ( "%d" , &amp;x ); used[x % base] = 1; &#125; scanf ( "%d" , &amp;t ); for ( int i = 1 ; i &lt;= t ; i++ ) &#123; int x; scanf ( "%d" , &amp;x ); used[x % base] = 1; &#125; bool flag = 1; for ( int i = 0 ; i &lt; base ; i++ ) &#123; if ( !used[i] ) &#123; flag = 0; break; &#125; &#125; if ( flag ) puts ( "Yes" ); else puts ( "No" ); &#125; return 0;&#125; 嫌疑人我们先考虑一个显然错误的贪心:我们对于每个人被统计了多少次直接开桶统计,然后把统计的个数从大到小排序之后可以二分找到每一个需要被计入答案的数量.貌似一眼发现不了什么错误但是这个真的错了.我们发现对于一个人$i$,如果它要搞$j,k$的话,那么假设有一个投票,要投票的人是$j,k$,那么$i$这个人就会对这个计数方案贡献$2$的同意数.而这显然与一个人只能对一个方案有$1$的贡献不相符.所以我们考虑把多算的这一部分从原答案中减去,我们发现对于一个人,它只能对某一组特定的方案有$2$的赞同数,所以我们可以使用$map$套一个$pair$来对多统计的组数的贡献,然后我们遍历所有我们标记了的组合,如果本来它的赞同数$&gt;=p$并且它的赞同数$-$多统计的赞同数小于$p$的话,我们就需要让答案减少$1$.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 3e5 + 10;int n , p;int cnt[N] , rc[N];long long xdd;map &lt; pair &lt; int , int &gt; , int &gt; mp;signed main ( void ) &#123; freopen ( "suspect.in" , "r", stdin ); freopen ( "suspect.out" ,"w",stdout); scanf ( "%lld%lld" , &amp;n , &amp;p ); if ( p == 0 ) &#123; printf ( "%lld\n" , 1ll * n * ( n - 1 ) / 2 ); return 0; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int x , y; scanf ( "%lld%lld" , &amp;x , &amp;y ); cnt[x]++; cnt[y]++; if ( x &gt; y ) swap ( x , y ); rc[x]++; rc[y]++; mp[make_pair ( x , y )]++; &#125; sort ( cnt + 1 , cnt + 1 + n ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int l = i + 1 , r = n , ans = -1; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( cnt[mid] + cnt[i] &gt;= p ) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; if ( ans != -1 ) xdd = xdd + n - ans + 1; &#125; for ( map &lt; pair &lt; int , int &gt; , int &gt; :: iterator it = mp.begin () ; it != mp.end () ; it++ ) if ( rc[it -&gt; first.first] + rc[it -&gt; first.second] &gt;= p &amp;&amp; rc[it -&gt; first.first] + rc[it -&gt; first.second] - it -&gt; second &lt; p ) xdd--; printf ( "%lld\n" , xdd ); return 0;&#125; Xor发现在某个区间中出现过偶数次数字的异或和=区间中出现过的数字的异或和异或区间中出现了奇数次数字的异或和.而某个区间中出现了奇数次数字的异或和显然等于这个区间的异或和(因为出现了偶数次的数字异或起来的值为$0$).而异或值是有可减性的,所以我们对于这一部分只需要一个前缀异或和就可以统计了.那么我们剩下的问题就只有如何求在一个区间内出现过的数字的异或和.而这个东西显然不怎么可求.所以我们考虑离线的做法.我们对于所有的询问,将询问按照右端点从小到大排序,然后我们对于每个数字,维护一个这个数字上一次出现的位置(可以离散化或者直接开桶统计).然后我们在右移右指针的过程中,对于每个数,我们就像普通的树状数组一样异或所有的数字,这相当于维护了一个普通的异或和.但是我们如果现在要异或的这个数字之前出现过,那么我们把这个数字从上一次出现的位置再异或一次这个数(这样可以把多次出现的值异或掉).12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w; &#125;const int N = 3e5 + 10;int n , m;int val[N] , tree[N] , fro[N];map &lt; int , int &gt; flag;struct Que &#123; int l , r; int id;&#125; query[N];int ans[N];inline bool cmp ( Que x , Que y ) &#123; return x.r &lt; y.r;&#125;inline int lowbit ( int x ) &#123; return x &amp; -x;&#125; inline void add ( int pos , int x ) &#123; while ( pos &lt;= n ) &#123; tree[pos] ^= x; pos += lowbit ( pos ); &#125; return;&#125;inline int check ( int pos ) &#123; int res = 0; while ( pos ) &#123; res ^= tree[pos]; pos -= lowbit ( pos ); &#125; return res;&#125;int main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; val[i] = read (); fro[i] = fro[i - 1] ^ val[i]; &#125; m = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; query[i].l = read () , query[i].r = read (); query[i].id = i; &#125; sort ( query + 1 , query + 1 + m , cmp ); int now = 0; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; while ( now &lt; query[i].r ) &#123; now++; if ( !flag[val[now]] ) flag[val[now]] = now; else &#123; add ( flag[val[now]] , val[now] ); flag[val[now]] = now; &#125; add ( now , val[now] ); &#125; ans[query[i].id] = check ( query[i].r ) ^ check ( query[i].l - 1 ) ^ fro[query[i].r] ^ fro[query[i].l - 1]; &#125; for ( int i = 1 ; i &lt;= m ; i++ ) printf ( "%d\n" , ans[i] ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高失联测D9]]></title>
    <url>%2F2019%2F11%2F04%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E8%81%94%E6%B5%8BD9%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 蔡老板这道题题解里的二分的$check$到底是怎么想出来的啊….我们考虑到对于某个数$i$,在它的二进制表示下,对于某个确定的$2^i$的物品,你取还是不取是不影响$2^j(j&lt;i)$的物品拿还是不拿的.然后发现显然钱数这个东西是满足单调性的所以显然可以爬山所以我们可以二分钱数然后$check$.但是发现这个东西貌似不怎么好$check$.我们想一下我们之前说的性质,可以发现对于每一位,如果在二进制表示下是$1$,那么如果不拿就一定亏了(确信).但是拿的话只拿这个价格的东西显然不会更优.我们想一下,对于这一位之前的某一维,我们选之后(或者根本没选)剩下的,如果直接扔掉显然会浪费掉.然后我们又会发现,因为每个东西的价格都是用二的幂次方表示的,而两个价格为$2^i$的物品可以合并为一个$2^{i+1}$的物品.而这个操作显然需要我们按照钱数从小到大进行.那么我们的贪心思路就比较明显了,我们对于每一个二分出来的钱数$mid$,我们从低到高考虑这个钱数的每一位,如果是$1$的话,那么我们就选择当前维护的最大的一个值.然后把其他的从大到小两两合并成一个新的.而对于二进制考虑下是$0$的情况,我们直接合并即可. 唯一睿酱我们设$f_{l,r}$表示$l,r$这段区间一共有多少种方案,而且$l-1,r+1$是边界或者大于其中的所有数字.那么转移的话,我们可以考虑在$l,r$中枚举一个$k$,使得$l+r_k=k$或者$k+r_k=r$,然后转移就好了.但是这样转移的话发现时间复杂度是$O(n^3)$的,我们还得考虑怎么优化:我们发现,对于某个确定的$k$,它只能转移到$l=k-r_k$或者$r=k+r_k$的区间.所以我们不再枚举$k$,而是对于每一个$k$,我们都选择枚举它能转移到哪里.时间复杂度为$O(n^2)$. 波波🐮蔡老板牛逼! 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普转提撒花]]></title>
    <url>%2F2019%2F11%2F03%2F%E6%99%AE%E8%BD%AC%E6%8F%90%E6%92%92%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开(但是我还是要说一句周队🐮🍺!) 完结撒花qwq…. 嘴强王者首先可以设一个$k=\frac{n}{m}$表示每一组的人数.然后我们把所有队伍按照队长的能力值从小到大排序(即根据队长的排名从大到小排序).然后我们考虑能力值排名最大的队长怎么取.发现显然只能去取排名比$a_i$靠后的,方案为 $\dbinom{n-a_i}{k-1}$然后我们再去考虑能力值排名第二大的队伍,发现不仅只能去取排名比$a_i$靠后的,而且也不能去取已经被排名第一大的队伍取过的人,那么方案为$\dbinom{n-a_i-k}{k-1}$同样的,以此类推,最后的答案就是$\prod\limits_{i=1}^n\dbinom{n-a_i-k \times (i - 1) }{k-1}$ 数组发现题目中有一个突破点就是只有$1$和$2$两种数字.然后我们发现如下一个结论:我们找到某一个$1$,然后设它的位置为$i$,那么$[1,sum_n-sum_{i-1}]$范围内的数字都一定可以被取到.所以我们可以从左到右再从右到左分别找到第一个$1$,然后把可以到达的数标记起来.然后我们再找到之前没有被$1$之后的数字标记过的$2$的数量$num$,那么所有能到达的数的并集就是 [1,max(sum_n-sum_{i-1})(a_i=1)]∪max(sum_n-sum_{i-1})(a_i=1)+2 \times k (k]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2019]Elaxia的路线]]></title>
    <url>%2F2019%2F11%2F01%2FSDOI2019-Elaxia%E7%9A%84%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[传送门 首先我们可以知道如果把所有最短路上的边挑出来，再按照最短路中$dis$数组的递推关系给它加上方向的话这就是一个有向无环图。而如果把所有两个最短路的公共边挑出来的话，这个有向无环图中的最长链就是答案。并且判断一条边在最短路上的方式就是$dis[s→u]+w(u,v)+dis[u→t]=dis[s→t]dis[s→u]+w(u,v)+dis[u→t]=dis[s→t]$。并且因为这是无向图，所以求任意一个点到终点的距离只需要以终点为起点再跑一遍最短路就可以了。需要注意的问题就是公共路径从不同的方向经过也是可以的，所以需要把一对起点和终点倒过来再做一遍。 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校内ACM赛题解选讲]]></title>
    <url>%2F2019%2F10%2F30%2F%E6%A0%A1%E5%86%85ACM%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[校内题目就不公开题面啦x 数学首先我们用二项式定理展开一下式子. E((x-E(x))^k)=\sum_{i=0}^k[\dbinom{k}{i} \times (-1)^{k-i} \times E(x^i) \times E^{k-i}(x)]有因为$x$是一个常数,则$E(x)=x$,那么显然$E^{k-i}(x)={(\dfrac{1}{2})}^{k-i}$,那么问题就只剩下了$E(x^i)$怎么求了.而对于$E(x^i)$,我们可以设函数$f(x)=x^i$,然后考虑它的图像.因为$x^i$的期望对应的就是图像中的$y$,所以有$1 \times E(x^i) = S$.所以我们要计算的就只剩下函数$f(x)=x^i$在$[0,1]$上的图像的面积了.然后这个东西….可以用积分去求得: \int_{0}^{1}x^i\,dx = \dfrac{1^{i+1}}{i+1} - \dfrac{0^{i+1}}{i+1} = \frac{1}{i+1}计算出$E(x^i)$后,将表达式带回原式后得到 ans=\sum_{i=0}^k[\dbinom{k}{i} \times (-1)^{k-i} \times \frac{1}{i+1} \times {(\dfrac{1}{2})}^{k-i}]英语发现直接做的话貌似没什么思路….显然这道题可以先把询问离线出来,然后有一个显然错误的贪心就是每次选一个叶子节点的值(指从根节点到某个叶子的前缀和)最大的.这样做显然错误,因为每个点对答案的贡献只能被统计一次,所以我们要考虑怎么调整这个贪心的思路.通过观察发现,对于某一个点$i$,它的值只能被计算到它所有的儿子中边权权重求大的那个儿子,而对于它其他的儿子,它的贡献为$0$.所以我们的思路类似重链剖分中的寻找重儿子,我们对于每个非叶节点$p$,都在它的子树中找到一个权重最大的子树,然后把它的边权加入到它的重儿子中即可.听说这东西叫做长链剖分 政治看完题之后首先想到的就是对于每个犯罪团伙两两考虑包含关系然后再统计答案,但是这样的话时间复杂度上界是$O(2^{40})$,无法通过本题.然后我们发现村庄的数量只有$20$个,而且显然如果有两个团伙,他们的控制的村庄的状态一样,那么这两个团伙的收入和支出也一定是一样的.那么我们可以考虑根据每个团伙的控制村庄的二进制开桶,然后根据$S_i$统计每个团伙的答案.不难发现,对于某三个团伙(我们设他们控制的村庄的二进制表示分别为$i,j,k$),那么如果有$i \subsetneqq j , j \subsetneqq k$,那么一定有$i \subsetneqq k$.而如果一个集合$i$是$j$的子集的话,那么必要条件即在二进制表示下$i$中$1$的个数小于等于二进制表示下$j$中$1$的个数.那么我们如果考虑按照二进制表示下$1$的个数来划分集合的$rank$的话,那么显然某一个状态$i$一定会被所有的二进制下$1$的个数小于它的子集转移到,但是这样直接枚举的话是$3^n$的.所以我们考虑到可以用$FMT$优化.因为$FMT$为高维前缀和,我们每一次对于某一个状态$j$,显然$inn_j=inn_j+=inn_{j xor ( 1 &lt;&lt; i )} ((1&lt;&lt;i) and j==1)$.而对于支出的情况.可以发现,对于某个状态$i$,它的支出次数即为包含它的集合的个数,而包含它的集合的个数显然也可以用$FMT$去求解(但是注意转移的时候是由它转移到它的子集)即在进行$FMT$时要用异或之后的状态去更新之前的状态. 音乐首先发现直接使用区间的最大值去减去区间的最小值去更新答案的话显然是不对的,考虑怎么去调整.发现如果我们使用线段树的话,那么对于某个非叶节点,那么它的答案可能是它左子树的答案,也有可能是它右子树的答案.但是对于合并的话貌似直接不能两边的答案取一个$max$.我们发现,对于这个节点左子树中的每一个值,那么右子树中的任何一个比左子树中某一个值大的节点都可以去更新这一个节点.所以,我们直接去用右子树中的任何一个节点,去更新左子树中的任何一个节点是没有问题的.那么我们就可以分别使用左子树中的最小值和右子树中的最大值去维护这个两颗子树合并时的答案.而对于左子树的答案或者右子树的答案可能会大于左右两颗子树合并时的答案的情况,我们可以对于左子树的答案,右子树的答案和右子树的最大值-左子树的最小值去取一个$max$即为这个节点的$ans$值.所以我们需要维护一颗线段树,分别维护区间最大/最小值以及我们要求的答案即可简单线段树练习题. 体育我们发现无解的情况只存在于起点会重复的情况,但是题目中明确给出了起点和终点的坐标不会重复,所以没有无解的情况.而且ACM你只判无解也没分然后我们发现,如果我们把起点和终点都按照坐标从小到大排序之后,我们用最小的起点去对应最小的终点的话,发现这个起点是最小的,那么坐标比它大的点到这些点的终点的路径中一定有一段路程不会被包含,对于终点来说同理(如下图) 所以我们可以直接排完序之后找答案即可. 美术显然,我们可以设$f_{i,j,01}$表示现在以及考虑了$i$个格子,其中有$j$个格子的颜色和这个格子的上一个的颜色不一样,并且这个格子的颜色和它的上一个的颜色一不一样.那么如果这个格子的颜色和之前的一样的话,就只能继承前$i-1$个格子的答案,而如果这个格子和这个格子的前一个格子的颜色不一样的话,那么这个格子就有$m-1$种涂色方案.根据上边所说的,状态转移方程就很明显了: \begin{cases}f_{i,j,0}=f_{i-1,j,0}+f_{i-1,j,1}\\f_{i,j,1}=(f_{i-1,j-1,0}+f_{i-1,j-1,1}) \times (m-1)\end{cases}听说还有组合数学的做法,但是我不会 生物首先发现这道题的数据范围非常的迷惑,因为$n$只有$26$而且$a,b,c$只有$9$,所以只要$v$大于$26 \times 9$,我们就不妨钦定$v=26 \times 9$.这样之后发现混乱度可以直接用一维表示出来,所以我们考虑一下$DP$.直觉$DP$的话可以设$f_{i,j}$表示已经考虑了前$i$种相对性状,此时的混乱度是$j$的时候的方案数.但是这样的话我们会发现一个问题,就是我们可能会把同一种基因型在父本的贡献和在母本的贡献算重,而且也不好去重.所以我们考虑加一维状态:我们设$f_{i,j,k}$表示已经考虑了前$i$种相对性状,其中父本贡献的混乱度为$j$,母本贡献的混乱度为$k$时的方案数,在转移的时候直接考虑父本的性状已经母本的性状即可. 信息看上去不好写实际上还挺简单的模拟我不管这道题我一定要放代码(其实是为了凑字数) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pii std::pair&lt;int,int&gt;#define pll std::pair&lt;ll,ll&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125;template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125;/**********************************************************************************************************************************************************************************************************************************************************************/const int N = 1005;int n , m , sx , sy;int indeque[N][N];char mp[N][N] , operation[N];inline void init () &#123; read ( n , m ); F ( i , 1 , n ) scanf ( "%s" , mp[i] + 1 ); F ( i , 1 , n ) F ( j , 1 , m ) if ( mp[i][j] == '@' ) &#123; mp[i][j] = '.'; sx = i , sy = j; break; &#125; scanf ( "%s" , operation + 1 ); return;&#125;inline void FindDir ( int &amp;dx , int &amp;dy , char op ) &#123; if ( op == 'W' ) dx = -1 , dy = 0; else if ( op == 'A' ) dx = 0 , dy = -1; else if ( op == 'S' ) dx = 1 , dy = 0; else if ( op == 'D' ) dx = 0 , dy = 1; return;&#125;struct Node &#123; int x , y;&#125;qu[ ( N * N )*6];int hea = N * N , tail = ( N * N ) - 1;void Debug () &#123; F ( i , 1 , n ) &#123; F ( j , 1 , m ) if ( indeque[i][j] )&#123; if(indeque[i][j] == hea ) printf("%c",'@'); else printf("%c",'X'); &#125; else printf ( "%c",mp[i][j] ); puts ( "" ); &#125; puts ( "" ); return;&#125;inline void work () &#123; qu[++tail] = ( Node ) &#123; sx , sy &#125;; indeque[sx][sy] = tail; int len = strlen ( operation + 1 ); F ( T , 1 , len ) &#123; char op = operation[T]; int dx , dy; FindDir ( dx , dy , op ); int nx = qu[hea].x , ny = qu[hea].y; int tx = qu[tail].x , ty = qu[tail].y; if ( mp[nx + dx][ny + dy] == '.' &amp;&amp; !indeque[nx + dx][ny + dy] ) &#123; qu[--hea] = ( Node ) &#123; nx + dx , ny + dy &#125;; indeque[nx + dx][ny + dy] = hea; indeque[tx][ty] = 0; tail--; &#125; else if ( mp[nx + dx][ny + dy] == 'o' ) &#123; qu[--hea] = ( Node ) &#123; nx + dx , ny + dy &#125;; indeque[nx + dx][ny + dy] = hea; mp[nx + dx][ny + dy] = '.'; &#125; else if ( indeque[nx + dx][ny + dy] ) &#123; int start = indeque[nx + dx][ny + dy]; for ( int i = start ; i &lt;= tail ; i++ ) &#123; int xx = qu[i].x , yy = qu[i].y; indeque[xx][yy] = 0; &#125; while ( tail &gt;= start ) tail--; qu[--hea] = ( Node ) &#123; nx + dx , ny + dy &#125;; indeque[nx + dx][ny + dy] = hea; &#125; else if ( nx + dx &gt; m || ny + dy &gt; n || nx + dx &lt;= 0 || ny + dy &lt;= 0 || mp[nx + dx][ny + dy] == '#' ) &#123; puts ( "-1" ); exit ( 0 ); &#125; //Debug (); &#125; return;&#125;inline void print () &#123; F ( i , 1 , n ) F ( j , 1 , m ) if ( mp[i][j] == '#' || mp[i][j] == 'o' ) continue; else mp[i][j] = '.'; int xx = qu[hea].x , yy = qu[hea].y; mp[xx][yy] = '@'; hea++; while ( hea &lt;= tail ) &#123; xx = qu[hea].x , yy = qu[hea].y; mp[xx][yy] = 'X'; hea++; &#125; F ( i , 1 , n ) &#123; F ( j , 1 , m ) printf ( "%c" , mp[i][j] ); puts ( "" ); &#125; return;&#125;int main ( void ) &#123; init (); work (); print (); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POJ2284]That Nice Euler Circuit]]></title>
    <url>%2F2019%2F10%2F28%2FPOJ2284-ThatNiceEulerCircuit%2F</url>
    <content type="text"><![CDATA[传送门 思路首先我们想到的就是直接开二维数组模拟然后$bfs$统计答案.但是这样的话时间复杂度是不行的,所以我们需要考虑其他方法.我们考虑到欧拉公式,即$E=V+F-2$.在这里$E$为边数,$V$为点数,$F$为面的个数.本来这个欧拉公式是求三维的情况的,但是发现二维的情况也适用,所以我把它称为木大公式.可以直接开$map$统计点和边的个数,然后试用欧拉公式进行计算即可. (注意特判刚开始$0$的情况) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 10;int NodeNum , EdgeNum;char s[N];struct kuai &#123; int x , y;&#125;;bool operator &lt; ( kuai x , kuai y ) &#123; if ( x.x == y.x ) return x.y &lt; y.y; return x.x &lt; y.x;&#125;;map &lt; kuai , bool &gt; Node;map &lt; pair &lt; kuai , kuai &gt; , bool &gt; Edge; int main ( void ) &#123; scanf ( "%s" , s + 1 ); int n = strlen ( s + 1 ); int xx = 0 , yy = 0; Node[ kuai &#123; 0 , 0 &#125; ] = 1; NodeNum = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int lx = xx , ly = yy; if ( s[i] == 'L' ) xx--; else if ( s[i] == 'R' ) xx++; else if ( s[i] == 'U' ) yy++; else if ( s[i] == 'D' ) yy--; if ( !Node[ kuai &#123; xx , yy &#125; ] ) &#123; Node[ kuai &#123; xx , yy &#125; ] = 1; NodeNum++; &#125; if ( !Edge[ make_pair ( kuai &#123; lx , ly &#125; , kuai &#123; xx , yy &#125; ) ] &amp;&amp; !Edge[ make_pair ( kuai &#123; xx , yy &#125; , kuai &#123; lx , ly &#125; ) ] ) &#123; Edge[ make_pair ( kuai &#123; xx , yy &#125; , kuai &#123; lx , ly &#125; ) ] = 1; Edge[ make_pair ( kuai &#123; lx , ly &#125; , kuai &#123; xx , yy &#125; ) ] = 1; EdgeNum++; &#125; // printf ( "step:%d , from(%d,%d) -&gt; to(%d,%d)\n" , i , lx , ly , xx , yy ); &#125; // printf ( "%d %d\n" , EdgeNum , NodeNum ); printf ( "%d\n" , EdgeNum - NodeNum + 2 ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder Beginner Contest 144]题解]]></title>
    <url>%2F2019%2F10%2F28%2FAtcoderABC144%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[我菜爆了😢 9x9思路签到题,直接判断一下两个数的大小即可. 代码1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main ( void ) &#123; int a , b; cin &gt;&gt; a &gt;&gt; b; if ( a &gt;= 1 &amp;&amp; a &lt;= 9 &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= 9 ) cout &lt;&lt; a * b &lt;&lt; endl; else cout &lt;&lt; "-1" &lt;&lt; endl; return 0;&#125; 81思路从$2$枚举到$9$然后判断一下另一半是否小于$10$即可,注意$1$的情况. 代码12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main ( void ) &#123; int a , b; cin &gt;&gt; a; if ( a == 1 ) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; return 0; &#125; for ( int i = 2 ; i &lt;= 9 ; i++ ) if ( a % i == 0 ) &#123; if ( a / i &lt;= 9 &amp;&amp; a / i &gt;= 1 ) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; "No" &lt;&lt; endl; return 0;&#125; Walk on Multiplication Table思路我们可以在$\sqrt{n}$的时间内枚举出每个数的因数,然后对于每个因子判断一下是否可以更新答案即可. 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main ( void ) &#123; long long a; cin &gt;&gt; a; if ( a == 1 ) &#123; cout &lt;&lt; "0" &lt;&lt; endl; return 0; &#125; long long ans = 1e16; for ( int i = 1 ; i &lt;= sqrt ( a ) ; i++ ) &#123; if ( a % i == 0 ) ans = min ( ans , ( i - 1 ) + ( a / i ) - 1 ); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Water Bottle思路根据生活常识,我们发现如果把杯子倾斜,水能洒出来的话,从这个杯子的剖面去看,一共会有两种情况:剖面是个梯形与剖面是个三角形.而又因为当只有本来杯子内水的体积占用了原来杯子的体积的一半以上时剖面才会是个梯形,所以我们可以分两种情况分别讨论.我们将剖面画出来,然后发现这个图形的面积$S \times a$即为水的体积$x$,所以我们就可以算出来可变边的长度,再根据反三角函数计算出本来的解是多少. 弧度转角度: 角度=弧度$ \times 180 / Π$ 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;double a,b,x;double Rad_to_deg = 45.0 / atan(1.0);int main ( void ) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;x; if ( x &gt;= ( a * a * b ) / 2 ) &#123; double C = 2.0 * b - ( 2.0 * x / ( a * a ) ); double hu = atan ( a / C ); hu = hu * Rad_to_deg * 1.0; printf ( "%.10lf\n" , 90.0000000 - hu ); &#125; else &#123; double A = ( 2.0 * x ) / ( a * b ); double hu = atan ( A / b ); hu = hu * Rad_to_deg * 1.0; printf ( "%.10lf\n" , 90.0000000 - hu ); &#125; return 0;&#125; Gluttony思路根据我们的直觉,我们把$A$数组从小到大排序,然后把$F$数组从大到小排序,这样的话答案一定是最优的请自行证明.然后我们考虑怎么统计答案,显然,题目中要求最大值最小,所以我们可以二分这个最大值$mid$,然后对于每一组$A_i$与$F_i$,我们设$cnt_i$为使这组$A_i \times B_i &lt;= mid$时需要的锻炼次数.然后我们就可以列出$F_i \times ( A_i - cnt_i ) &lt;= mid $ , 即$cnt_i = max ( 0 , A_i - mid / F_i )$. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 2e5 + 10;int n , k;int A[N] , F[N];inline bool cmp ( int x , int y ) &#123; return x &gt; y;&#125;inline bool check ( int mid ) &#123; int cnt = 0; for ( int i = 1 ; i &lt;= n ; i++ ) cnt += max ( 0ll , A[i] - mid / F[i] ); if ( cnt &lt;= k ) return true; else return false;&#125;signed main ( void ) &#123; n = read () , k = read (); for ( int i = 1 ; i &lt;= n ; i++ ) A[i] = read (); for ( int i = 1 ; i &lt;= n ; i++ ) F[i] = read (); sort ( A + 1 , A + 1 + n ); sort ( F + 1 , F + 1 + n , cmp ); int l = 0 , r = 1e16; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( check ( mid ) ) r = mid - 1; else l = mid + 1; &#125; printf ( "%lld\n" , l ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Atcoder题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普转提D6]]></title>
    <url>%2F2019%2F10%2F28%2F%E6%99%AE%E8%BD%AC%E6%8F%90D6%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 石头思路我们设$f_i$表示前$i$个序列中能排出多少序列.那么显然有$f_i=\sum f_j([\sum_{k=1}^{j+1}a_k]是素数)$ 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define int long long #define ha 987654321const int N=1e6+10;using namespace std ;int n , f[N] , s[N] , vis[N] , num , prime[N] ;void pre() &#123; for(int i = 2 ; i &lt; N ; i ++) &#123; if(!vis[i]) prime[++num] = i ; for(int j = 1 ; j &lt;N &amp;&amp; i*prime[j] &lt;N ; j ++) &#123; vis[i*prime[j]] = 1 ; if(i % prime[j] == 0) break ; &#125; &#125; vis[1] = 1 ;&#125; int a[2000] ;signed main () &#123; pre() ; scanf("%lld",&amp;n) ; for(int i = 1 ; i &lt;= n ; i ++) &#123; int x ; scanf("%lld",&amp;x) ; a[i] = x ; s[i] = s[i-1] + a[i] ; &#125; f[0] = 1 ; for(int i = 1 ; i &lt;= n ; i ++ ) &#123; for(int j = 0 ; j &lt; i ; j ++) &#123; if(!vis[s[i]-s[j]]) f[i] = (f[i] + f[j])%ha ; &#125; &#125;cout &lt;&lt; f[n]%ha &lt;&lt; endl ; return 0 ;&#125; 载重思路先预处理出一个最大生成树,然后$check$两点之间的最大瓶颈路与给定的值的大小关系即可. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 1e5 + 10;const int M = 3e5 + 10;int n , m , q , t;int head[N];struct Edge &#123; int from; int to; int date; int next;&#125;e[M &lt;&lt; 1] , G[M &lt;&lt; 1];int father[N];inline bool cmp ( Edge x , Edge y ) &#123; return x.date &gt; y.date;&#125;int find ( int cur ) &#123; if ( father[cur] != cur ) father[cur] = find ( father[cur] ); return father[cur];&#125;inline void Union ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; return;&#125;inline bool Judge ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); if ( x == y ) return true; else return false;&#125;inline void add ( int x , int y , int z ) &#123; G[++t].to = y; G[t].from = x; G[t].date = z; G[t].next = head[x]; head[x] = t; return;&#125;int p[N][22] , mins[N][22];int deep[N];void Creat ( int root , int fa ) &#123; p[root][0] = fa; deep[root] = deep[fa] + 1; for ( int i = head[root] ; i ; i = G[i].next ) &#123; int j = G[i].to; if ( j == fa ) continue; mins[j][0] = G[i].date; Creat ( j , root ); &#125; return;&#125;inline int LCA ( int x , int y ) &#123; int minn = 2147483647; if ( deep[x] &gt; deep[y] ) std :: swap ( x , y ); for ( int i = 21 ; i &gt;= 0 ; i-- ) if ( deep[x] &lt;= deep[y] - ( 1 &lt;&lt; i ) ) &#123; minn = std :: min ( minn , mins[y][i] ); y = p[y][i]; &#125; if ( x == y ) return minn; for ( int i = 21 ; i &gt;= 0 ; i-- ) &#123; if ( p[x][i] == p[y][i] ) continue; minn = std :: min ( minn , std :: min ( mins[x][i] , mins[y][i] ) ); x = p[x][i]; y = p[y][i]; &#125; return std :: min ( minn , std :: min ( mins[x][0] , mins[y][0] ) );&#125;int main ( void ) &#123; n = read () , m = read () , q = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); e[i].from = x; e[i].to = y; e[i].date = z; &#125; for ( register int i = 1 ; i &lt;= n ; i++ ) father[i] = i; memset ( mins , 0x3f3f3f3f , sizeof ( mins ) ); std :: sort ( e + 1 , e + 1 + m , cmp ); int NowEdge = 0; for ( int i = 1 ; i &lt;= m &amp;&amp; NowEdge != n - 1 ; i++ ) &#123; int l = e[i].from , r = e[i].to; if ( !Judge ( l , r ) ) &#123; Union ( l , r ); NowEdge++; add ( l , r , e[i].date ); add ( r , l , e[i].date ); &#125; if ( NowEdge == n - 1 ) break; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) if ( deep[i] == 0 ) &#123; deep[i] = 1; p[i][0] = 0; Creat ( i , 0 ); &#125; for ( int j = 1 ; j &lt;= 21 ; j++ ) for ( int i = 1 ; i &lt;= n ; i++ ) &#123; p[i][j] = p[p[i][j - 1]][j - 1]; mins[i][j] = std :: min ( mins[i][j - 1] , mins[p[i][j - 1]][j - 1] ); &#125; for ( ; q-- ; ) &#123; int l = read () , r = read () , vv = read (); if ( !Judge ( l , r ) ) puts ( "No" ); else &#123; int res = LCA ( l , r ); if ( res &gt;= vv ) puts ( "Yes" ); else puts ( "No" ); &#125; &#125; return 0;&#125; 分数思路我们模拟一下现实中的过程,发现我们需要找出分母所有的质因子并且把他们乘起来就是答案,但是需要写高精度. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int MO = 15;struct Big&#123; int len, data[10005]; void clear() &#123; memset ( this , 0 , sizeof ( *this ) ); &#125; int &amp; operator [] ( int k ) &#123; return data[k]; &#125; Big &amp; operator = ( int k ) &#123; clear(); len = 0; while ( k ) &#123; ++len; data[len] = k &amp; MO; k &gt;&gt;= 4; &#125; if ( len == 0 ) ++len; return *this; &#125; Big operator * ( Big &amp; A ) &#123; Big temp; temp.clear(); temp.len = len + A.len - 1; for ( int i = 1 ; i &lt;= len ; i++ ) for ( int j = 1 ; j &lt;= A.len ; j++ ) &#123; temp[i + j - 1] += A[j] * data[i]; temp[i + j] += ( temp[i + j - 1] &gt;&gt; 4 ); temp[i + j - 1] &amp;= MO; &#125; while(temp[temp.len + 1]) ++temp.len; return temp; &#125; void print()&#123; for (int i = len; i &gt;= 1; i--) printf("%X", data[i]); putchar('\n'); &#125;&#125; temp , ans;const int N = 1000005;int pnum , p[N];bool f[N];map &lt; int , bool &gt; M;void work ( int num ) &#123; for ( int i = 1 ; i &lt;= pnum ; i++ ) &#123; if ( num % p[i] == 0 ) if ( M[p[i]] == 0 ) &#123; M[p[i]] = true; temp = p[i]; ans = ans * temp; &#125; while ( num % p[i] == 0 ) num /= p[i]; &#125; if ( num != 1 ) if ( M[num] == 0 ) &#123; M[num] = true; temp = num; ans = ans * temp; &#125; return;&#125; int main ( void ) &#123; ans = 1; int T; T = read (); memset ( f , true , sizeof ( f ) ); f[0] = f[1] = false; p[pnum = 1] = 2; for ( int now = 2 ; now &lt; N ; ) &#123; for ( int j = 2 * now ; j &lt;= N ; j += now ) f[j] = false; now++; while ( now &lt; N &amp;&amp; !f[now] ) now++; if ( f[now] ) p[++pnum] = now; &#125; while ( T-- ) &#123; int x = read () , y = read (); int d = __gcd ( x , y ); x /= d; y /= d; work ( y ); &#125; ans.print(); return 0;&#125; 鏼尔德思路解：设$d_{i,j}$表示走到结点$i$，被收了$j$次路费，最少花了多少钱。状态转移方程：考虑上一个结点，不妨设为$k$。$d_{i,j} = min[max(d_{k,j-1} + i到k的路费, d_{k,j})]$边界：$d_{1,j} = 0$最终解：$d_{n,k}$. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;#define N 3010#define INF 1000000000000000000#define LL long longstruct edge &#123; LL to, cost, next;&#125;;queue&lt;LL&gt; q;edge e[N &lt;&lt; 1];bool exist[N];LL d[N][N], head[N], n, m, K, nedge;inline LL max(LL x, LL y) &#123; return x &gt; y ? x : y;&#125;inline void link(LL u, LL v, LL w) &#123; e[++nedge].to = v; e[nedge].cost = w; e[nedge].next = head[u]; head[u] = nedge;&#125;int main() &#123; scanf("%lld %lld %lld", &amp;n, &amp;m, &amp;K); for(LL i = 1; i &lt;= m; i++) &#123; LL u, v, w; scanf("%lld %lld %lld", &amp;u, &amp;v, &amp;w); link(u, v, w); link(v, u, w); &#125; for(LL i = 2; i &lt;= n; i++) fill(&amp;d[i][0], &amp;d[i][N], INF); q.push(1); exist[1] = true; while(!q.empty()) &#123; LL u = q.front(); q.pop(); exist[u] = false; for(LL i = head[u]; i; i = e[i].next) &#123; LL v = e[i].to, w = e[i].cost; bool flag = false; for(LL j = 0; j &lt;= K; j++) &#123; LL t = d[u][j]; if(j) t = max(t, d[u][j - 1] + w); if(d[v][j] &gt; t) &#123;d[v][j] = t; flag = true;&#125; &#125; if(flag &amp;&amp; !exist[v]) &#123; exist[v] = true; q.push(v); &#125; &#125; &#125; printf("%lld", d[n][K]); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普及五联测D4]]></title>
    <url>%2F2019%2F10%2F26%2F%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8BD4%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开. 刷题王者思路直接开$map$统计即可. 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int n;bool mp[10005];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int num; scanf ( "%d" , &amp;num ); while ( num-- ) &#123; int x; scanf ( "%d" , &amp;x ); mp[x] = 1; &#125; &#125; int ans = 0; for ( int i = 1000 ; i &lt;= 9999 ; i++ ) if ( mp[i] ) ans++; printf ( "%d\n" , ans ); return 0;&#125; 回到原点思路考虑我们按照原来的字符串进行移动之后的位置$(x,y)$.发现对原来字符串进行操作的话,如果我们把某个向上的和向下的操作变成向左或向右的,那么每次可以从$(x,y)$向左上/下,右上/下移动.所以我们每次可以对于$x$和$y$的绝对值$+1$或者$-1$.所以答案就是$min(abs(x),abs(y)) + max ( abs ( x ) - min ( abs ( x ) , abs ( y ) ) , abs ( y ) - min ( abs ( x ) , abs ( y ) ) ) / 2$. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1005;int len , x , y;char s[N];int main ( void ) &#123; scanf ( "%s" , s + 1 ); len = strlen ( s + 1 ); if ( len &amp; 1 ) &#123; puts ( "-1" ); return 0; &#125; for ( int i = 1 ; i &lt;= len ; i++ ) &#123; if ( s[i] == 'U' ) y++; if ( s[i] == 'D' ) y--; if ( s[i] == 'L' ) x--; if ( s[i] == 'R' ) x++; &#125; int ans = 0; ans += min ( abs ( x ) , abs ( y ) ); if ( x &gt;= 0 ) x -= ans; else if ( x &lt; 0 ) x += ans; if ( y &gt;= 0 ) y -= ans; else if ( y &lt; 0 ) y += ans; if ( x != 0 ) ans += abs ( x / 2 ); else if ( y != 0 ) ans += abs ( y / 2 ); printf ( "%d\n" , ans ); return 0;&#125; 快乐矩阵思路发现原来某些点的贡献可以压缩到一个点,所以我们对每一行求一个前缀差,然后再对这最后一列的前缀差求一个前缀差,判断一下是否为$0$即可. 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int mp[505][505];int n , m;int num[505];signed main ( void ) &#123;// freopen ( "C.in" , "r" , stdin ); ios :: sync_with_stdio ( false ); cin.tie ( 0 ) , cout.tie ( 0 ); cin &gt;&gt; n &gt;&gt; m; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 1 ; j &lt;= m ; j++ ) cin &gt;&gt; mp[i][j]; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int sum = 0; for ( int j = 1 ; j &lt; m ; j++ ) mp[i][j + 1] -= mp[i][j]; num[i] = mp[i][m]; // cout &lt;&lt; num[i] &lt;&lt; endl; &#125; int now = 0; for ( int i = 1 ; i &lt; n ; i++ ) num[i + 1] -= num[i]; now = num[n]; if ( abs ( now ) == 0 ) puts ( "Yes" ); else puts ( "No" ); return 0;&#125; 梦中的位运算思路发现进行操作一定比不操作更优秀,所以我们要求的就是操作到不能再操作了的时候这个序列的平方和.又因为这个操作的本质就是把$1$都放到某一个数字上,所以我们直接统计一下二进制下某一位出现了多少次然后贪心统计即可. 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w; &#125;inline void print ( __int128 x ) &#123; if ( !x ) return ; print ( x / 10 ); putchar ( x % 10 + '0' ); return;&#125;int n;int num[35];__int128 ans;int main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int x = read (); for ( int j = 0 ; j &lt;= 30 ; j++ ) if ( x &amp; ( 1 &lt;&lt; j ) ) num[j]++; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; __int128 re = 0; for ( int j = 0 ; j &lt;= 30 ; j++ ) if ( num[j] &gt;= i ) re |= (1ll &lt;&lt; j); ans += re * re; &#125; print ( ans ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 75题解]]></title>
    <url>%2F2019%2F10%2F25%2FEdu75%2F</url>
    <content type="text"><![CDATA[意外感觉还挺友善的? Broken Keyboard思路考虑一段字符连续出现的次数是奇数次还是偶数次,如果有某种字符连续出现了奇数次那么就是一定存在的. 代码12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while ( T-- ) &#123; string s; cin &gt;&gt; s; int len = s.size (); map &lt; char , bool &gt; ans; char las = '.'; int num = 0; for ( int i = 0 ; i &lt;= len ; i++ )&#123; if ( las != s[i] ) &#123; if ( num % 2 == 1 ) ans[las] = 1; las = s[i]; num = 1; &#125; else num++; &#125; for ( int i = ( int ) 'a' ; i &lt;= ( int ) 'z' ; i++ ) if ( ans[(char)i] == 1 ) cout &lt;&lt; ( char ) i; cout &lt;&lt; endl; &#125; return 0;&#125;// Binary Palindromes思路发现如果可以根据题目中给的条件来交换的话,那么原问题可以等价为给你若干个$1$和$0$,然后能对于某些给定的长度,最多能拼出多少回文串.发现如果我们要构造串的话,那么在前$len/i$(向下取整)个位置,我们不用考虑什么其他的条件,只需要每次选择一个剩余数量大的然后$-2$即可.然后我们发现如果我们要构造的串的长度为奇数的话,中间的那个用什么是个问题,我们考虑一下,因为我们在构造过程的第一步中要拿出两个来构造,那么如果剩余数量是奇数一定会比剩余数量是偶数更劣.而奇数$-1=$偶数,所以如果有剩余个数是奇数的话,我们拿出一个奇数的来$-1$,否则选择一个剩余数量多的构造. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int len[55];int main()&#123; ios :: sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while ( T-- ) &#123; memset ( len , 0 , sizeof ( len ) ); int NumZ = 0 , NumO = 0; int n; cin &gt;&gt; n; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; string s; cin&gt;&gt;s; len[i] = s.size(); for ( int j = 0 ; j &lt; len[i] ; j++ ) if ( s[j] == '0' ) NumZ++; else NumO++; &#125; sort ( len + 1 , len + 1 + n ); int ans = 0; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= len[i] / 2 ; j++ ) &#123; if ( NumO &gt; NumZ ) NumO -= 2; else NumZ -= 2; &#125; if ( len[i] % 2 == 1 ) if ( NumO &gt;= 1 &amp;&amp; NumO % 2 == 1 ) NumO--; else if ( NumZ &gt;= 1 &amp;&amp; NumZ % 2 == 1 ) NumZ--; else &#123; if ( NumO &gt; NumZ ) NumO -= 1; else NumZ -= 1; &#125; if ( NumZ &gt;= 0 &amp;&amp; NumO &gt;= 0 ) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; Minimize The Integer思路发现这样一个结论,如果可以交换任意不同相邻奇偶数的话,那么原来奇数和偶数相对于自己的奇偶性的数的相对位置是不会改变的.所以我们可以分别把奇数和偶数存储起来.然后开两个队列,分别对比奇数和偶数队列的队头大小并且贪心的选择一个小的输出即可. 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;string s;int main ( void ) &#123; ios :: sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while ( T-- ) &#123; cin &gt;&gt; s; int len = s.size (); queue &lt; int &gt; qu[2]; for ( int i = 0 ; i &lt; len ; i++ ) if ( ( ( int ) s[i] - '0' ) % 2 == 0 ) qu[0].push ( ( int ) s[i] - '0' ); else qu[1].push ( ( int ) s[i] - '0' ); qu[0].push ( 11 ); qu[1].push ( 11 ); for ( int i = 1 ; i &lt;= len ; i++ ) &#123; if ( qu[0].front () &lt; qu[1].front () ) &#123; cout &lt;&lt; qu[0].front (); qu[0].pop (); &#125; else if ( qu[0].front () &gt; qu[1].front () ) &#123; cout &lt;&lt; qu[1].front (); qu[1].pop (); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Salary Changing思路发现可以二分这个$mid$,然后我们考虑怎么$check$.对于某个区间$[l,r]$,如果$r&gt;=mid$,那么说明在这个区间中我们可以取到$mid$.然后我们把能取到$mid$的区间全部取到$mid$,发现如果大于$mid$的区间刚好为$(n+1)/2$个,那么说明这个取值是可行的. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; const int INF = 1e9 + 5; struct Node &#123; int L, R; bool operator&lt;(const Node &amp;other) const &#123; return L &lt; other.L; &#125;&#125;; int N, H;long long S;vector&lt;Node&gt; v; bool possible(int median) &#123; long long sum = 0; for (Node &amp;s : v) sum += s.L; int count = 0; for (int i = N - 1; i &gt;= 0 &amp;&amp; count &lt; H; i--) if (v[i].R &gt;= median) &#123; sum += max(median - v[i].L, 0); count++; &#125; return count == H &amp;&amp; sum &lt;= S;&#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N &gt;&gt; S; H = (N + 1) / 2; v.resize(N); for ( Node &amp;s : v ) cin &gt;&gt; s.L &gt;&gt; s.R; sort ( v.begin() , v.end () ); int l = 0, r = INF , ans; while ( l &lt;= r ) &#123; int mid = ( l + r ) / 2; if ( possible ( mid ) ) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[51NodP1682] 中位数计数]]></title>
    <url>%2F2019%2F10%2F24%2F51Nod-P1682%E4%B8%AD%E4%BD%8D%E6%95%B0%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[传送门 发现题目中的数据范围说明我们需要一个时间复杂度为$O(n^2)$的算法.发现我们可以考虑每个数字的贡献,我们发现,对于某个位置上的数字而言,包含这个位置的区间的数量是$n$级别的.所以我们可以尝试对于每个位置的数字,枚举包含这个位置的区间然后统计答案.所以问题就转化成了怎么统计答案.由于权值的范围很大,所以我们考虑设$sum_{n+j}$表示排序后,与$i$这个位置的数字还需要移动正负$j$个单位才能到中位数的位置.然后我们枚举完所有区间之后直接统计就好了. 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 8e3 + 5;const int INF = 0x3f3f3f3f;int n;int num[N], sum[N &lt;&lt; 1], ans[N];int main ( void ) &#123; ios :: sync_with_stdio ( false ); cin.tie ( 0 ) , cout.tie ( 0 ); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; num[i]; for (int i = 0; i &lt; n; i++)&#123; memset(sum, 0, sizeof(sum)); int cnt = 0; for (int j = i; j &gt;= 0; j--)&#123; if (num[j] &gt; num[i]) cnt++; if (num[j] &lt; num[i]) cnt--; sum[8000+cnt]++; &#125; cnt = 0; for (int j = i; j &lt; n; j++)&#123; if (num[j] &gt; num[i]) cnt++; if (num[j] &lt; num[i]) cnt--; ans[i] += sum[8000-cnt]; &#125; &#125; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; ans[i]; if (i != n-1) cout &lt;&lt; " "; else cout &lt;&lt; endl; &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JZOJ]平均数]]></title>
    <url>%2F2019%2F10%2F24%2FJZOJ-%E5%B9%B3%E5%9D%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[莫得传送门qwq,,, 考虑二分平均值mid，设当前平均值小于等于mid的个数为$f(mid)$。当$f(mid)&gt;k$，则缩小$mid$。然后剩下的问题就变成了怎么求出这个$f$了.我们设𝑎数组前缀和为$sum_i$,那么区间$[𝑗+1,𝑖]$的平均值为$\frac{𝑠𝑢𝑚[𝑖]−𝑠𝑢𝑚[𝑗]}{𝑖−𝑗}$.然后观察对于一对$(𝑖,𝑗)$： \frac{𝑠𝑢𝑚_i−𝑠𝑢𝑚_j}{𝑖−𝑗}≤𝑚𝑖𝑑⇔𝑠𝑢𝑚_i−𝑠𝑢𝑚_j≤𝑚𝑖𝑑∗(𝑖−𝑗)⇔𝑠𝑢𝑚_i−𝑚𝑖𝑑∗𝑖≤𝑠𝑢𝑚_j−𝑚𝑖𝑑∗𝑗显然,如果我们定义$v_i$表示$sum_i-mid \times i$的话,那么$f(mid)$即为$v$数组的逆序对.所以我们要做的就是求出逆序对的个数即可,可以用树状数组或者归并排序轻松解决. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[51Nod]P1686 第K大区间]]></title>
    <url>%2F2019%2F10%2F24%2F51NodP1686-%E7%AC%ACK%E5%A4%A7%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[传送门注意到如果我们设$f_i$表示值大于$i$的区间有多少个的话,那么显然$i$越大,区间的个数越小,具有单调性,所以显然可以二分解决.又因为题目中的限制可以转化为$f_i&gt;=k$并且$i$最大.那么我们可以去二分这个$i$然后统计一下$f_i$有多少个.那么现在的问题就是怎么去统计这个$f_i$到底有多少.我们先对原数组进行离散化处理(因为原来的权值范围实在是太大了),然后开一个$buck_i$表示$i$这个数字出现了多少次.那么发现如果我们使用$two$_$pointers$统计答案的话,那么每次会更新众数的那个值一定只能是新加进来的那个值.所以我们只需要判断一下是不是$buck_r&gt;=mid$即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e5 + 10;int n , k;struct Node &#123; int id; int v;&#125;ls[N];int num[N] , idx;int buck[N];inline bool cmp ( Node x , Node y ) &#123; return x.v &lt; y.v;&#125;int pos[N];vector &lt; int &gt; G[N];inline int check ( int x ) &#123; if ( x == 1 ) return n * ( n - 1 ) / 2; int ans = 0 , L = 0; for ( int i = 1 ; i &lt;= n ; i++ ) G[i].clear(); memset ( buck , 0 , sizeof ( buck ) ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( buck[num[i]] &gt;= x - 1 ) pos[i] = G[num[i]][buck[num[i]] + 1 - x]; else pos[i] = 0; L = max ( L , pos[i] ); ans += L; buck[num[i]]++; int tmp = buck[num[i]]; G[num[i]].push_back( i ); &#125; return ans;&#125;signed main ( void ) &#123; ios :: sync_with_stdio ( false ); cin.tie ( 0 ) , cout.tie ( 0 ); cin &gt;&gt; n &gt;&gt; k; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; ls[i].id = i; cin &gt;&gt; ls[i].v; &#125; sort ( ls + 1 , ls + 1 + n , cmp ); ls[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( ls[i].v != ls[i - 1].v ) idx++; num[ls[i].id] = idx; &#125; int l = 1 , r = n , ans = 1; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( check ( mid ) &gt;= k ) &#123; l = mid + 1; ans = mid; &#125; else r = mid - 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #595 (Div. 3)]]></title>
    <url>%2F2019%2F10%2F23%2FRound595%2F</url>
    <content type="text"><![CDATA[降智题真的可以为所欲为. Yet Another Dividing into Teams思路因为题目中有个条件叫做每个$a_i$互不相同,所以我们可以先排序之后看一下$a_i$于$a_{i-1}$的差的绝对值是否为$1$.如果有的话答案就是$2$,否则答案显然为$1$. 代码12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int n , ans;int num[105];int main ( void ) &#123; int T; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; sort(num+1,num+1+n); ans=1; for(int i=2;i&lt;=n;i++) if(abs(num[i]-num[i-1])==1) ans=2; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Books Exchange思路$B1$和$B2$就一起说了….首先如果$i$可以把他的信息传给$d_i$,那么我们由信息传递那道题的思路可知我们可以从$i$到$d_i$连一条边.而每个点要知道自己的信息,就是要在自己所在的强连通分量中走一圈.即每个点的答案就是每个点所在强连通分量的大小.又因为题目保证一定有解,所以直接$Tarjan$缩点然后直接统计$size$即可,多测注意清空. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;int n,t,idx,Bcnt;int head[N];struct Edge&#123; int to; int next;&#125;e[N&lt;&lt;1];int dfn[N],low[N];int Belong[N],siz[N];inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;stack &lt; int &gt; st;bool instack[N];void Tarjan ( int cur ) &#123; st.push ( cur ); dfn[cur] = low[cur] = ++idx; instack[cur] = 1; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( !dfn[j] ) &#123; Tarjan ( j ); low[cur] = min ( low[cur] , low[j] ); &#125; else if ( instack[j] ) low[cur] = min ( low[cur] , dfn[j] ); &#125; int k; if ( dfn[cur] == low[cur] ) &#123; Bcnt++; do &#123; k = st.top (); instack[k] = 0; st.pop (); Belong[k] = Bcnt; siz[Belong[k]]++; &#125; while ( k != cur ); &#125; return;&#125;int main ( void ) &#123; ios :: sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; t=0; memset(head,0,sizeof(head)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int to; cin&gt;&gt;to; add(i,to); &#125; for(int i=1;i&lt;=n;i++) if (!dfn[i] ) &#123; while(!st.empty()) st.pop(); Tarjan(i); &#125; //cout&lt;&lt;t&lt;&lt;endl; for(int i=1;i&lt;=n;i++) cout&lt;&lt;siz[Belong[i]]&lt;&lt;" "; cout&lt;&lt;endl; &#125; return 0;&#125; Good Numbers (easy version)思路我们发现在$3^i&lt;=10000$的情况下$i$最大只到$10$,所以我们可以$2^{log_3n}$的时间复杂度枚举一下所有的$good$数,每次询问时$check$一下即可. 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int n,idx;int num[10004];inline int ksm(int x,int y)&#123; int res=1; while(y)&#123; if(y&amp;1) res*=x; x=x*x; y&gt;&gt;=1; &#125; return res;&#125;int main ( void ) &#123; ios :: sync_with_stdio(false); cin.tie(0),cout.tie(0); for(int i=1;i&lt;=(1&lt;&lt;10)-1;i++)&#123; int now=0; for(int j=0;j&lt;=10;j++) if(i&amp;(1&lt;&lt;j)) now=now+ksm(3,j); num[++idx]=now; &#125; sort(num+1,num+1+idx); int T; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=idx;i++) if(num[i]&gt;=n)&#123; cout&lt;&lt;num[i]&lt;&lt;endl; break; &#125; &#125; return 0;&#125; Good Numbers (hard version)思路考虑$C1$中的思路发现这样枚举的话太费事了.所以我们可以先找到一个小于$n$的$good$数,而这个数显然可以贪心的在$O(log_3n)$的复杂度内求出来.然后我们考虑怎么让这个数字增加.我们用二进制表示每个$3^i$是否被加入到这个数字里,那么我们可以发现我们要做的就是找到一个二进制下最左边的右边是$0$的$1$,把$0$变成$1$,然后把前边的$1$都变成$0$然后统计新的数字是什么即可. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n;bool used[42];inline int ksm(int x,int y)&#123; int res=1; while(y)&#123; if(y&amp;1) res*=x; x=x*x; y&gt;&gt;=1; &#125; return res;&#125;signed main ( void ) &#123; ios :: sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; memset(used,0,sizeof(used)); cin&gt;&gt;n; int tmp=n,res=0; int MAX=40,MAXX=-1; while(tmp)&#123; int sign=0; if(MAX&lt;=0) break; for(int i=0;i&lt;MAX;i++)&#123; if(ksm(3,i)&gt;tmp)&#123; MAXX=max(MAXX,i); break; &#125; sign=i; &#125; used[sign]=1; tmp-=ksm(3,sign); res+=ksm(3,sign); MAX=sign; &#125; if(res==n) cout&lt;&lt;res&lt;&lt;endl; else&#123; int sign; for(int i=40;i&gt;=0;i--) if(used[i])&#123; sign=i; break; &#125; int css=0; for(int i=0;i&lt;=sign;i++)&#123; if(used[i]==1&amp;&amp;used[i+1]==0)&#123; css = ksm ( 3 , i + 1 ); for ( int j = i + 2 ; j &lt;= sign ; j++ ) if ( used[j] ) css = css + ksm ( 3 , j ); break; &#125; &#125; cout &lt;&lt;css &lt;&lt; endl; &#125; &#125; return 0;&#125; Too Many Segments (easy version)思路发现我们只需要每次找到一个被覆盖次数大于$k$的点,然后寻找一下覆盖了这个点的区间中右端点最靠右的贪心的删去即可.时间复杂度$O(n^2)$. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 205;int n , k;struct Sen &#123; int l,r,id; &#125; se[N];bool use[N];int num[N];int opt[N] , ans;int main ( void ) &#123; ios :: sync_with_stdio ( false ); cin.tie ( 0 ) , cout.tie ( 0 ); cin &gt;&gt; n &gt;&gt; k; int MinLim = 2147483647 , MaxLim = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; cin &gt;&gt; se[i].l &gt;&gt; se[i].r; se[i].id = i; MinLim = min ( MinLim , se[i].l ) , MaxLim = max ( MaxLim , se[i].r );&#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = se[i].l ; j &lt;= se[i].r ;j++ ) num[j]++; for ( int i = MinLim ; i &lt;= MaxLim ; i++ ) &#123; while ( num[i] &gt; k ) &#123; int MaxDisTanceR = -1 , MaxDisTanceSign = -1; for ( int j = 1 ; j &lt;= n ; j++ ) if ( se[j].l &lt;= i &amp;&amp; se[j].r &gt;= i &amp;&amp; !use[j] ) if ( MaxDisTanceR &lt; se[j].r ) &#123; MaxDisTanceR = se[j].r , MaxDisTanceSign = j;&#125; use[MaxDisTanceSign] = 1; opt[++ans] = MaxDisTanceSign; for ( int j = se[MaxDisTanceSign].l ; j &lt;= se[MaxDisTanceSign].r ; j++ ) num[j]--; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; for ( int i = 1 ; i &lt;= ans ; i++ ) cout &lt;&lt; opt[i] &lt;&lt; " "; return 0;&#125; Too Many Segments (hard version)思路我们发现按照右端点排序之后,对于每个区间,如果它即将要覆盖的这个区间的最大值小于$k$的话,那么直接覆盖是没有问题的.否则考虑对后面的贡献的话,如果这个区间之前的区间不选择的话,那么前边的区间不选一定比不选现在的这个区间更劣.(因为删除排序后前边的节点对后面的贡献更小).所以我们需要一个可以维护区间$MAX$和区间加的数据结构维护即可.(线段树). 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=2e5+5;int n,k;struct node&#123; int x,y; int id;&#125;sg[MAXN];bool operator &lt;(node a,node b)&#123; return a.y&lt;b.y;&#125;#define lc k&lt;&lt;1#define rc k&lt;&lt;1|1#define ls lc,l,mid#define rs rc,mid+1,rint mx[MAXN&lt;&lt;2],tag[MAXN&lt;&lt;2];inline void add(int k,int v)&#123; mx[k]+=v; tag[k]+=v;&#125;inline void pushup(int k)&#123; mx[k]=max(mx[lc],mx[rc]);&#125;inline void pushdwn(int k)&#123; add(lc,tag[k]); add(rc,tag[k]); tag[k]=0;&#125;int Query(int k,int l,int r,int qx,int qy)&#123; if(qx&lt;=l&amp;&amp;r&lt;=qy) return mx[k]; pushdwn(k); int mid=l+r&gt;&gt;1,res=0; if(qx&lt;=mid) res=max(res,Query(ls,qx,qy)); if(mid&lt;qy) res=max(res,Query(rs,qx,qy)); return res;&#125;void Modify(int k,int l,int r,int qx,int qy)&#123; if(qx&lt;=l&amp;&amp;r&lt;=qy) return add(k,1); pushdwn(k); int mid=l+r&gt;&gt;1; if(qx&lt;=mid) Modify(ls,qx,qy); if(mid&lt;qy) Modify(rs,qx,qy); pushup(k); return ;&#125;int m;bool vis[MAXN];int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;sg[i].x,&amp;sg[i].y),sg[i].id=i; sort(sg+1,sg+n+1); m=n; for(int i=1;i&lt;=n;i++) if(Query(1,1,2e5,sg[i].x,sg[i].y)&lt;k) Modify(1,1,2e5,sg[i].x,sg[i].y),m--,vis[i]=1; printf("%d\n",m); for(int i=1;i&lt;=n;i++) if(!vis[i]) printf("%d ",sg[i].id); puts(""); return 0;&#125; By Elevator or Stairs?思路可以发现在每一层时,你是在电梯上还是在楼梯上是影响继续向后转移的,所以我们可以开$f_{i,j}$表示现在位于第$i$层,在/不在楼梯上时最小的时间花费.然后转移的话考虑是从上一层走楼梯来还是走电梯来即可. 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+10;int n,c;int A[N],B[N],f[N][2];int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; c; for(int i=2;i&lt;=n;i++) cin &gt;&gt; A[i]; for(int i=2;i&lt;=n;i++) cin &gt;&gt; B[i]; cout &lt;&lt; 0 &lt;&lt; " "; memset(f,0x3f3f3f3f,sizeof(f)); f[1][1] = c; f[1][0] = 0; for(int i=2;i&lt;=n;i++)&#123; f[i][0] = min(f[i-1][0]+A[i], f[i-1][1]+A[i]); f[i][1] = min(f[i-1][0]+B[i]+c, f[i-1][1]+B[i]); cout &lt;&lt; min(f[i][0], f[i][1]) &lt;&lt; " " ; &#125; return 0;&#125; Maximum Weight Subset思路update:(官方题解.我反正还没懂)😂我们设$f_{i,j}$表示现在是以$i$为根的节点,选中的点最浅深度是$j$时划分出子集的最大权值.初始化时显然$f_{i,0}=a_i$.显然这个是刚开始时没有子树的情况,然后我们一颗颗的添加子树.考虑怎么转移:因为我们一定是从底向上转移的,所以我们对于每个子树的根节点$i$,枚举一下这个点是继承的哪一颗子树的$f$,同时我们还要考虑其他子树对答案的贡献值,显然,距离可以直接进行转移).总的方程为:$f_{v,dep}=max(f_{v,dep},(dep==0?a_v:f_{v,dep-1})+\sum_{son_v}f_{son,max(dep-1,k-dep-1)})$.最终答案即为$f_{0,0}$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 210; int n, k;vector&lt;int&gt; a;vector&lt;vector&lt;int&gt;&gt; g, dp; void dfs(int v, int p) &#123; dp[v][0] = a[v]; for (auto to : g[v]) if (to != p) \ dfs(to, v); for (int dep = 0; dep &lt; N; ++dep) &#123; if (dep == 0) &#123; for (auto to : g[v]) &#123; if (to == p) continue; dp[v][dep] += dp[to][max(0, k - dep - 1)]; &#125; &#125; else &#123; for (auto to : g[v]) &#123; if (to == p) continue; int cur = dp[to][dep - 1]; for (auto other : g[v]) &#123; if (other == p || other == to) continue; cur += dp[other][max(dep - 1, k - dep - 1)]; &#125; dp[v][dep] = max(dp[v][dep], cur); &#125; &#125; &#125; for (int dep = N - 1; dep &gt; 0; --dep) dp[v][dep - 1] = max(dp[v][dep - 1], dp[v][dep]); return;&#125; int main() &#123; cin &gt;&gt; n &gt;&gt; k; ++k; a = vector&lt;int&gt;(n); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; &#125; g = vector&lt;vector&lt;int&gt;&gt;(n); for (int i = 0; i &lt; n - 1; ++i) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; --x, --y; g[x].push_back(y); g[y].push_back(x); &#125; dp = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(N)); dfs(0, -1); cout &lt;&lt; dp[0][0] &lt;&lt; endl; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高失联测D7]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E8%81%94%E6%B5%8BD7%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开. dls的生日礼物还是首先考虑无解的话会是什么情况,无解的话,一定是某一段长度大于$1$的区间被覆盖了两次以上,这个显然可以离散化来统计.然后我们再来想有解的情况,我们考虑,这道题让你把原来的区间分成两个集合,而相交的区间必须颜色不同.所以我们考虑到二分图模型.如果两个区间相交的话,那么这两个区间是要有边相连的.而因为我们已经排除了无解的情况,所以有解的情况一定会是一张二分图.即所有的连通块都是二分图.但是我们发现,如果暴力枚举区间连边的话是$O(n^2)$的,需要考虑怎么优化.我们又发现在某个连通块中,因为连通块中的点都是区间看成的点,所以一个连通块也就代表了一个区间,我们只需要考虑一下互不相交的连通块的个数$x$然后答案就是$2^x$. dls的生日宴会首先我们发现,如果我们按照$k=\frac{n}{2} , \frac{n}{4} , \frac{n}{8}$不断选取$k$的值的话,那么轮数为$logn$轮,即轮数最多为$logn$(向上取整)轮.我们假设我们一共操作了$m$轮,第$i$轮我们选择的$k$的值为$k_i$,那么如果满足能找到$dls$的话,需要满足 m]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Global Round 5题解]]></title>
    <url>%2F2019%2F10%2F21%2FGrobalRound5%2F</url>
    <content type="text"><![CDATA[传说中集齐了五颗无限宝石的$tourist$一个响指能让所有人的$rating$消失一半 Balanced Rating Changes发现在答案一定存在的情况下,对于每个偶数,一定是直接把$i$变成$\frac{i}{2}$.我们要考虑的就只有奇数的情况.显然,对于每个正数奇数和每个负数奇数,他们分别向上取整和向下取整的次数应该是一样多的.所以我们不如钦定刚开始无论正的奇数向下取整,负的奇数向上取整,然后扫一遍$check$即可.12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int change;int num[20000],ans[20000];int main()&#123; int T; scanf("%d",&amp;T); for(int i=1;i&lt;=T;i++)&#123; scanf("%d",&amp;num[i]); ans[i]=num[i]/2; change+=ans[i]; &#125; if(change==0) for(int i=1;i&lt;=T;i++) printf("%d\n",ans[i]); else&#123; if(change&gt;0)&#123; for(int i=1;i&lt;=T&amp;&amp;change!=0;i++)&#123; if(num[i]&lt;0&amp;&amp;num[i]%2==-1)&#123; change--; ans[i]--; &#125; &#125; &#125; else for(int i=1;i&lt;=T&amp;&amp;change!=0;i++) if(num[i]%2==1&amp;&amp;num[i]&gt;0)&#123; ans[i]++; change++; &#125; for(int i=1;i&lt;=T;i++) printf("%d\n",ans[i]); &#125; return 0;&#125; Balanced Tunnel考虑如果有一辆车在进入隧道行使的过程中没有被其他车超车的话,那么本来在它前边的车出去之后应该还在它前边(废话).考虑怎么判断这个东西,我们对于初始位置的车辆,我们记录一个$id_i$,即初始在$i$这个位置的车辆,它的$id$为$i$.然后我们发现在$id$这个东西,如果有一辆车$j$在车$i$的前方,那么$id_j$一定大于$id_i$.而如果本来有一辆车在它后边超过了它,那么在新的车辆中一定有一个$max(id_{i+1}…id_{n})&gt;id_i$(注意这里的标号为重排之后的标号.)那么我们只需要记录一个重排之后的车的$id$的后缀最大值,然后对于每辆车$i$,我们$check$一下前缀最大值是不是有比它小的从而可以不重不漏的$check$它有没有超车,然后统计答案即可.123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+10;int n;int pos[N],fin[N];int mins[N];int main()&#123; memset(mins,0x3f,sizeof(mins)); ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; pos[x]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; fin[i]=pos[x]; &#125; for(int i=n;i&gt;=1;i--) mins[i]=min(mins[i+1],fin[i]); int ans=0; for(int i=1;i&lt;n;i++) if(mins[i+1]&lt;fin[i]) ans++; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Balanced Removals (Easier)发现我们需要一个$O(n^2)$的算法.我们发现对于某个点$i$,那么距离它最近的点一定是最优的(因为中间不可能有其他的点).所以我们只需要对于每个点枚举一下目前没有用过的点中距离它最近的点即可.1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=2005;int n;struct Node&#123; int x,y,z;&#125; node[N];bool rem[N];inline int calc(int x,int y)&#123; return abs(node[x].x-node[y].x)+abs(node[x].y-node[y].y)+abs(node[x].z-node[y].z);&#125;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;node[i].x&gt;&gt;node[i].y&gt;&gt;node[i].z; for(int i=1;i&lt;=n;i++)&#123; if(rem[i]) continue; int mins=1e16,sign; for(int j=i+1;j&lt;=n;j++)&#123; if(rem[j]) continue; int val=calc(i,j); if(val&lt;mins)&#123; mins=val; sign=j; &#125; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;sign&lt;&lt;endl; rem[i]=1; rem[sign]=1; &#125; return 0;&#125; Balanced Removals (Harder)发现我们需要一个$O(nlogn)$的算法.而直接优化$Eazy$难度的算法貌似不怎么可能,所以我们考虑换方法.我们首先想怎么降维,我们对于$x$和$y$相等的先用贪心取最短的处理的话,那么发现$z$这一维就没啥用了.那么这个问题就转化成了二维的问题,然后我们再对于所有$x$相等的重复贪心取最短处理,这样的话我们只需要排两次序即可. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柯学上网教程]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%9F%AF%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[感觉我人要没.jpg “欸,你为啥能上Google啊?”这都$9102$年了,如果你还说你是用的某虚拟专线网络的话那你就8太彳亍了.毕竟…国外用着靠谱的那些东西,他们的价格是这样的:这样的还有这样的 emmmmm…如果你家里有矿的话你现在可以不要往下阅读了. 显然对于一般的家里没矿的普通人来说,这东西的价格显然不现实对趴.所以怎么办呢? 没钱,没办法,没钱你想什么柯学上网其实百度也挺好用的,不要想着用$Google$了,好好的做一个社会主义好青年趴(doge).]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>柯学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大图床稳定性测试]]></title>
    <url>%2F2019%2F10%2F21%2F%E5%9B%9B%E5%A4%A7%E5%9B%BE%E5%BA%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%B5%8B%E8%AF%95x%2F</url>
    <content type="text"><![CDATA[众所周知的360,新浪,百度,搜狗图床,到底谁最容易挂稳定呢 统一上传一张图,看看哪一个图床最后挂掉(我感觉退役之前是挂不完了) 新浪图床: 搜狗图床:update: 2019-10-23,它404了(新浪图床获胜). 百度图床:打假赛的百度图床选手提前倒下(doge) 360图床:打假赛的360图床选手提前倒下(doge) 感觉竞争并不会太激烈.jpg啥玩意有竞争吗? 我自己的github图床: 做个对比吧万一github没了就尴尬了 update:总结一下,因为百度图床和360图床直接上传失败,所以只有搜狗和新浪图床的竞争.搜狗图床只存活了两天….所以要是想要存图的话….还是用github的图床吧]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>无聊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普转提D5题解]]></title>
    <url>%2F2019%2F10%2F20%2F%E6%99%AE%E8%BD%AC%E6%8F%90D5%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 Zbox loves keyboard首先考虑直接递推,但是由于$Backspace$操作的存在,使得出现了后效性,所以貌似无法直接递推.然后我们考虑一下先不考虑$Backspace$怎么做.我们引入图论模型,把$[1,10^6]$中的每个值都看做一个点.然后我们考虑前几个操作,那么 对于每个点$x$,由$x$向$x+1$连接一条边. 对于每个点$x$,我们从小到大枚举$k$使得从$x$到$x \times k &lt;= n$连接一条边. 然后我们只需要从$x$向$n$跑一遍最短路即可(目测会卡某死掉的算法).然后我们再来考虑一下有$Backspace$怎么做.我们发现,如果我们从某个点$i$超级加倍到了$2 \times i$,而$2 \times i$比$n$大好多好多,那么我们在一个一个$Backspace$的时候一定会遇到一个$j (n&lt;j&lt;i)$可以从$x$转移到.所以我们瞎猜看题解看出来了$Backspace$操作的上界$100$,然后我们对于每个$i$,都向$[max(1,i-100),i-1]$的区间的点连边就好了. 这样的话我们计算一下时间复杂度发现边的数量为调和级数为$nInn$的复杂度,而我们跑一遍$Heap$_$Dijkstra$是$O(nlog_2m)$的.所以总复杂度为$O(n{log^2_2n})$.注意到$n$其实挺大的,所以需要卡卡常数(比如用斐波那契堆跑$Heap$_$Dijkstra$什么的) Zbox loves graph这道题正解好像真的是暴力(首先发现如果我们缩点缩出来一个$DAG$之后,对于每一个强连通分量我们可以开一个$bitset$来统计.但是如果强连通分量很多的话不行?发现一个题目中给定的一个重要的条件:因为这是一张随机图,所以强连通分量的个数一定不会太多,而且弱联通分量也不会太多.既然是暴力,那么我们考虑一下怎么卡常.首先$bitset$的常数小的一批.但是貌似直接做还是有点困难.我们考虑把所有的弱联通分量分别拿出来对里边的点进行重标号之后再分别做出来,然后直接对$bitset$进行一次$or$操作这样可以省去很多时间.剩下的….不说了我继续去卡常了 Zbox loves memory这个真的连正解是啥都不知道块状链表套$tire$,嗯这很SCP. ISN这道题听说树状数组优化下$DP$就过了,咱也不敢问. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取石子(概率期望)]]></title>
    <url>%2F2019%2F10%2F16%2F%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%85%A5%E9%97%A8%E5%8F%96%E7%9F%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[我看我是完全不懂哦 题面:其中$1&lt;=n&lt;=10^5$,$1&lt;=a_i&lt;=10^9$ 首先我们推广一下,概率具有可加性(也叫线性性).用公式解释就是$E(XY)=E(X)+E(Y)$.然后具体推广到这道题的话,我们设$E(t)$表示答案,那么$E(t)=[\sum_{i=2}^{n}P_i]+1$.其中$P_i$表示$i$这堆在$1$号堆之前被拿的期望.然后假设我们每次在$1$号堆和$x$号堆之间选择一堆的话,那么选择$x$号堆还是选择$1$号堆之间的相对概率是不受其他堆石子影响的.即$P_i=\frac{a_i}{a_i+a_1}$.那么答案很显然就是$ans=[\sum_{i=2}^{n}\frac{a_i}{a_1+a_i}]+ 1$时间复杂度为$O(n)$123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=1e5+10;int n;double a[N];signed main(void)&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; double ans=1.0; for(int i=2;i&lt;=n;i++) ans=ans+(a[i]/(a[1]+a[i])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Karen And SpuerMarket题解]]></title>
    <url>%2F2019%2F10%2F16%2FSuperMarket%2F</url>
    <content type="text"><![CDATA[九条可怜是个可爱的女孩子首先发现,题目中的对于使用优惠劵的条件的约束,如果建一张图出来,那么很容易就可以发现满足这是一棵树.所以我们考虑使用树形$DP$来解决问题.我们设$f_{i,j,0/1}$来表示在以$i$为根节点的子树中,选择$j$个使用优惠卷,当前的这个选/不选择优惠卷时能得到的最小花费.然后转移的时候枚举一下子树,因为体积都为$1$,所以可以根据经典的树上背包的优化把这道题优化到$O(n^2)$.考虑一下怎么转移,显然,当我们当前到达的$i$这个节点使用优惠券的话,那么它可以从它的子树中使用或者不用优惠卷的状态转移过来,如果当前的这个节点不适用优惠券的话,那么它就只能从它子树的不使用优惠券的状态转移过来. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define sz(x) ((int) (x).size())#define forn(i,n) for (int i = 0; i &lt; int(n); ++i)#define all(x) (x).begin(), (x).end()typedef long long ll;typedef long long i64;typedef long double ld;const int inf = int(1e9) + int(1e5);const ll infl = ll(2e18) + ll(1e10); const int maxn = 5005;int B;int c[maxn];int d[maxn];vector&lt;int&gt; g[maxn];int n; int kc[maxn][maxn];int kd[maxn][maxn];int cnt[maxn];int buf[2][maxn]; void merge(int *a, int *b, int *to, int c1, int c2) &#123; forn (i, c1 + c2 + 1) to[i] = inf; forn (i, c1 + 1) forn (j, c2 + 1) to[i + j] = min(to[i + j], a[i] + b[j]);&#125; void dfs(int u) &#123; for (int v: g[u]) dfs(v); int q = 0; forn (i, n + 1) buf[q][i] = inf; cnt[u] = 1; buf[q][0] = 0; buf[q][1] = c[u]; for (int v: g[u]) &#123; merge(buf[q], kc[v], buf[q ^ 1], cnt[u], cnt[v]); q ^= 1; cnt[u] += cnt[v]; &#125; forn (i, n + 1) kc[u][i] = buf[q][i]; q = 0; forn (i, n + 1) buf[q][i] = inf; cnt[u] = 1; buf[q][1] = c[u] - d[u]; for (int v: g[u]) &#123; merge(buf[q], kd[v], buf[q ^ 1], cnt[u], cnt[v]); q ^= 1; cnt[u] += cnt[v]; &#125; forn (i, n + 1) kd[u][i] = min(buf[q][i], kc[u][i]);&#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; B; forn (i, n) &#123; cin &gt;&gt; c[i] &gt;&gt; d[i]; if (i) &#123; int x; cin &gt;&gt; x; --x; g[x].push_back(i); &#125; &#125; dfs(0); int p = n; while (kd[0][p] &gt; B) --p; cout &lt;&lt; p &lt;&lt; '\n';&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces Round #592]]></title>
    <url>%2F2019%2F10%2F15%2FRound-592%2F</url>
    <content type="text"><![CDATA[我好菜啊 Pens and Pencils发现直接除一下,算出来分别需要多少铅笔和钢笔,最后看一下加起来是不是大于$k$即可.注意一个细节,假如我们有$8$个工作需求,然后一支铅笔可以解决$3$个的话,那么我们需要$3$支铅笔.所以我们不能直接算$a/x$,而是要算$(a+(x-1))/x$.1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int T; cin&gt;&gt;T; while(T--)&#123; int a,b,c,d,k; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;k; int ll=(a+(c-1))/c; int rr=(b+(d-1))/d; if(ll+rr&gt;k) puts("-1"); else cout&lt;&lt;ll&lt;&lt; " "&lt;&lt;rr&lt;&lt;endl; &#125; return 0;&#125; Rooms and Staircases首先考虑一下走楼梯对答案有什么好处.如果不走楼梯的话,那么答案一定就是$n$.我们设一个楼梯在房间$i$的位置,那么我们从$1$走到$i$时,如果选择从$i$这个点走下去的话.那么如果我们向右走,显然和直接不走楼梯没区别.而且根据题目中的限定,我们向初始走的位置的反方向走的时候就一定不能再回来了,所以我们的决策就是在每个楼梯的地方,判断一下是继续走的答案更优秀,还是走回去的答案更优秀,取最大值即可.123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int n;string s;int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while (T--)&#123; cin&gt;&gt;n&gt;&gt;s; int ans=-1; for(int i=0;i&lt;n;i++) if(s[i]=='1') ans=max(ans,2*(i+1)); int now=1; for(int i=n-1;i&gt;=0;i--)&#123; if(s[i]=='1') ans=max(ans,2*(now)); now++; &#125; if(ans==-1) ans=n; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; The Football Season现在不会x. Paint the Tree首先考虑判断一下无解的情况,由于每相邻的三个点都不能同色,而我们只能把这些点染成三种颜色.那么考虑某个节点$i$,如果和$i$直接相邻的点多于$2$个,那么无论如何都会有两个节点同色的.发现在上图(样例二)中,因为与节点$3$直接相邻的点为$3$个.所以这个情况是无解的.所以发现有解的情况只有是链的情况.而在一条链的情况下,如果我们确定了前两个节点的颜色的话,那么这条链的颜色也是一定可以被确定下来的.又因为前两个点的颜色只有$3 \times 2=6$种情况,所以我们可以直接暴力统计答案即可.时间复杂度为$O(6 \times n)$.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 5;int n, tot, rt, len, ansx, ansy;ll f[N][5][5], ans;int fr[N][5][5];int c[5][N];int head[N], deg[N], sen[N], res[N];struct Edge &#123; int u; int v; int next;&#125; e[N &lt;&lt; 1]; inline void addedge(int u, int v) &#123; e[++tot] = (Edge) &#123;u, v, head[u]&#125;; head[u] = tot; e[++tot] = (Edge) &#123;v, u, head[v]&#125;; head[v] = tot; return; &#125; void dfs1(int u, int fa) &#123; sen[++len] = u; for(register int i = head[u]; i; i = e[i].next) &#123; int v = e[i].v; if(v == fa) continue; dfs1(v, u); &#125; return; &#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=4;j++) for(int k=0;k&lt;=4;k++) f[i][j][k]=1e16; for(int i = 1; i &lt;= 3; i++) for(int j = 1; j &lt;= n; j++) cin&gt;&gt;c[i][j]; for(int i = 1; i &lt; n; i++) &#123; int u, v; cin&gt;&gt;u&gt;&gt;v; deg[u]++; deg[v]++; addedge(u, v); &#125; for(int i = 1; i &lt;= n; i++) if(deg[i] &gt;= 3) &#123; puts("-1"); return 0; &#125; for(int i = 1; i &lt;= n; i++) if(deg[i] == 1) &#123; rt = i; break; &#125; dfs1(rt, 0); for(int i = 1; i &lt;= 3; i++) for(int j = 1; j &lt;= 3; j++) &#123; if(i == j) continue; f[2][i][j] = min(f[2][i][j], (ll)c[i][sen[1]] + c[j][sen[2]]); &#125; for(int i = 3; i &lt;= n; i++) for(int j = 1; j &lt;= 3; j++) for(int k = 1; k &lt;= 3; k++) for(int t = 1; t &lt;= 3; t++) &#123; if(j == k || j == t || k == t) continue; if(f[i][k][t] &gt; f[i - 1][j][k] + c[t][sen[i]]) &#123; f[i][k][t] = f[i - 1][j][k] + c[t][sen[i]]; fr[i][k][t] = j; &#125; &#125; ans = f[0][0][0]; for(int i = 1; i &lt;= 3; i++) for(int j = 1; j &lt;= 3; j++) if(f[n][i][j] &lt; ans) &#123; ans = f[n][i][j]; ansx = i; ansy = j; &#125; res[sen[n - 1]] = ansx; res[sen[n]] = ansy; for(int i = n; i &gt;= 3; i--) &#123; int go = fr[i][ansx][ansy]; ansy = ansx; ansx = go; res[sen[i - 2]] = go; &#125; cout&lt;&lt;ans&lt;&lt;endl; for(int i = 1; i &lt;= n; i++) cout&lt;&lt;res[i]&lt;&lt;" "; return 0;&#125; Minimizing Difference这不是一眼题吗为什么要放到E上,放到C上不行吗发现我们每次操作的话肯定是对最大值或者最小值进行操作.所以我们先把原来的数组排序.然后我们每次枚举一下我们要把第几大的和第几小的进行操作,而这个操作显然可以双指针优化.12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int inf = 1e18 + 7;const int N = 1e5 + 10;int n, k,ans;int a[N], sum[N], cnt[N];signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++ i)&#123; cin &gt;&gt; a[i]; cnt[i] = 1; &#125; sort(a + 1, a + n + 1); ans = a[n] - a[1]; for (int i = 0; i &lt; n; ++ i)&#123; int l = 1 + i; int r = n - i; if (l &gt;= r) break; if (l + 1 != r)&#123; int can = k / (i+1); if (can == 0) break; int lim = a[l+1]-a[l] + a[r]-a[r-1]; ans -= min(lim, can); k -= min(lim, can) * (i+1); if (lim &gt; can) break; &#125; if (l + 1 == r)&#123; int can = k / (i+1); if (can == 0) break; int lim = a[r]-a[l]; ans -= min(lim, can); k -= min(lim, can) * (i+1); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI普转提D4]]></title>
    <url>%2F2019%2F10%2F13%2FZROI%E6%99%AE%E8%BD%AC%E6%8F%90D4%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 控制人偶发现我们只要算出来在一个循环中,坐标的变化值$(\Delta x , \Delta y)$.然后将变化值去乘循环时间的个数,最后多出来的暴力即可. 复杂度计算来我们开始一步一步的推公式(题目中要我们求的时间复杂度,写成多项式的形式就是: \sum_{i=1}^n\sum_{j=1}^m\sum_{k=i}^n\sum_{l=j}^m\sum_{x=i}^k\sum_{y=j}^l 1首先我们可以发现,最后的$x$和$y$的两维,因为是直接加起来的,所以可以直接变成$(l-j+1) \times (k-i+1)$,那么原来式就变成了 \sum_{i=1}^n\sum_{j=1}^m\sum_{k=i}^n\sum_{l=j}^m(l-j+1) \times (k-i+1)然后我们发现,同样的$(l-j+1)$和$(k-i+1)$分别都是被统计了$(m-j+1)$次和$(n-i+1)$次,所以由乘法分配律可知 \sum_{k=i}^n\sum_{l=j}^m(l-j+1) \times (k-i+1) = \sum_{k=i}^n[\sum_{l=1}^{m-j+1} \times (k-i+1)]发现$(k-i+1)$的系数可以直接等差数列求和,然后再将$\sum_{k=i}^n$拆开和等差数列求和公式之后就会得到 \sum_{i=1}^n\sum_{j=1}^m\sum_{k=i}^n\sum_{l=j}^m(l-j+1) \times (k-i+1) = \sum_{i=1}^n\sum_{j=1}^m\frac{(n-i+1) \times (n-i+2)}{2} \times \frac{(m-j+1) \times (m-j+2)}{2}将分母提取出来之后,可以得到原式等价于 \frac{\sum_{i=1}^n\sum_{j=1}^m (n-i+1) \times (n-i+2) \times (m-j+1) \times (m-j+2)}{4}然后继续固定$i$,我们发现系数满足$A_i=i^2+i$,那么根据$\sum_{i=1}^n i^2=\frac{n \times (n+1) \times (2 \times n + 1)}{6}$有原式等价于$[\frac{m \times ( m + 1 ) \times ( 2 \times m + 1) }{6} \times \frac{m \times (m+1)}{2}] \times [\frac{n \times (n+1) \times (2 \times n + 1 )}{6}+\frac{n \times ( n + 1 )}{2}] / 4$预处理逆元之后可以直接$O(1)$求出 复印任务我们注意到$1&lt;=t_i&lt;=10^3$.所以我们可以在很少的时间内怼同类时间的复印机进行预处理.由于我们知道每个复印机的启动时间,所以我们可以维护三个值.我们用$c_i$表示周期为$i$的复印机个数,$f_{t,p}$表示周期为$t$的复印机,且它的工作的起始时间对$t$取膜以后是$p$的个数(同时我们用$g$)表示$f$的后缀和.同时我们记录$s_t$表示所有周期为$t$的时间的复印机进入打印状态所欲要的$t$的时间周期有多少个.通过处理这三个数组,我们可以很快的计算同类周期的复读机在一段时间内的打印个数. 所以我们可以选择二分一个时间$T$,假设我们现在枚举的复印机的时间周期为$t$,那么我们发现能产生的复印件个数为$c_t \times (T/t) - s_j - f_{j,Tmodt+1} $然后我们把每个时间的加起来就是答案. A+B Problem二维树状数组裸题….直接安利我学习的博客了qwq.. 写的挺好的一篇博客 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI普及五联测D3]]></title>
    <url>%2F2019%2F10%2F12%2FZROI%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8BD3%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开. 旋风回旋曲由于可能的情况非常的小,所以我们只需要判断一下的几种情况: 从$x$直接走到$y$. 从$x$走到$a$,再从$b$走到$y$. 从$x$走到$b$,再从$a$走到$y$.由于只有三种情况,直接$3$个$if$判断一下即可. 假面饭店首先第一反应就是枚举每个数字取还是不取,所以我们需要$2^{size}$枚举每个数,但是显然还得枚举每个数的顺序,复杂度明显过不了.所以我们考虑枚举$i$来得到$i^2$.这样的话,发现我们最多是只需要枚举到$\sqrt{10 \times n}$即可.枚举的时候注意一下剪枝,不然就会$T$掉. 疯狂外星人发现我们可以枚举一下不能放入的物品是哪个.那么显然如果第$i$个物品不能放入的话,重量比$i$小的物品一定要都被放进去.然后再来考虑一下重量比$i$大的物品.发现我们可以用计数类的$01$背包来解决.最后需要注意一点,如果全都能放进去的话,也需要算一种方案,所以我们要枚举到第$n+1$个物品. 流浪地球发现维护连通块的消失的话,显然不怎么可做.所以我们尝试离线,我们把询问按照从大到小排序,然后每次从一个询问过渡到另外一个询问的时候,会出现若干个新的”大陆”.然后我们的任务就变成了这些新的大陆能不能和其他的连通块连起来.对于这一个操作,显然我们可以维护一个并查集,每次判断+合并几个连通块即可. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round74题解]]></title>
    <url>%2F2019%2F10%2F10%2FRound74%2F</url>
    <content type="text"><![CDATA[又安排了队友一手….. Prime Subtraction可以发现,如果只是用质数的话,那么除了$1$之外的数都是可以由质数凑出来的.所以只需要判断一波是不是相差为$1$即可.123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long a,b; int T; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;a&gt;&gt;b; if(a-b==1) puts("NO"); else puts("YES"); &#125; return 0;&#125; Kill ‘Em All发现如果我们打了一个按照坐标排序之后中间的数,那么对于右边的数字来说一定是劣的.所以我们发现,如果我们排序之后,从右往左开始打的话,那么对于答案的贡献一定不会更劣.所以直接排序之后从右往左打然后判断即可. 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; return s*w;&#125; const int N=1e5+10;int n,r;int pos[N];bool dis[N];inline bool cmp(int x,int y)&#123; return x&gt;y;&#125;signed main()&#123; int T=read(); while(T--)&#123; memset(dis,0,sizeof(dis)); n=read(),r=read(); for(int i=1;i&lt;=n;i++) pos[i]=read(); sort(pos+1,pos+1+n,cmp); int tag=0,ans=0; for(int i=1;i&lt;=n;i++)&#123; if(dis[pos[i]]) continue; if(pos[i]-tag*r&lt;=0) break; dis[pos[i]]=1; ans++; tag++; &#125; printf("%lld\n",ans); &#125; return 0;&#125; Standard Free2play我们来模拟一下一个人从高处到低处”掉下来”的过程.我们假设本来在外面的是$1$,不在外面的是$0$.考虑一个序列$11100$,如果我们站在最左边的那个$1$上,如果我们想要往右(即往下跳)的话,我们使用最左边的这个按钮,那么序列就会变成$00100$,而我们现在位于中间的那个$1$上.发现如果我们当前的位置到下一个$1$的位置,如果是连续的$1$的区间的话,那么我们一定只能跳奇数个段.如果两者的高度差大于$2$(即跳一下会摔死的话),那么就要么改变现在的状态,要么使用一个膜法石.显然,如果我们要跳到的这个位置到我们现在的这个位置中间间隔了偶数个紧贴着的即$111$这样的话,我们就需要使用膜法石,否则我们就不需要用膜法石.但是注意一下发现开头和结尾的位置是不一样的所以对位于顶端和末尾的情况特殊讨论一下即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;#define fore(i, l, r) for(int i = int(l); i &lt; int(r); i++)#define sz(a) int((a).size())#define x first#define y secondconst int INF = int(1e9);int h, n;vector&lt;int&gt; p;inline bool read() &#123; if(!(cin &gt;&gt; h &gt;&gt; n)) return false; p.resize(n); fore(i, 0, n) cin &gt;&gt; p[i]; return true;&#125;inline void solve() &#123; int ans = 0; int lf = 0; fore(i, 1, n) &#123; if (i &gt; 0 &amp;&amp; p[i - 1] &gt; p[i] + 1) &#123; if (lf &gt; 0) ans += (i - lf) &amp; 1; else ans += 1 - ((i - lf) &amp; 1); lf = i; &#125; &#125; if (p[n - 1] &gt; 1) &#123; if (lf != 0) ans += (n - lf) &amp; 1; else ans += 1 - ((n - lf) &amp; 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int tc; cin &gt;&gt; tc; while(tc--) &#123; read(); solve(); &#125; return 0;&#125; AB-string发现直接求的话貌似不怎么好求,所以我们考虑下求出所有的不好的串然后从总答案中减去.考虑怎求出所有不好的字串.首先发现只有$A$和$B$这两种字符,那么有一个很显然的结论:如果$s_i!=s_{i+1}$或者$s_i!=s_{i-1}$,那么$s_i$和$s_{i+1}$所在的字串一定是不好的.所以我们直接正反判断两边即可.1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int N=3e5+10;int n;long long ans;char str[N];inline void Solve(int x)&#123; int now=1,d=x; for(int i=2;i&lt;=n;i++)&#123; // cout&lt;&lt;str[i]&lt;&lt;" "&lt;&lt;str[i-1]&lt;&lt;endl;3 if(str[i] == str[i-1]) now++; else &#123; ans -= now-d; now = 1; &#125; &#125; return;&#125; int main()&#123; scanf("%d",&amp;n); scanf("%s",str+1); ans = 1ll*n*(n-1)/2; Solve(0); std::reverse(str+1,str+n+1); Solve(1); printf("%lld\n",ans); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kruscal重构树学习笔记]]></title>
    <url>%2F2019%2F10%2F09%2FKruskal%E9%87%8D%E6%9E%84%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学不会啊…. 以上就是性质,讲完了 你们不要打我QAQ… 一道例题(货车运输)我们看一下第五条性质,哎妈呀这道题不是裸题吗.我们跑一遍$Kruscal$重构树,然后询问的时候每两个点的答案,就是这两个在重构树上$LCA$的点权.然后就没了. 另一道例题(有没有大佬知道是哪个OJ上的题话告诉我谢谢) 第一反应是考虑每条边在作为权值最小的边的时候的贡献,但是发现这样也并不好统计最终贡献.所以根据这篇博客的标题,我们来考虑$Kruscal$重构树的做法.我们发现$Kruscal$重构树满足大根堆的性质,那么我们考虑某一个边权节点,他有贡献的路径很显然是它连接的叶子节点的路径一直到某个不在它子树内而且父亲节点大于它的节点.但是发现这样也并不好统计最终贡献.发现,如果重构树满足小根堆的性质的话,那么我们发现两点间路径边权的最小值就是他们的$LCA$,这样就方便统计答案了.所以我们考虑把所有的边权同乘$-1$,这样之后再建重构树.然后就可以统计答案了. 还有一道例题(有没有大佬知道是哪个OJ上的题话告诉我谢谢)也是$Kruscal$重构树的套路题…对于边权最大值的限制， 完全可以等价地转化到它们在最小瓶颈生成树上路径边权最大值的限制。考虑$Kruskal$重构树上一个点在只允许走边权$&lt;=k$的边的情况下能够到的点的集合,发现它们是一棵子树,且根为$s$的某个祖先.具体来说,是$s$到根路径上深度最小的点权$&lt;=k$的祖先我们可以倍增地找到这个祖先,接下来问题就转化为了经典问题:求一个子树当中的权值第k大.使用主席树可以轻松解决. 最后一道例题(归程)题面就不放了….因为每天开始的时候车的位置都会被重置一次,所以我们对于每次询问都可以在起点进行一次$bfs$,然后答案就是这些点中到$1$号点距离最小的点.但是这样…显然过不了…发现每次进行询问的时候都去$bfs$一遍显然太慢了,而且这道题为强制在线,也不能按照这些询问的海拔排序.那么我们怎么办呢?根据标题,我们可以选择$Kruscal$重构树来解决掉这道题.首先我们发现,$Kruscal$重构树满足大根堆的性质,那么满足海拔大于水位线的边组成的点一定是某一颗子树.然后我们可以进行一次堆优化的$Dijkstra$进行预处理,然后把$1$号点到每个点的最短路的长度记为重构树上新的点的点权.然后对于每次查询,我们的任务就变成了查询某颗子树中的叶子的权值最小值,而且是静态的.显然可以$log$的复杂度随便搞一搞. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>Kruscal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF416E]]></title>
    <url>%2F2019%2F10%2F09%2FCF416E%2F</url>
    <content type="text"><![CDATA[$ZROI$杂题选讲…. 看到这道题之后,我们第一反应肯定是一遍$Floyd$.然后考虑一下怎么判断某条边是不是被最短路覆盖.朴素的想法是我们每次枚举边,然后以这条边两条边的端点$u,v$再枚举这两个端点的所有最短路.即判断 dis(s,u)+w+dis(v,t)==dis(s,t)或者 dis(s,v)+w+dis(u,t)==dis(s,t)但是这样统计答案的话,由于边的条数为$n^2$的,所以这种算法的总复杂度为$O(n^4)$的.显然过不了所以我们考虑一下怎么优化.我们考虑上一个算法的时间复杂度的瓶颈,显然在我们枚举了$s,t$之后,因为还需要枚举每一条边,所以枚举边显然会超时.所以我们考虑一下枚举完$s,t$之后不再枚举每一条边,而是去枚举每一个中转点$p$.然后如果我们发现 dis(s,p)+dis(p,t)==dis(s,t)那么显然在$dis(s,p)$上以$p$结尾的边都是可以被加入的.所以我们现在的问题就只剩下了怎么求在$dis(s,p)$上的点了.发现我们就算暴力枚举每条边然后验证也并不会超时.所以直接这样做就可以了 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GXOI/GZOI2019]旅行者]]></title>
    <url>%2F2019%2F10%2F08%2FSNOI2017-%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[$ZROI$杂题选讲…..多点最短路?floyd直接莽啊我知道你很勇,但是这道题$10^5$真的没法直接莽啊… 考虑那$K$组特殊的点,我们发现如果我们把它们分成两组,然后由一组向另一种跑最短路,很明显可以得到答案.但是很显然不能只是分组分一次.我们考虑优化分组的过程.发现在考虑二进制之后,每两个互不相同的值一定最少会有一个不同的地方.所以我们如果对于每个点的编号,按照$1&lt;&lt;i$进行分类的话.一定可以保证在某一次分类的过程中,有任意两个点被分到了不同的集合内部.所以我们对这$K$组关键点进行二进制分组,然后建一个超级源点和一个超级汇点分别连接入集合和出集合.然后查询这个超级源和超级汇之间的最短路即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;inline LL read()&#123; LL x = 0,f = 1; char c = getchar(); while (c != EOF &amp;&amp; !isdigit(c)) &#123;if (c == '-') f = -1;c = getchar();&#125; while (isdigit(c)) &#123;x = x * 10 + c - '0';c = getchar();&#125; return x * f;&#125;inline void write(LL x)&#123; if (x &lt; 0) putchar('-'),x = -x; if (x &gt; 9) write(x/10); putchar(x%10+'0');&#125;inline void writeln(LL x)&#123; write(x),putchar('\n'); &#125;const int N = 100005,M = 500005;int Fr[M&lt;&lt;2],To[M&lt;&lt;2],Ne[M&lt;&lt;2],Dis[M&lt;&lt;2],He1[N],He2[N],_k;inline void add(int *He,int x,int y,int z)&#123; ++_k,Fr[_k] = x,To[_k] = y,Dis[_k] = z,Ne[_k] = He[x],He[x] = _k;&#125;int T,n,m,k,p[N];const LL INF = 1ll&lt;&lt;60;int f1[N],f2[N];LL dis1[N],dis2[N];LL ans;struct Node&#123; int x; LL d; Node (int xx = 0,LL dd = 0)&#123; x = xx,d = dd; &#125; inline bool operator &lt; (Node x) const&#123; return d &gt; x.d; &#125;&#125;t;priority_queue&lt;Node&gt;Heap;void Dij_1()&#123; int i; while (!Heap.empty()) Heap.pop(); for (i = 1; i &lt;= n; ++i) &#123; dis1[i] = INF; f1[i] = -1; &#125; for (i = 1; i &lt;= k; ++i) &#123; dis1[p[i]] = 0; f1[p[i]] = p[i]; Heap.push(Node(p[i],0)); &#125; int p,x; while (!Heap.empty())&#123; t = Heap.top(); Heap.pop(); if (t.d == dis1[t.x]) for (p = He1[t.x]; p ; p = Ne[p]) if (dis1[To[p]] &gt; dis1[t.x] + Dis[p])&#123; dis1[To[p]] = dis1[t.x] + Dis[p]; f1[To[p]] = f1[t.x]; Heap.push(Node(To[p],dis1[To[p]])); &#125; &#125; return;&#125;void Dij_2()&#123; int i; for (i = 1; i &lt;= n; ++i) &#123; dis2[i] = INF; f2[i] = -1; &#125; for (i = 1; i &lt;= k; ++i) &#123; dis2[p[i]] = 0; f2[p[i]] = p[i]; Heap.push(Node(p[i],0)); &#125; int p,x; while (!Heap.empty())&#123; t = Heap.top(); Heap.pop(); if (t.d == dis2[t.x]) for (p = He2[t.x]; p ; p = Ne[p]) if (dis2[To[p]] &gt; dis2[t.x] + Dis[p])&#123; dis2[To[p]] = dis2[t.x] + Dis[p]; f2[To[p]] = f2[t.x]; Heap.push(Node(To[p],dis2[To[p]])); &#125; &#125; return;&#125;int main(void)&#123; int i,u,v,w; T = read(); while (T--)&#123; _k = 0; memset(He1,0,sizeof(He1)); memset(He2,0,sizeof(He2)); n = read(),m = read(),k = read(); while (m--)&#123; u = read(); v = read(); w = read(); if (u^v) &#123; add(He1,u,v,w); add(He2,v,u,w); &#125; &#125; for (i = 1; i &lt;= k; ++i) p[i] = read(); Dij_1(); Dij_2(); ans = INF; for (i = 1; i &lt;= n; ++i) if (f1[i] ^ f2[i]) ans = min(ans,dis1[i] + dis2[i]); for (i = 1; i &lt;= _k; i += 2) if (f1[Fr[i]]^f2[To[i]]) ans = min(ans,dis1[Fr[i]] + dis2[To[i]] + Dis[i]); writeln(ans); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF938D题解]]></title>
    <url>%2F2019%2F10%2F08%2FCF938D%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$ZROI$杂题选讲…..刚开始的时候看见题目中要求的这个式子貌似不知道从何开始想….首先发现$2 \times d(i,j)$这个东西可以直接在存边的时候把边权变成两倍即可.但是剩下的那个加$a_j$貌似很难处理,每次暴力枚举么?显然不行.我们考虑一下,对于这个数据范围来说,显然只能跑一遍最短路,所以我们考虑怎么在一遍最短路的过程中求出每个点的答案.但是这样做的话,显然要把所有的$a_i$联系起来,怎么办呢?建虚点√我们新建一个虚点,然后由这个虚点向每个点$i$连一条边权为$a_i$的边.然后我们考虑一下原来的那个式子,发现这样的话原来的式子就变成了求$min(2\times d(i,j)+d(new,j))$.再考虑一下最短路的松弛操作,是不是发现了啥.我们直接从新建的虚点开始跑一遍最短路,然后对于每个点,$dis_i$就是答案了.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define int long long#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , date = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) date = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * date;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , date = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) date = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * date;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 1e6 + 10;int n , m , t;int head[N];struct Edge&#123; int to; int date; int next;&#125;e[N];int dis[N];bool vis[N];std :: priority_queue &lt; std :: pair &lt; int , int &gt; , std :: vector &lt; std :: pair &lt; int , int &gt; &gt; , std :: greater &lt; std :: pair &lt; int , int &gt; &gt; &gt;qu;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].date = z; e[t].next = head[x]; head[x] = t; return;&#125;signed main ( void ) &#123; read ( n , m ); for(int i=1;i&lt;=m;i++)&#123; int x,y,z; read(x,y,z); add(x,y,2*z); add(y,x,2*z); &#125; for(int i=1;i&lt;=n;i++)&#123; int x=_read(); add(n+1,i,x); &#125; memset(dis,0x3f,sizeof(dis)); dis[n+1]=0; qu.push(MP(0,n+1)); while ( !qu.empty () ) &#123; int j = qu.top().se; qu.pop (); if ( vis[j] ) continue; vis[j] = 1; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].date ) &#123; dis[k] = dis[j] + e[i].date; if ( !vis[k] ) qu.push ( MP ( dis[k] , k ) ); &#125; &#125; &#125; F ( i , 1 , n ) printf ( "%lld%c" , dis[i] , i == n ? '\n' : ' ' ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4479题解]]></title>
    <url>%2F2019%2F10%2F08%2FHDU4479%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$ZROI$杂题总结… 发现我们需要保证边权递增,但是似乎并没有什么方法.所以我们考虑将边权排个序,然后将边权从小到大开始考虑.这样之后,当我们先默认边权都互不相同时,我们每次以一条边去更新它两端的节点.如果能更新的话,显然在经过的节点上,一定是先经过边权较小的路径,再经过边权较大的路径.这样之后可以保证我们求的就一定是题目中要求的答案.然后发现其实边权并不是互不相同的,所以可以将边权一样的边分成一组,每次操作的过程中去用这组中的一坨边去更新. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; return s*w;&#125;const int N=1e4+10;const int M=1e5+10;const LL oo=0x3f;int n,m,t;LL dis[N];bool updated[N];struct Edge&#123; int from; int to; LL date;&#125;lis[M];int v[N];LL vdis[N];inline bool cmp(Edge x,Edge y)&#123; return x.date&lt;y.date;&#125;inline void work(int l,int r)&#123; int cnt=0; for(int i=l;i&lt;=r;i++)&#123; int ll=lis[i].from,rr=lis[i].to; if(updated[ll]&amp;&amp;dis[rr]&gt;lis[i].date+dis[ll])&#123; v[++cnt]=rr; vdis[cnt]=lis[i].date+dis[ll]; &#125; if(updated[rr]&amp;&amp;dis[ll]&gt;lis[i].date+dis[rr])&#123; v[++cnt]=ll; vdis[cnt]=lis[i].date+dis[rr]; &#125; &#125; for(int i=1;i&lt;=cnt;i++)&#123; dis[v[i]]=min(dis[v[i]],vdis[i]); updated[v[i]]=1; &#125; return;&#125;int main(void)&#123; int T=read(); while(T--)&#123; t=0; memset(updated,0,sizeof(updated)); n=read(),m=read(); for(int i=1;i&lt;=n;i++)dis[i]=oo; dis[1]=0; updated[1]=1; for(int i=1;i&lt;=m;i++)&#123; int x=read(),y=read(); LL z=read(); lis[++t].from=x; lis[t].to=y; lis[t].date=z; &#125; sort(lis+1,lis+1+t,cmp); lis[t+1].date=oo; for(int i=1;i&lt;=t;i++)&#123; int l=lis[i].from,r=lis[i].to; int j; for(j=i+1;j&lt;=t+1;j++) if(lis[j].date!=lis[i].date) break; work(i,j-1); i = j-1; &#125; if(dis[n]&gt;=oo) puts("No answer"); else printf("%lld\n",dis[n]); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI国庆七天乐D5]]></title>
    <url>%2F2019%2F10%2F07%2FZROI%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%90D5%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开要是CSP的D1这么考我估计我今年又凉了 添经过观察之后发现,在没有任意三线共点的情况下,答案只可能是$1,2,3$当中的一个.然后发现答案吧为$1$的情况只有在所有直线都相互平行或者$n$小于$2$的情况下会成立.然后考虑答案为$2$的情况,发现只有两组平行线集合,而且总线段的个数大于$2$的情况时,会发现答案为$2$.剩下的情况就是答案为$3$的情况. 罐装首先按照国王游戏的套路来推一波贪心的式子.然后发现得到了$p_i \times t_j &gt; p_j \times t_i$移项之后就有$\frac{p_i}{t_i}&gt;\frac{p_j}{t_j}$.然后我们按照这个东西排序,每次修改的时候都暴力做一遍,总复杂度为$O(m\times nlogn)$,就可以拿到$70$分的好成绩.然后我们又发现,每次修改时只会修改一个点,这样的话每次修改的时候都重新做一遍,感觉非常的浪费.我们考虑一下,我们修改一个点的时候,对其他点的贡献的影响.我们发现如果我们修改的那个位置,在排完序之后在原来序列中的位置为$pos$的话,我们如果把这个点先去掉的话,那么从$pos+1$到$n$的位置的数的贡献都会增加$t_{pos} \times \sum_{i=pos+1}^np_i$然后我们考虑一下修改的过程,等价于我们把一个位置删去,然后再在这个区间中插入我们要修改的数值,这个过程中要进行两次区间$sum$. 所以用权值线段树或者平衡树等数据结构维护即可. 三千米这道题是不可能补的,这辈子都不可能补的 总结:难度差不多$noip$的$d1$难度吧(甚至还要低)….但是我这个得分就….算了我太菜了/kk 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国庆七天乐D1]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%90D1%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开w 幸福题目中要我们去求$\sum_{i=0}^n F_i$我们发现直接去由$f$数组去递推$F$数组的话时间复杂度是$O(n^2)$的,显然过不了,所以我们要推一波式子.由题意可知 F_i=\sum_{i=0}^n f_i\times f_{n-i}我们发现$f_i=f_{i-1}+f_{i-2}$,那么我们把$f_0$和$f_1$单独拿出来之后,上边的式子就可以拆成 F_i=\sum_{i=2}^n [(f_{i-1}+f_{i-2}) \times f_{n-i}]+f_0 \times f_n + f_1 \times f_{n-1}再根据万能的加法结合律,我们把上式中的几个$\sum$拆分魔改之后得到 F_i=\sum_{i=0}^{n-1} f_i \times f_{n-i-1} + \sum_{i=0}^{n-2} f_i \times f_{n-i-2} + f_0 \times f_n - f_1 \times f_n + f_0 \times f_n然后发现前边那两个$\sum$的式子分别是$F_{i-1}和F_{i-2}$,又因为$f_0=f_1=1$,带入这个式子之后我们可以得到: F_i=F_{i-1}+F_{i-2}+f_i然后就可以愉快的矩乘求出来了.但是因为我比较菜,只会用矩阵快速幂求第$i$项,但是题目中要求你求$\sum_{i=0}^nF_i$,我们怎么办呢?然后我们来考虑一下怎么用矩阵快速幂的过程中直接求出前缀和. 我们想一下矩阵乘法的过程,因为我们的目标矩阵是由原来的矩阵和我们构造的矩阵相乘得到的,如果我们中间构造一个$01$矩阵的话,矩阵乘法就可以看成是矩阵中的元素不断的相加,所以原理上在矩阵快速幂的过程中是可以直接求出我们要求的数列的前缀和的.我们以求斐波那契数列的前缀和为例子,因为我们知道,一个$n \times m$的矩阵与一个$m \times k$的矩阵相乘之后,我们得到的矩阵是一个$n \times k$的矩阵.所以我们考虑在我们原来构造的矩阵中加上一位,这样的话矩阵就变成了{$f_i,f_{i+1},\sum_{j=1}^{i+1}f_j$}.相应的,在我们构造的矩阵中,我们可以通过使$f_i与f_{i+1}$都被加入我们新加的一维来达到更新前缀和的目的.综上,我们可以在求$F_i$的矩阵中加一维表示前缀和,然后直接矩阵快速幂即可.时间复杂度为$O(logn)$,可以通过本题 树链剖分先考虑暴力怎么写.我们发现如果根节点被确定了的话,我们提前用树上差分统计出每个点被经过了多少次之后,可以直接贪心的去找答案.所以这样的话我们必须要枚举根节点.这样的话复杂度也是显然过不了.我们先钦定一个节点作为根节点,然后我们考虑每个节点作为根节点的情况.显然发现某个点的在原树上的儿子节点是不受影响的,所以我们可以预先进行一次$dfs$来确定我们发现,如果某个节点$i$与我们当前的这个即将要成为根的节点不相邻的话,那么这个点$i$是很显然不会受到影响的(该怎么走还得怎么走)我们考虑从上往下的顺序进行$DFS$，然后每次求出当前节点作为根时的最小代价。显然，与当前节点不相邻的边不受这个节点的影响，因此我们可以直接求出.又因为孩子方向的在第一次$DFS$中预处理了，而父亲方向的在刚刚$DFS$的过程中求出。然后求出与当前节点相邻的边中，最大的以及次大的，根据$DFS$的孩子选择是去掉最大的还是次大的即可。 小E和小F strikes again这道题是不可能补的,这辈子都不可能补的 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #588 (Div. 2)题解]]></title>
    <url>%2F2019%2F09%2F27%2FCF588%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[lyt我对不起你啊/ll Dawid and Bags of Candies其实我们按照大小排序了之后,我们发现可能的答案只有第$1,4$组成或者第$4$个单独组成,判断一下即可.注意精度,不然直接除$2$的时候可能会被卡. Ania and Minimizing发现如果把高位变小了之后,那么答案一定会变得更优.所以我们直接从高位向低位贪心即可.注意判断$k$为$0$的情况. Anadi and Domino$emmmmm….$看题面就非常高大上然后我们认真读了读题发现真的很高大上.看一眼数据范围,$n&lt;=7$,所以我们考虑一下枚举与每个点相连的边的颜色.然后我们直接暴力$check$即可.对不起数据范围小真的可以为所欲为1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;int G[10][10];int col[8],ans;bool used[7],uc[7][7];void Prep()&#123; memset(uc,false,sizeof(uc)); return;&#125;inline void check()&#123; Prep(); int tmp=0; for(int i=1;i&lt;=n;i++)&#123; if(col[i]==0) continue; for(int j=i+1;j&lt;=n;j++)&#123; if(!G[i][j]||!col[j]) continue; if(!uc[col[i]][col[j]])&#123; uc[col[i]][col[j]]=1; uc[col[j]][col[i]]=1; tmp++; &#125; &#125; &#125; ans=max(ans,tmp);// if(tmp==21)&#123;// for(int i=1;i&lt;=n;i++)// cout&lt;&lt;col[i]&lt;&lt;" ";// exit(0); // &#125; return;&#125;void dfs(int x)&#123; if(x==n+1)&#123; check(); return; &#125; for(int i=0;i&lt;=6;i++)&#123; col[x]=i; dfs(x+1); &#125; return;&#125;int main ( void ) &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; G[x][y]=1; G[y][x]=1; &#125; memset(col,-1,sizeof(col)); dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;// Main Code Marcin and Training Camp我们考虑到,如果一个人$i$和另一个人$j$能看顺眼的话,只有$j$是$i$的子集才可以.然后如果在某个分组里,$j$已经是某个$i$人的子集了,那么$j$一定是可以被选出的.所以我们的任务就变成了找到所有的$a_k$只出现过一次或者不是其他出现过两次或多次的$a_i$的子集合的$k$.然后从$sum$中将这些不合法的状态删去即可. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习笔记]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数论果然博大精深,但是我啥都没听懂 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCP-114514]]></title>
    <url>%2F2019%2F09%2F23%2FSCP1%2F</url>
    <content type="text"><![CDATA[qwq SCP-114514 研究社 等级: Keter 特殊收容措施: 目前SCP-114514无法被收容,目前基金会的目的是使SCP-114514保持不再发生变化. 项目描述: 已知SCP-114514曾经的名称有信息学,OI,国际象棋,围棋,五子棋,羽毛球,篮球,OSU,植物大战僵尸,外卖K歌研究社.已知项目会在随机的时间进行名称上的变化.目前已经证实,在每次项目的名称发生改变时,项目内的人员(称之为$SCP-114514-1919810$)的兴趣爱好会随着研究社的名称发生变化. 经过研究发现,SCP-114514内的人员爱好需要的物件似乎并不需要从外界获取,会有一个被称为$SCP-114514-1$的被称为$Z$主任的人形实体供给,而供给的物品似乎是从内部自然产生的. 在每次项目的名称发生改变时,会强制将项目周边距离不超过$10m$的人员强制转化为$SCP-114514-1919810$,已知这一影响不可逆.而且在普通人员被强制转化后,会在[数据删除]的时间之内丧失对文化课学习的兴趣. 常人暴露在SCP-114514面前是致命的,所以对于SCP-114514的任何接触需要3名及以上四级权限者的允许,且实验者在实验后将被强制隔离$3$天,如果在隔离时间之内实验者表现了明显的兴趣爱好变化,那么实验者将会被处决. 对于SCP-114514的进一步研究报告为致命媒介模因,需要得到O5议会的批准之后访问. 您好,监督者,已取消对机动特遣队的派遣指令.]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>SCP乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #587题解]]></title>
    <url>%2F2019%2F09%2F22%2FCodeforcesRound-587%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[LYT我对不起你啊/ll Prefixes经过观察私信找规律之后发现,对于每个偶数的前缀$i$,如果$i&gt;2$且$i$这个前缀满足条件,那么$i/2$也一定会满足条件.所以我们要满足的就是对于每个最小的间隔为$2$的区间,使他们当中有一个$a$和一个$b$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 2e5 + 10; int n , ans;char ss[N]; int main() &#123; read ( n ); scanf ( "%s" , ss + 1 ); int s1 = 0 , s2 = 0; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( ss[i] == 'a' ) s1++; else s2++; if ( i % 2 == 0 ) &#123; if ( s1 == s2 ) continue; ans++; if ( s1 &gt; s2 ) ss[i] = 'b'; else ss[i] = 'a'; s1 = 0; s2 = 0; &#125; &#125; writeln ( ans ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%c" , ss[i] ); return 0; &#125; Shooting通过观察样例可知,从大到小排序即可qwq… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 1005; int n;struct Node &#123; int val; int pos;&#125;ls[N]; ll ans; inline bool cmp ( Node x , Node y ) &#123; return x.val &gt; y.val;&#125; int main() &#123; read ( n ); F ( i , 1 , n ) &#123; ls[i].val = _read (); ls[i].pos = i; &#125; std :: sort ( ls + 1 , ls + 1 + n , cmp ); F ( i , 1 , n ) ans += ls[i].val * ( i - 1 ) + 1; writeln ( ans ); F ( i , 1 , n ) printf ( "%d " , ls[i].pos ); return 0; &#125; White Sheet发现如果这个白色矩形的四条边都被覆盖了的话,那么中间一定也被覆盖了.然后暴力枚举判断即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ struct Point&#123; int x; int y;&#125;p[7];int main ( void )&#123; for(int i=1;i&lt;=6;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); if(p[3].x&lt;=p[1].x&amp;&amp;p[3].y&lt;=p[1].y&amp;&amp;p[4].x&gt;=p[2].x&amp;&amp;p[4].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[5].x&lt;=p[1].x&amp;&amp;p[5].y&lt;=p[1].y&amp;&amp;p[6].x&gt;=p[2].x&amp;&amp;p[6].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[3].x&lt;=p[1].x&amp;&amp;p[4].x&gt;=p[2].x&amp;&amp;p[5].x&lt;=p[1].x&amp;&amp;p[6].x&gt;=p[2].x)&#123; if(p[3].y&lt;=p[1].y&amp;&amp;p[4].y&gt;=p[5].y&amp;&amp;p[6].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[5].y&lt;=p[1].y&amp;&amp;p[6].y&gt;=p[3].y&amp;&amp;p[4].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; &#125; if(p[3].y&lt;=p[1].y&amp;&amp;p[4].y&gt;=p[2].y&amp;&amp;p[5].y&lt;=p[1].y&amp;&amp;p[6].y&gt;=p[2].y)&#123; if(p[3].x&lt;=p[1].x&amp;&amp;p[4].x&gt;=p[5].x&amp;&amp;p[6].x&gt;=p[2].x)&#123; printf("NO\n"); return 0; &#125; if(p[5].x&lt;=p[1].x&amp;&amp;p[6].x&gt;=p[3].x&amp;&amp;p[4].x&gt;=p[2].x)&#123; printf("NO\n"); return 0; &#125; &#125; printf("YES\n"); return 0;&#125; Swords发现求个$gcd$就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 2e5 + 10; int n , maxs;int num[N];ll ans , sum; int main() &#123; read ( n ); F ( i , 1 , n ) &#123; num[i] = _read (); maxs = max ( maxs , num[i] ); &#125; F ( i , 1 , n ) &#123; int res = ( maxs - num[i] ); ans = std :: __gcd ( ans , res * 1ll ); &#125; if ( ans == 0 ) &#123; puts ( "0 0" ); return 0; &#125; else &#123; F ( i , 1 , n ) sum += ( maxs - num[i] ) / ans; printf ( "%I64d %I64d\n" , sum , ans ); &#125; return 0; &#125; Numerical Sequence (easy version)发现$k$只有$10^9$的范围,所以就暴力跳就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std; #define LL long long#define N 40010 LL sum[N],T; int judge(int x) &#123; int count = (int)log10((double)x) + 1; return count;&#125;int fun(int x) &#123; int sum = pow(10,x); return sum;&#125;void solve() &#123; int sumn = 0; memset(sum, 0,sizeof(sum)); for(int i = 1 ; i &lt; 40005 ; ++i) &#123; sumn += judge(i); sum[i] = sum[i - 1] +sumn; &#125;&#125;void answer(int x) &#123; int j,ans,summ,i = 1; while(sum[i] &lt; x) i++; ans = x - sum[i -1]; summ = 0; for(j = 1 ; j &lt;= i ; ++j) &#123; summ += judge(j); if(summ &gt;= ans) break; &#125; if(summ == ans) printf("%d\n", j %10); if(summ &gt; ans) printf("%d\n", (j / fun(summ -ans)) % 10);&#125; int main() &#123; scanf("%lld",&amp;T); solve(); while(T--) &#123; int pos; scanf("%d",&amp;pos); answer(pos); &#125; //system("pause"); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普转提七连测D3]]></title>
    <url>%2F2019%2F09%2F22%2FP%E8%BD%ACTD3%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 序列我们考虑化简式子: (x^2+y)^2\equiv(x^2-y)^2+1\pmod{p}两边的平方式展开之后再合并同类项之后可有 4x^2y\equiv1\pmod{p}我们发现,如果我们把$4x^2$看作一个整体,那么$y$就是$4x^2$在膜$p$意义下的逆元.所以我们现在的任务变成了找对于每个$num_i$,$4num_i$的逆元有多少个又因为题面中说了数字互不相等,所以我们完全可以使用$unordered$_$map$统计.注意去重即可,时间复杂度$O(nlogINTMAX)$ 汽水乍一看并莫得啥思路.然后我们想一下,如果我们把每个糖浆的浓度都减少$n$的话,那么我们的任务就变成了怎么凑出$0$浓度的任务.然后我们建立一个图论模型:我们设$dis_i$表示凑到$i+n$这个浓度时最少用的糖浆是多少,显然可以使用$bfs$求最短路. 树我们发现,最优解一定是原来的某些连通块相互连接形成的,然后就没了qwq DAG首先推广一个结论:如果最长路是$x$,那么一定存在一个$x+1$的染色方案.我们对于每一条边$(i-&gt;j)$,我们规定只能从颜色小的点走向颜色大的点.然后考虑这样的话我们就划分成了一个分层图.然后又因为我们要让最长路最短,说白了就是要让层数最少.而我们又发现同层的点之间没有边,等价于一个独立集.所以我们的任务就转化成了把这张图划分成最少的独立集个数,使得他们的并集为这一张图.又因为我们发现数据范围很小,只有$17$,所以我们可以考虑状压$DP$来解决这个问题.我们设$f_i$表示我们目前选择的点的总集为$i$的时候的最小的独立集个数.我们预处理出从$0$到$(1&lt;&lt;n)-1$中的每个状态是否为独立集,然后我们在每次枚举状态$i$的时候,显然$i$这个状态只能从它的某个为独立集的子集转移过来.转移很显然,$f_i=min(f_j+1)$$(j$为$i$的子集且$j$这个集合为独立集). 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高失联测D4]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E8%81%94%E6%B5%8BD4%2F</url>
    <content type="text"><![CDATA[罗小黑真尼玛好看 罗其实暴力有$60$分,只需要判断一下上下是否相等即可.对于其他的情况,我们发现如果我们只有一个*的话,就可以匹配所有的字符串,所以*的个数最多只有一个.然后我们再考虑一下万能字符串(能匹配所有长度有下界的字符串的字符串)长什么样子.显然是*???????????????然后我们考虑一下,我们对于某两个字符串xxxx*xxxxx*xxx和xxxx*xxxxxx.我们发现答案中的那个*一定会匹配原来两个串中所有的*.那么我们最终构造出来的那个串的长度一定就是原来两个字符串中所有非*的最小值加一. 然后我们考虑了之前的条件之后,发现我们可以枚举我们的这个*之前的长度$L_1$.对于*之后的长度我们可以算出来.然后对于原来的两个字符串之前的$L_1$位,我们可以像白给的$60$分那样做匹配来这样的话我们最后把所有答案拿出来,比较一下字典序和$?$的个数,就能在$O(n)$的复杂度内解决这道题.但是这样的复杂度对于这道题来说显然不够优秀,所以我们考虑怎么优化这个算法.我们发现两个答案不一样的地方一定是*,所以我们可以分别从左向右和从右向左递推出以$i$为*的位置时,左边$?$的个数和右边$?$的个数.这样的话我们就可以用$O(n)$的时间复杂度构造出所有断点$i$的左边和右边的符号是不是问号以及问号的个数,而通过这些东西就可以构造出答案.然后我们在所有的答案中,贪心的先找出一个$?$的个数最小的串,然后再在这些串里找出$L_1$最小的串(因为$L_1$小的话说明第一个出现的*位置靠前,字典序小).然后根据这个构造最后的串就好了. 小首先有一个结论:一个不超过$T$的数有$loglogT$个质因子.这样的话,如果我们每次枚举区间,然后$check$答案的话,就得到了一个$O(n^3loglogT)$的方法.发现这个方法还是太$naive$,我们来尝试优化一下,我们发现,如果我们枚举区间,然后在区间右移的时候维护现在出/进区间的元素的话,我们可以把枚举+$check$的复杂度从$O(n^2)$降低到$O(n)$这样的话就是$O(n^2loglogT)$了,可以通过$60$分. 考虑每个质因子在每个区间中的贡献,假设我们现在枚举的质因子是$p$,那么对于位置$i$上的数字$num_i$如果存在质因子$p$,那么我们记$pre_{i,p}=1$,否则的话记录$pre_{i,p}=-1$.这样枚举区间的时候,我们可以直接从这个区间的区间和是否大于等于$0$来判断.这样之后复杂度还是$O(n^2loglogT)$,还需要进一步优化. 我们还是先枚举每个质因子,然后我们令$p_1,p_2,……,p_k$为这个质因子第$1,2,3….k$次出现的位置.在我们把$p$数组排序之后,我们发现,如果我们能找到一个$p_j-p_i+1&lt;=2\times(j-i+1){j&gt;i}$,那么我们就找到了一组$2\times(j-i+1)$的解.我们把这个式子移项之后有$p_j-2\times j&lt;=p_i-2\times i+1$.显然,我们可以按照$p_i-2\times i$来排序.最后我们枚举$j$之后,由于我们的排序方式,我们可以发现$p_j-2\times j&lt;=p_i-2\times i$一定是会被满足的,所以我们只需要找一个$max(j-i+1)$即可.然后我们发现这个东西显然是可以二分或者双指针直接找的,总复杂度为$O(nloglogTlogn)$. 黑暂时先黑一会~ 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普及五连测D2]]></title>
    <url>%2F2019%2F09%2F21%2FPJ%E4%BA%94%E8%BF%9E%E6%B5%8BD2%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 安排座位首先我们可以算出对于每一排,我们可以排出来多少座位,以及一共需要多少排才能把座位排完.然后我们考虑插入走廊的事情要使得尽量多的位置在走廊边上, 于是在 n 列中插入走廊的策略是显然的, 我们只要以两列为单位, 在其中插入即可．有一些边界情况需要考虑清楚． 加法问题我们考虑如果满足式子$a \times 10^x+b \times 10^y$=$c \times 10^z$,那么一定有$a,b,c$这三个数在乘方之后的位数最少是$len_c&gt;=len_{a,b}$首先我们将$c$的末位数补齐,然后我们发现,$c$一定是由$a,b$相加进位之后得到的. 我们固定$a,b$为$len_c$位和$len_{c-1}$位,然后我们枚举$0$的个数之后判断. 这样的话貌似要写高精度,其实不用,我们知道$hash$就是以一个$base$进制来表示数的方式,如果我们的$hash$中的$base$设为$10$,那么一个原本的$10$进制数在$hash$之后,可以直接用哈希值加减来判断. 有趣的数经过我们快乐的打表之后发现,对于$k$进制下的末尾有奇数个$0$的数,有$m=a \times k^p(p\equiv1\pmod{2},!a\equiv0\pmod{k})$.有了这个结论,我们就可以快速的统计出在$[1,n]$的区间中,符合条件的数字的个数.又因为两个数的相对大小关系不会因为进制而改变,所以我们可以二分区间上界来找到我们要找的第$n$个数. 与非门树我们发现,对于某一个节点,无论是否发生故障,那么它的状态一定只有$0$和$1$两种.所以我们可以设$f_{i,0/1,0/1}$,表示现在是第$i$个点,理论状态为$0/1$,实际状态为$0/1$时的方案数. 乍一看貌似不怎么可转移,我们想,对于理论状态为$0$,实际状态也为$0$的状态一定是只能从子树为全$0$和全$1$的状态转移而来.然后对于理论状态和实际状态相异或为$1$的状态,但是我们可以通过输入为$0$或者$1$的状态减去输入全$0$的状态快速得到．然后对于$f_{i,1,1}$的这种状态,我们可以用所有的总状态减去其他的所有状态达到. 总结:比较基础的树形$DP$+简单容斥即可.(气稽败坏.png) 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 73题解]]></title>
    <url>%2F2019%2F09%2F20%2FCF%E9%A2%98%E8%A7%A3%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[qwq A.2048 Game我们发现,我们可以忽略掉$2048$以上的数,剩下的数开桶统计然后贪心即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 105;int n; ll num[N];int used[2050];int main ( void ) &#123; int T = _read (); while ( T-- ) &#123; memset ( used , 0 , sizeof ( used ) ); n = _read (); F ( i , 1 , n ) &#123; num[i] = _read (); if ( num[i] &lt;= 2048 ) used[num[i]]++; &#125; if ( used[2048] ) &#123; puts ( "YES" ); continue; &#125; for ( int i = 1 ; i &lt;= 1024 ; i *= 2 ) used[i * 2] += ( used[i] / 2 ); if ( used[2048] ) puts ( "YES" ); else puts ( "NO" ); &#125; return 0;&#125; B.Knights我们贪心的考虑一下,如果我们现在这个位置的骑士,在它能移动的八个方向上,都会碰到其他的骑士,那么这个位置对答案的贡献一定是最优的. 结合样例,我们可以发现这样一种构造方法,我们从点$(1,1)$开始进行一次$bfs$,然后按照骑士的移动方法,每次更新一层,然后把这一层的骑士染色成和现在的骑士颜色不一样的颜色. 对于剩下的,那么可以证明没有任何点能跳到这个点,所以随便什么颜色都可以. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/int n;char mp[105][105];const int dx[] = &#123; 0 , 1 , 1 , -1 , -1 , 2 , 2 , -2 , - 2 &#125;;const int dy[] = &#123; 0 , 2 , -2 , 2 , -2 , 1 , -1 , 1 , -1 &#125;;void dfs ( int x , int y , char col ) &#123; mp[x][y] = col; for ( int i = 1 ; i &lt;= 8 ; i++ ) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if ( xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= n &amp;&amp; mp[xx][yy] != 'W' &amp;&amp; mp[xx][yy] != 'B' ) dfs ( xx , yy , col == 'W' ? 'B' : 'W' ); &#125; return;&#125;int main ( void ) &#123; n = _read (); dfs ( 1 , 1 , 'W' ); bool flag = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= n ; j++ ) &#123; if ( mp[i][j] == 'W' || mp[i][j] == 'B' ) printf ("%c",mp[i][j]); else &#123; printf ("%c" , flag?'B':'W'); flag ^= 1; &#125; &#125; puts(""); &#125; return 0;&#125;// Main Code C.Perfect Team一个直观的感觉就是你从$c,m$中取一个$Min$,然后我们会发现可能人数凑不够$Min*3$,所以我们判断一下$min(Min,sum/3)$就是答案了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/int n;int c , m , x;int main ( void ) &#123; int T = _read (); while ( T-- ) &#123; read ( c , m , x ); int mins = min ( c , m ); int sums = c + m + x; printf ( "%d\n" , min ( mins , sums / 3 ) ); &#125; return 0;&#125;// Main Code D.Make The Fence Great Again毒瘤出题人一个DP数据范围开3e5 看到$3e5$的数据范围,第一反应就是贪心,但是发现貌似不怎么可做?然后开始考虑$DP$,发现如果$i$这个点被升高了的话,貌似对后边的点是有影响的,有后效性,怎么办?我们经过观察可知,如果一个点要升高,那么它最多升高两次,所以我们可以设$f_{i,j}$表示现在是第$i$个位置,其中$i$这个位置升高了$j$次. 转移的话很显然,我们枚举一个最小的$f_{i-1,k}$并且要保证$fence_{i-1}.high+k$不等于$fence_i.high+j$然后转移就好了. 时间复杂度的话是$O(n*16)$硬核O(nlogn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define int long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 3e5 + 10;int n , idx;struct Node &#123; int hi; int vi;&#125;fence[N];int f[N][5];signed main ( void ) &#123; int T = _read (); while ( T-- ) &#123; n = _read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; read ( fence[i].hi , fence[i].vi ); for ( int j = 0 ; j &lt;= 4 ; j++ ) f[i][j] = 1e17; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 0 ; j &lt;= 4 ; j++ ) &#123; for ( int k = 0 ; k &lt;= 4 ; k++ ) &#123; if ( fence[i].hi + j == fence[i - 1].hi + k ) continue; f[i][j] = min ( f[i][j] , f[i - 1][k] ); &#125; if ( f[i][j] == 1e17 ) continue; f[i][j] += 1ll * j * fence[i].vi; &#125; &#125; int ans = 1e17; for ( int i = 0 ; i &lt;= 4 ; i++ ) ans = min ( ans , f[n][i] ); writeln ( ans ); &#125; return 0;&#125;// Main Code 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO09FEB]改造路Revamping Trails题解]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%94%B9%E9%80%A0%E8%B7%AF%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[复习了一波分层图…. 可以发现这道题就是分层图裸题.我们可以设$dis_{time,i}$表示现在已经用了$time$次免费机会,到达了$i$这个点的时候的最短路径.那么我们在进行堆优化$Dijkstra$时($SPFA$跑分层图一般会死的很惨),我们对于每次转移时,判断一下是否使用一次免费机会即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define K 25#define N 10005#define M 4200005#define F(i,a,b) for(int i=a;i&lt;=b;i++)#define G(i,a,b) for(int i=head[a];i;i=b[i].next)using namespace std;int n,m,k,t,start,end;struct Edge&#123; int to; int data; int next;&#125;e[M];struct Que&#123; int time,cur; Que(int a,int b):time(a),cur(b)&#123;&#125;&#125;;int head[N],vis[K][N];bool inque[K][N];int ans=2147483647;struct cmp &#123; bool operator () ( Que x , Que y ) &#123; return vis[x.time][x.cur] &gt; vis[y.time][y.cur]; &#125;&#125;;priority_queue &lt; Que , vector &lt; Que &gt; , cmp &gt; qu;void add (int x,int y,int z)&#123; e[++t].to=y; e[t].data=z; e[t].next=head[x]; head[x]=t; return;&#125;inline void spfa (int x)&#123; memset(vis,0x3f3f3f3f,sizeof(vis)); vis[0][x]=0; inque[0][x]=1; qu.push(Que(0,1)); while (!qu.empty())&#123; Que j=qu.top(); qu.pop(); inque[j.time][j.cur]=0; G(i,j.cur,e)&#123; int k=e[i].to; if (vis[j.time][k]&gt;vis[j.time][j.cur]+e[i].data)&#123; vis[j.time][k]=vis[j.time][j.cur]+e[i].data; if (!inque[j.time][k])&#123; inque[j.time][k]=1; qu.push(Que(j.time,k)); &#125; &#125; &#125; if (j.time&lt;k) G(i,j.cur,e)&#123; int k=e[i].to; if (vis[j.time+1][k]&gt;vis[j.time][j.cur])&#123; vis[j.time+1][k]=vis[j.time][j.cur]; if (!inque[j.time+1][k])&#123; inque[j.time+1][k]=1; qu.push(Que(j.time+1,k)); &#125; &#125; &#125; &#125; F(i,0,k) ans=min(ans,vis[i][n]); return;&#125;int main()&#123; scanf ("%d%d%d",&amp;n,&amp;m,&amp;k); F(i,1,m)&#123; int x,y,z; scanf ("%d%d%d",&amp;x,&amp;y,&amp;z); add (x,y,z); add (y,x,z); &#125; spfa(1); printf ("%d\n",ans); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>DP</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高失恋测D3]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E6%81%8B%E6%B5%8BD3%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 最长01子序列我们首先考虑暴力,我们发现,一个串的形式,是由它中间的$0$的个数所决定的,而中间$0$的个数是由前导$0$的个数所决定的.所以我们可以枚举前导$0$的个数,从而贪心匹配即可,这样复杂度为$O(n^2)$,能拿到60分. 我们接着来考虑怎么优化这个过程,我们发现,我们匹配的过程,就是经过一段$0$之后,找到下一个$1$的位置,而随着位置从左向右,前缀的$0$的个数是单调递增的,所以我们可以考虑二分优化.我们对于现在的位置$i$(初始情况下为$0$,且假设我们现在枚举的前导$0$的个数为$x$)我们要找的就是满足$fro[pos]-fro[i]&gt;=x$的最左边的位置,而这个位置显然可以二分处理.我们计算一下复杂度,发现这种方法的复杂度为$\sum_{i=1}^n\frac{n}{i}$=$O(nIn n)$.便可以通过此题. 路径长度先考虑暴力,我们可以把到达每一个点的所有值用背包记录下来,这样有$40$分. 然后我们考虑这个过程,我们发现,如果我们考虑三个距离$x,y,z$的话.如果这三个距离,满足$z&lt;=1.1x&lt;=1.1y&lt;=1.1z$的话,那么$y$这个距离完全可以不要.原因的话,我们发现,我们要求的是到一个点的距离满足在区间$[dis,1.1dis]$之间的路径,那么如果这里的$y$满足$dis&lt;=y&lt;=1.1dis$的话,那么$x$和$z$当中一定会有一个满足这个条件的.所以我们可以根据这个条件,不记录所有的距离.又因为$1.1^{420}$大概等于$10^{17}$,所以我们只需记录$420$个左右的距离.同时,在合并两个集合时,如果我们用归并排序时,可以做到$O(A+B)=O(logM)$. 动态矩阵最短路我们先考虑一维的情况:对于每一次的操作,我们可以把这一列看成一个点,然后我们维护一下这个点最后一次被清空的时间点.然后对于每次询问,我们只需要查询一下两个点中间的最前一次被清空的时间到现在是不是小于$v$即可. 发现这种做法貌似很容易推广到二维的情况,对于行和列,我们分别建线段树.然后我们判断一下两个点之间的各种连接情况然后判断答案即可.貌似需要写线段树上二分. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces round585题解]]></title>
    <url>%2F2019%2F09%2F15%2Fround585%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[A.傻逼题,暴力枚举即可(我也就只会傻逼题了) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)#define G(i,a,b,c) for(rint a=head[b];a;a=c[a].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 10005;int n , a1 , a2 , k1 , k2 , idx;int num[N];inline bool cmp1 ( int x , int y ) &#123; return x &gt; y;&#125;inline bool cmp2 ( int x , int y ) &#123; return x &lt; y;&#125;int main ( void ) &#123; read ( a1 , a2 , k1 , k2 , n ); for ( int i = 1 ; i &lt;= a1 ; i++ ) num[++idx] = k1; for ( int i = 1 ; i &lt;= a2 ; i++ ) num[++idx] = k2; std :: sort ( num + 1 , num + 1 + idx , cmp1 ); int ans = 0; int tmp = n; for ( int i = 1 ; i &lt;= idx ; i++ ) if ( tmp &lt; num[i] ) &#123; tmp = 0; break; &#125; else tmp -= num[i] - 1; if ( tmp == 0 ) printf ( "%d " , ans ); else printf ( "%d " , tmp ); std :: sort ( num + 1 , num + 1 + idx , cmp2 ); ans = 0 , tmp = n; for ( int i = 1 ; i &lt;= idx ; i++ ) if ( tmp &lt; num[i] ) break; else &#123; ans ++; tmp -= num[i]; &#125; printf ( "%d\n" , ans ); return 0;&#125;// Main Code B.分从后往前现在的数的正负性讨论即可,负负得正. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 4e5 + 10;int n;ll num[N] , s[N];ll tai,fro;ll odd,uodd;int main ( void ) &#123; read ( n ); F ( i , 1 , n ) &#123; num[i] = _read (); s[i] = s[i - 1] ^ ( num[i] &lt; 0 ); if ( s[i] == 1 ) &#123; tai += odd; fro += uodd; odd++; fro++; &#125; else &#123; tai += uodd; fro += odd; tai++; uodd++; &#125; &#125; std :: cout &lt;&lt; fro &lt;&lt; " " &lt;&lt; tai &lt;&lt; std :: endl; return 0;&#125; C.发现只有$A$和$B$,两种字符,很容易发现规律. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/char s[3][200005];int n , sum;int can1,can2,bc;int cnt1[200005],cnt2[200005];int main()&#123; read ( n ); scanf ( "%s%s" , s[1] , s[2] ); for(int i=0;i&lt;n;i++)&#123; if(s[1][i]!=s[2][i])&#123; if(s[1][i]=='a')&#123; can1++; cnt1[can1]=i+1; &#125; else&#123; can2++; cnt2[can2]=i+1; &#125; &#125; &#125; if(n%2==1)&#123; puts ( "-1" ); return 0; &#125; if(can1%2==1)&#123; sum+=2; sum+=(n-2)/2; writeln ( sum ); printf ( "%d %d\n" , cnt1[1] , cnt1[1] ); printf ( "%d %d\n" , cnt1[1] , cnt2[1] ); for(int i=2;i&lt;=can1;i+=2) printf ( "%d %d\n" , cnt1[i] , cnt1[i + 1] ); for(int i=2;i&lt;=can2;i+=2) printf ( "%d %d\n" , cnt2[i] , cnt2[i + 1] ); return 0; &#125; sum=(can1+can2)/2; writeln ( sum ); for(int i=1;i&lt;=can1;i+=2) printf ( "%d %d\n" , cnt1[i] , cnt1[i + 1] ); for(int i=1;i&lt;=can2;i+=2) printf ( "%d %d\n" , cnt2[i] , cnt2[i + 1] ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普转提七连测D2]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%99%AE%E4%B8%93%E6%8F%90D2%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 T1.首先$naive$的做法就是枚举一下从$L$到$R$的数然后判断是否合法,复杂度为$O((R-L)*log_{10}n$) 然后正解是暴力暴力出奇迹 我们可以发现这种数是十分稀疏的,所以我们可以考虑枚举每一个特殊的数字,然后判断每一个数字是否在区间$[L,R]$之内.时间复杂度为$O(17^2*9^2)$. T2.我们首先记录一下每个字符的前缀和$A_i,B_i,C_i$我们考虑怎么判断一个区间合法:如果在一个区间$[l,r]$当中,$A_{l-1}-B_{l-1}==A_{r}-B{r}$,同时$B_{l-1}-C_{l-1}==B_r-C_r$.所以我们考虑一下,如果对于每个$i$,我们把$A_i-B_i$和$B_i-C_i$看成两个二元组,那么我们的任务就是去寻找有几对二元组相同. T3.先考虑一下能组成$11$的倍数的数的特征:奇数位和偶数位的和的差的绝对值对$11$取模的结果为$0$.所以我们枚举一下每个数字分到奇数位还是偶数位即可,这样是$O(2^n)$的,可以通过$60$分的数据. 我们考虑一下,如果分到了奇数位或者偶数位,那么他的位置和被放的先后顺序是无关紧要的,换句话说,也就是无后效性.所以我们考虑用背包实现这个过程,我们可以设$f_{i,j,k}$表示前$i$个数中,选了$j$个放在奇数位,能不能使和变成$k$. 然后我们就可以统计答案了. T4.我们通过思考发现,如果现在面前只有$1$个或者$2$个怪物的话,如果我们放一次重击和放一次$AOE$,那么我们的收益是相同的(在现在生命值最小的怪物不能被一次打死的情况下).所以我们要按照生命值从小到大排序. 我们发现,如果现在怪物的数量$num &gt;= 3$,那么我们放一次群攻的话,收益一定比放一次重击要大.所以我们就可以直接贪心了. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据生成]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[图和树的数据生成器 图有向图和无向图同样适用的数据生成器,可生成随机图 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;using namespace std;int n,m,s,T;inline int random() &#123; static int seed = s; return seed = (int)(seed*48271ll%2147483647);&#125;set&lt;int&gt;to[100005];//去重int main() &#123; srand ( time ( NULL ) ) ; cin &gt;&gt; T; cout &lt;&lt; T &lt;&lt; endl; while(T--) &#123; s = rand(); n = 96; m = 102; printf("%d %d \n",n,m); for(int i = 1 ; i &lt;= m ; i++) &#123; int u = random() % n + 1; int v = random() % n + 1; while(to[u].find(v) != to[u].end() || u == v) &#123; u = random() % n + 1; v = random() % n + 1; &#125; printf("%d %d\n",u,v); to[u].insert(v); &#125; printf("\n"); &#125; return 0;&#125; 树保证数据为一棵随机树 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;using namespace std;int a[10005],e[10005][2];int n = 1000;bool flag[10005];int main() &#123; freopen("testdata.in","w",stdout); printf("%d\n",n); for(int i = 1 ; i &lt;= n ; i++) &#123; a[i] = rand() % n + 1; while(flag[a[i]]) a[i] = rand() % n + 1; flag[a[i]] = 1; &#125; for(int i = 2 ; i &lt;= n ; i++) &#123; e[i-1][0] = a[i]; e[i-1][1] = a[rand() % (i - 1) + 1]; &#125; memset(flag,0,sizeof(flag)); for(int i = 1 ; i &lt; n ; i++) &#123; int x = rand() % (n - 1) + 1; while(flag[x]) x = rand() % (n - 1) + 1; flag[x] = 1; int f = rand() % 2; if(f) printf("%d %d\n",e[x][0],e[x][1]); else printf("%d %d\n",e[x][1],e[x][0]); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>知识水平</category>
      </categories>
      <tags>
        <tag>数据制造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普及五联测D1]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8BD1%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 运算根据某些大佬说可以直接把所有的数加起来就是答案,但是因为我这个人比较弱所以就只会$DP$了我们设$f[i][0/1]$表示前$i$个数字中,在从第$i-1$次到第$i$次的转移时用了加/异或的最大值,转移显然.update:其实异或可以看作不进位加法,那么一坨数异或起来的答案一定不会大于这一坨数加起来的值(因为二进制下某两位的异或不会对下一位造成影响,而加法会).所以最后的答案显然就是所有的数加起来. 颜色我们可以发现每个数字,从他现在的位置开始,到他下一次出现的地方为止就是这个数字有贡献的区间,然后我们按照区间个数统计答案就好了 袋鼠我们发现如果按照题解从小到大排序之后,那么能被放下的一定是$[1,(n+1)/2]$这个区间里的数.然后我们可以双指针扫一下,遇到能装的就装一定更优. 树我们发现,一个性质,如果一条链的两个顶点的$LCA$在第三条链上,那么这两条链一定会有交点.所以我们可以用树上差分统计一下每个点被经过了多少次,然后我们考虑一下去重.我们发现,如果一个点被多条链的$LCA$同时经过了一个点的话,那么在这个点上,答案会被重复统计多次,所以我们只需要统计一下每个点上$LCA$出现的次数然后组合数学去重即可. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解:树]]></title>
    <url>%2F2019%2F09%2F12%2F%E9%A2%98%E8%A7%A3-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[暴力都不想写的题… 考虑到题目中要求的最小的那个东西不太好求所以我们可以找一个最大的符合条件的值,我们记为$tmp$,那么有$ans=tmp+1$ 那我们考虑一下这个$tmp$怎么求.发现和树的直径这个东西类似,然后就没啦x 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI普转提D1题解]]></title>
    <url>%2F2019%2F09%2F11%2FZROI%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[版权问题,题面不公开 T1.显然可以发现这个区间长度满足单调性(设$len1&gt;len2$,那么如果$len2$满足条件,$len1$一定满足条件.).所以我们可以考虑二分答案.我们设$buck[i][j]$数组来表示前$i$个数中,$j$这个数字出现了多少次(就是一个前缀和).但是这样的话我们会发现数据的权值是$10^9$范围的,直接开一个桶会挂掉(开$map$会$TLE$,,,不要问我咋知道的),所以我们考虑先对数据离散化.然后对于每一次二分,我们可以$O(n)$枚举区间,然后枚举权值,对于每个枚举的区间可以$O(n)$check每种权值,总复杂度为$O(n^2log_2n)$ T2.显然可以发现,题目中要求的个位数字只受要除的数的个位的影响,所以我们在求出来了倍数的个数$num$时,可以发现,个位数字的出现是有周期的,而这个周期和周期中的数字是由要除的数字的个位决定的.而因为要除的数字的个位最多只有10个,所以我们可以先预处理出每个数字的周期以及他们的和,再对多出来的部分直接暴力就可以了. T3.第一眼看上去发现限制有点多,但是分析一下,一个物品能不能放只受到了它放的时间以及它上边最多放多少东西的限制.所以对于时间这一方面的限制,我们可以考虑对时间这一维进行排序. 讲的很明白,但是我并不知道怎么证明qwq D.第一眼看来貌似不怎么可做… 自己观察之后我们发现直接求所有的方案数貌似不太可做…所以我们考虑一下容斥. 我们设$f_i$为包含了状态$i$以及状态$i$的所有子集的方案数.那么我们考虑一下怎么容斥. 我们以$n=3$的情况为示范.(不要吐槽我是灵魂画师) 我们可以发现,对于某个状态$j$,当这个状态中的$1$的个数的奇偶性等于$(1&lt;&lt;m)-1$的个数时,那么可以发现此状态的m容斥系数为$1$,否则,该状态的容斥系数为$-1$. 所以我们可以初步的列出一个式子: ans=\sum_{i=0}^{(1]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散步]]></title>
    <url>%2F2019%2F09%2F11%2F%E6%95%A3%E6%AD%A5%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这题好难啊 首先可以发现可以二分答案. 我们可以考虑二分一个最长的路径长度$mid$,然后将每个点看成不能在最多连续走$mid$个相同的路的情况下,从$1$号点到$n$号点是否联通. 然后现在的问题就变成了判断图的连通性的问题.我们发现,每个点只有两条出边.而且每种类型的出边只有一条,那么可以发现同样的类型的路径的走路的路径,可以看作一个集合.我们可以设$dis_{i,siz}$表示$i$这个点一直按照$siz$类型的路径一直走,最后一段$siz$路径的长度,然后我们发现,如果$i$这个点走到$j$这个点时,那么$dis_{j,siz}=dis_{i,siz}+1$,而我们发现这个东西显然可以用带权并查集来维护.在使用了带权并查集之后,我们每次就可以在$O(logn)$的时间复杂度内求出以某个点为起点走到最远能走到那个点了.然后我们可以进行一次$bfs$.在某次更新中,可以发现,如果现在到达这个点的最后的路径是$siz$类型的话,如果现在这个点连向的$siz xor 1$类型的点还没有被入队过,那么就将这个点扔进队里. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 2e5 + 10; int n;int G[N][2];int father[N][2] , dis[N][2];bool vis[N][2];struct Node &#123; int pos; int kid;&#125;;std :: queue &lt; Node &gt; qu;int find ( int x , int kd ) &#123; if ( father[x][kd] != x ) &#123; int tmp = father[x][kd]; father[x][kd] = find ( father[x][kd] , kd ); dis[x][kd] += dis[tmp][kd]; &#125; return father[x][kd];&#125;inline bool check ( int rdm ) &#123; memset ( vis , false , sizeof ( vis ) ); memset ( dis , 0 , sizeof ( dis ) ); F ( i , 1 , n ) father[i][0] = father[i][1] = i; qu.push ( Node &#123; 1 , 0 &#125; ); qu.push ( Node &#123; 1 , 1 &#125; ); while ( !qu.empty() ) &#123; int j = qu.front().pos; int siz = qu.front().kid; qu.pop(); int now = 0; while ( 1 ) &#123; int root = find ( j , siz ); now = dis[j][siz]; if ( now + 1 &gt; rdm ) break; int kt = G[root][siz]; int kj = find ( kt , siz ); if ( !vis[kt][siz ^ 1] ) &#123; vis[kt][siz ^ 1] = 1; qu.push ( Node &#123; kt , siz ^ 1 &#125; ); &#125; if ( kj == root ) break; father[root][siz] = kt; dis[root][siz] = 1; &#125; &#125; if ( vis[n][0] || vis[n][1] ) return 1; return 0;&#125;int main ( void ) &#123; read ( n ); F ( i , 1 , n ) &#123; G[i][0] = _read(); G[i][1] = _read(); &#125; int l = 0 , r = n + 1; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( check ( mid ) ) r = mid - 1; else l = mid + 1; &#125; if ( l &gt; n ) puts ( "-1" ); else writeln ( l ); return 0;&#125;// Main Code 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 72 题解报告]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[qwq A.第一眼看上去貌似是个找规律$O(1)$题,实际看了一下,确实是找规律$O(1)$题.所以就开始愉快的找规律,于是就有了以下的提交记录: emmm…. QAQ然后我们考虑一下正解. 我们设原来我们有$str in exp$,我们设我们分给$str x$点的$exp$,分给$in y$点的$exp$,那么显然有: x+y=exp \ and \ str+x>in+y发现上边的这个方程,通过将$y$用$exp-x$代替之后,我们可以解出$x$的具体范围.而且我们可以发现:所有$x$的取值范围一共只有$exp + 1$种,所以就可以愉快的求出答案了. 最后别忘了判断$exp$为$0$的情况. 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; int str,in,exp; cin&gt;&gt;str&gt;&gt;in&gt;&gt;exp; if (exp==0)&#123; if(str&gt;in) cout&lt;&lt;"1"&lt;&lt;endl; else cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; if(in+exp-str&lt;0)&#123; cout&lt;&lt;exp+1&lt;&lt;endl; continue; &#125; int ans=min(exp+1,(exp+1)-max(0ll,((in+exp-str)/2+1))); if ( ans &lt; 0 ) ans = 0; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; B.这么可爱的怪兽我怎么可能忍心去打它呢 我们看到题,首先想到,如果我们砍一刀,这个怪兽不死,那么它如果长出来的头大于我们我们这次砍掉的头.那么我们这次的操作显然没用.所以,在前几刀砍不死怪兽的情况下,我们需要最大化每一次砍头时的$d_i-h_i$,同时我们发现.在某一次砍头中,如果这次的$d_j$非常大,大到一下子可以把怪兽剩下的头砍完.我们就可以不用管这次砍头的副作用$h_j$了. 所以我们维护两个最大值,即$d_i-h_i$的最大值以及$d_i$的最大值,然后直接找题意做即可. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n,x;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; int maxs=-1e16; int Damage=-1e16; cin&gt;&gt;n&gt;&gt;x; for(int i=1;i&lt;=n;i++) &#123; int tx,ty; cin&gt;&gt;tx&gt;&gt;ty; maxs=max(maxs,tx); Damage=max(Damage,tx-ty); &#125; if ( x &lt;= maxs ) &#123; cout &lt;&lt; "1" &lt;&lt; endl; continue; &#125; if(Damage&lt;=0)&#123; cout&lt;&lt;"-1"&lt;&lt;endl; continue; &#125; int now = ( x - maxs ) / Damage; if ( now * Damage &lt; x - maxs ) now+=2; else now++; cout&lt;&lt;now&lt;&lt;endl; &#125; return 0;&#125; C.通过读题,我们可以发现一个很重要的东西:$\sum_{i=1}^t len_i&lt;=2*10^5$. 通过这个性质,我们可以发现,我们在枚举每一次的区间时,这个区间的最长长度为$log_2len$. 然后就做完了?? 我们枚举一下每个区间的左/右端点,然后直接暴力统计答案就好了. 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int N = 200000 + 10;int t,nex[N];char s[N];int main() &#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",s+1); int n=strlen(s+1); nex[n+1]=n+1; for(int i=n;i&gt;=1;i--) &#123; if(s[i]=='0') nex[i]=nex[i+1]; else nex[i]=i; &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; int now=0; for(int j=nex[i];j&lt;=min(n,nex[i]+20);j++)&#123; now=now*2+s[j]-'0'; if(now==j-i+1) ans++; &#125; &#125; printf("%d\n", ans); &#125;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round #582解题报告]]></title>
    <url>%2F2019%2F09%2F11%2FRound-2%2F</url>
    <content type="text"><![CDATA[qwq A.Chips Moving题意就是给你n个数,你每次可以选择一个数,对他进行免费的加2或者减2.或者花费1的代价,对某个数进行加一或者减一,求让所有的数变成一样的最小代价. 很显然可以发现,奇数和奇数之间可以相互转变,偶数和偶数之间也可以相互转变,那么我们只需要考虑让奇数全部变成偶数或者让偶数变成奇数就好了. 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int cnto = 0; for (int i = 0; i &lt; n; ++i) &#123; int x; cin &gt;&gt; x; cnto += x &amp; 1; &#125; cout &lt;&lt; min(cnto, n - cnto) &lt;&lt; endl; return 0;&#125; B.Bad Prices题意就是给你一个序列$A$,让你求出所有$A_i$中,$\sum_{i=1}^n[A_i&gt;A_{j(i&lt;j&lt;=n)}?0:1]$ 显然可以直接维护一个后缀最小值,然后判断一下当前$A_i$的值和当前后缀最小值的大小关系,如果$A_i&gt;num_i$,那么ans++ 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std; const int N=150005; int n;int num[N];int mins[N]; int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(mins,0x3f3f3f3f,sizeof(mins)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;num[i]); for(int i=n-1;i&gt;=1;i--) mins[i]=min(mins[i+1],num[i+1]); int ans=0; for(int i=1;i&lt;n;i++) if(num[i]&gt;mins[i]) ans++; printf("%d\n",ans); &#125; return 0;&#125; // C.Book Reading显然可以发现,题目中要求的个位数字只受要除的数的个位的影响,所以我们在求出来了倍数的个数$num$时,可以发现,个位数字的出现是有周期的,而这个周期和周期中的数字是由要除的数字的个位决定的.而因为要除的数字的个位最多只有10个,所以我们可以先预处理出每个数字的周期以及他们的和,再对多出来的部分直接暴力就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define int long long using namespace std; int n,m;int ned[10],idx[10];int sum[10][10]; signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); for(int i=1;i&lt;=9;i++)&#123; int now=i; sum[i][++idx[i]]=i; now+=i; while(now!=i)&#123; if(now&gt;=10) now-=10; sum[i][++idx[i]]=now; now+=i; &#125; &#125; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=idx[i];j++) ned[i]+=sum[i][j]; int T; cin&gt;&gt;T; while(T--)&#123; int ans=0; cin&gt;&gt;n&gt;&gt;m; int numm=n/m; int tmp = m; tmp%=10; if(tmp==0||numm==0)&#123; cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; int fir = numm/idx[tmp]; ans+=fir*ned[tmp]; // cout&lt;&lt;fir&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl; int sos=0; for(int i=fir*idx[tmp]+1;i&lt;=numm;i++) ans+=sum[tmp][i-fir*idx[tmp]]; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; // D.Equalizing by Division我们可以发现,对于某一个数$i$,他能变成的数的个数为$log_2i+1$个,而且题目中$i$的权值也不大,所以我们可以开一个桶,按照从小到大的顺序处理每一个数字,每次处理的时候将它能变成的$log_2i$个数字在桶中的权值全部+1,同时花费就是从原来的i到目前的数字要除几次二,当发现有桶中的数字大于给定的$k$时,更新答案. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std; const int N = 2e5 + 10; int n,k,ans=2147483647;int num[N];struct Node&#123; int val; int now;&#125;buck[N]; int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; buck[num[i]].now++; if(buck[num[i]].now&gt;=k)&#123; cout&lt;&lt;"0"&lt;&lt;endl; return 0; &#125; &#125; sort(num+1,num+1+n); for(int i=1;i&lt;=n;i++)&#123; int idx=1,tmp=num[i]/2; while(tmp)&#123; buck[tmp].now++; buck[tmp].val+=idx; if(buck[tmp].now&gt;=k) ans=min(ans,buck[tmp].val); tmp/=2; idx++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; // 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Qualification解题报告]]></title>
    <url>%2F2019%2F09%2F11%2FQualification%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[qwq T1:题目中给你一个$D$和一个$M$(一年有$D$个月,一个月有$M$天)让你求出: $d_1&gt;=2$ $d_{10}&gt;=2$ $d_1 \times d_{10} = m$ 的个数.其中$d_1$表示个位,$d_{10}$表示十位. 因为数据范围比较小,所以可以直接暴力枚举解决qwq… 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int m,d,ans;int main(void)&#123; scanf("%d%d",&amp;m,&amp;d); for(int i=1;i&lt;=m;i++)&#123; for(int sw=22;sw&lt;=d;sw++)&#123; int g=sw%10; int s=sw/10; if(g&gt;=2&amp;&amp;s&gt;=2&amp;&amp;s*g==i) ans++; &#125; &#125; printf("%d\n",ans); return 0;&#125; T2:给你一个数列$A$,将这个$A$不断$copy k$次变成数列$B$.最后让你求出数列$B$的逆序对个数.$k&lt;=10^9$ 看到$k$那么大,肯定可以$n^2$暴力了啊qwq 我们考虑这k组中的每一组.如果我们考虑原数列$A$中的每一位$A_i$,如果出现了一个$A_j&lt;A_i$,那么在从第$2$组开始,到第$k$组,这些比$A_i$小的数都会对$A_i$有贡献,而且第$3$组到第$k$组也会对第$2$组有贡献,这样一直递推下去,会发现有$1+(k-1)*(k-1)/2$次贡献,而且最后不要忘了一组中对自己的贡献. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=2004;const int HA=1e9+7;int n,k,ans;int num[N],dd[N];inline int ksm(int x,int y)&#123; int tmp=1; while(y)&#123; if(y&amp;1) tmp=(tmp*x)%HA; x=(x*x)%HA; y&gt;&gt;=1; &#125; return tmp%HA;&#125;signed main()&#123; scanf("%lld%lld",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;num[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; if(num[j]&lt;num[i]) dd[i]++; &#125; for(int i=1;i&lt;=n;i++)&#123; ans=(ans+k*(k-1)%HA*ksm(2,HA-2)%HA*dd[i]%HA)%HA; int tdp = 0; for(int j=i+1;j&lt;=n;j++) if(num[j]&lt;num[i]) tdp++; ans = ( ans + tdp * k ) % HA; &#125; printf("%lld\n",ans); return 0; &#125; T4:T3我不会欸qwq(捂脸) 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Atcoder题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round #573 (Div. 2)解题报告]]></title>
    <url>%2F2019%2F09%2F11%2FRound-1%2F</url>
    <content type="text"><![CDATA[qwq A:没啥可说的,直接按照$Mod 4$分类然后讨论就好了. B:显然可以发现答案只能是0,1,2,3中的某一个,我们只需要将读入记录下来,然后对于每一种胜利的情况分组枚举一下,记录一个最小的ans就可以了. C:考虑每一次操作中,这一页的最右边能消除几个.我们可以设我们已经消除了$sum$个数字,那么当前的$m_i$在消除之后中的书中的位置就是$m_i-sum$,我们就可以推导出来当前$m_i$的这一页的最右边的一个数字就是$((m_i-sum)/k+1)*k$,我们只需要开一个关于i的指针就可以了,时间复杂度为$O(m)$. D:考虑必胜情况:在另外一个人开始取的时候有$2$个或者以上的重复组.或者在有1个重复组时,取出一个重复组(因为不取就会输)之后回和另外一个元素再组成一个重复组. 我们再考虑完这种情况之后,可以发现,我们在将原来的数组排序之后,如果两边都按照最优方式取石子,那么最后的(在决定胜负之前),石子的序列一定是$B_i=i-1$的这样的一个等差数列.所以我们需要对原数组排序,然后统计一个$\sum_{i=1}^n A_i-(i-1)$,判断一下这个$sum$的奇偶性就可以了. PS:一定要先判断有没有例外的必胜情况(我就是这么WA了4发qwq….) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=1e5+10;int n,idxx;int num[N],dis[N];map&lt;int,bool&gt;mp;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; sort(num+1,num+1+n); int sum=0,dpp=0; for(int i=1;i&lt;=n;i++)&#123; if(num[i]==num[i-1]&amp;&amp;i&gt;=2)&#123; dpp++; dis[++idxx]=num[i]; &#125; sum+=num[i]-i+1; mp[num[i]]=1; &#125; if(n==1)&#123; if(sum&amp;1) cout&lt;&lt;"sjfnb"&lt;&lt;endl; else cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(dpp==1&amp;&amp;num[1]==0&amp;&amp;num[2]==0)&#123; cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(dpp==1&amp;&amp;n==2)&#123; cout&lt;&lt;"sjfnb"&lt;&lt;endl; return 0; &#125; if(dpp==1)&#123; if(mp[dis[1]-1]) cout&lt;&lt;"cslnb"&lt;&lt;endl; else &#123; if(!(sum&amp;1)) cout&lt;&lt;"cslnb"&lt;&lt;endl; else cout&lt;&lt;"sjfnb"&lt;&lt;endl; &#125; return 0; &#125; if(dpp&gt;=2)&#123; cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(!(sum&amp;1)) cout&lt;&lt;"cslnb"&lt;&lt;endl; else cout&lt;&lt;"sjfnb"&lt;&lt;endl; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round]]></title>
    <url>%2F2019%2F09%2F11%2FRound%2F</url>
    <content type="text"><![CDATA[qwq A:这道题能想到二进制转十进制然后判断满足的个数，但是转十进制范围已经超过了$long long$，直接模拟会溢出因为满足条件数值的都是4的次幂，所以二进制首位1后跟的$2k$个$0$即为$4$的$k$次幂直接对$0$的个数分析即可 B:很明显的一道贪心题目,当求最小的$sum$时,显然当$1$最多时,$sum$最小.当求$sum$最大时同理.又因为当$a_i$是一个偶数时,$\frac{a_i}{2}$肯定存在,而且$a_i$的最小值为1,所以显然$a_i$的值就只能是$2^j$. C:(个人感觉比$D$难$QAQ…$)让你在给定的序列$P$中求一个子序列,使得在图中按照该子序列进行最短路径移动时可以完整经过原序列$P$.乍一看一点思路都没有.但是仔细思考可以发现一点点思路.我们可以从题目中给出的起点(也就是一号点)开始进行移动,然后在原序列$P$中如果需要经过$P_{i}$和$P_{i+1}$,那么我们显然可以得到$P_i$与$P_{i+1}$一定是直接相连的(因为题目中没有给出无解的情况).那么我们可以扩展一下,假设我们现在在$P_j$号点,我们要走到$P_k$号点.那么如果$dis[P_j][P_k]==j-k$,那么在有解的情况下,一定是有$P_j$经过了所有的$j&lt;i&lt;k$的点(可以自己画个图证明一下).在这种情况下,我们就可以选择扩展答案了. (感觉还是放一下代码比较好qwq) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int oo = 0x3f3f3f3f;const int N = 105;const int M = 1e6 + 10;int n,m,idx;char mp[N][N];int G[N][N],point[M],ans[M];int qu[M&lt;&lt;1];int head=1,tai=0;int main()&#123; memset ( G , 0x3f3f3f3f , sizeof ( G ) ); scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%s" , mp[i] + 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= n ; j++ ) if ( mp[i][j] == '1' ) G[i][j] = 1; G[i][i] = 1; &#125; for ( int k = 1 ; k &lt;= n ; k++ ) for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) G[i][j] = min ( G[i][j] , G[i][k] + G[k][j] ); scanf("%d",&amp;m); for ( int i = 1 ; i &lt;= m ; i++ ) scanf ( "%d" , &amp;point[i] );// for(int i=1;i&lt;=n;i++)&#123;// for(int j=1;j&lt;=n;j++)// printf("%d " ,G[i][j]);// puts("");// &#125; int st=1,now=2; while(now&lt;=m)&#123; int diss=now-st; if(diss==G[point[st]][point[now]])&#123; if(head&lt;=tai) head++; qu[++tai]=now; now++; &#125; else &#123; ans[++idx]=point[st]; if(head&lt;=tai) st=qu[head++]; &#125; &#125; ans[++idx]=point[st]; if(ans[idx]!=point[m]) ans[++idx]=point[m]; printf("%d\n",idx); for(int i=1;i&lt;=idx;i++) printf ("%d ",ans[i]); return 0;&#125; D:感觉比$C$简单啊$QAQ$….让你求一个字符串使得这个字符串和给定01字符串的每一个子区间的最长单调不降区间长度一样长.我们自己理解了以后可以发现,一个区间的最长单调不降区间长度只是和每一个$1$后的$0$有关系,而和$0$后的$1$无关.(因为对于两个子串$11$和$01$,它们的最长不降区间是一样的).那么我们就可以考虑把原字符串的一些$1$变成$0$.就可以了. 但是怎么改变呢?我们考虑到,对于某一段连续的$1$,那么这段连续区间中的第一个1很显然是不必要的(而且不是最后一个1),那么我们可以把这些个1变成0.(然后就做完辣qwq) 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int tmpp;char ss[N] , tt[N];int main()&#123; scanf ( "%s" , ss + 1 ); int len = strlen ( ss + 1 ); for ( int i = 1 ; i &lt;= len ; i++ ) tt[i] = ss[i]; for ( int i = len ; i &gt;= 1 ; i-- ) &#123; if ( ss[i] == '1' &amp;&amp; tmpp &gt;= 0 ) tt[i] = '0'; int cur=ss[i] == '1' ? 1 : -1; tmpp = min ( tmpp + cur , cur ); &#125; for ( int i = 1 ; i &lt;= len ; i++ ) printf ( "%c" , tt[i] ); return 0;&#125;// E:现在还不会qwq 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190819模拟赛题解]]></title>
    <url>%2F2019%2F09%2F11%2F20190819%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[qwq 又是爆零的一次比赛欸qwq… T1: 让你在一个矩阵中,找出一条路径,使得经过的路径方差最小. 我就直接放题解了qwq… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;template &lt;class T&gt;bool Reduce(T &amp;a,T const &amp;b)&#123; return a&gt;b?a=b,1:0;&#125;const int N=31,inf=1e9+7,S=59*30;int n,m,ans;int a[N][N];int f[N][N];int cnt=0;void init()&#123; std::ios::sync_with_stdio(false); freopen("path.in","r",stdin); freopen("path.out","w",stdout); std::cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) std::cin&gt;&gt;a[i][j];&#125;int calc(const int &amp;sum,const int &amp;i,const int &amp;j)&#123; return (n+m-1)*a[i][j]*a[i][j]-2*sum*a[i][j];&#125;int dp(int sum)&#123; for(int i=0;i&lt;N;++i) for(int j=0;j&lt;N;++j) f[i][j]=inf; f[1][1]=calc(sum,1,1); for(int j=2;j&lt;=m;++j) Reduce(f[1][j],f[1][j-1]+calc(sum,1,j)); for(int i=2;i&lt;=n;++i) Reduce(f[i][1],f[i-1][1]+calc(sum,i,1)); for(int i=2;i&lt;=n;++i) for(int j=2;j&lt;=m;++j)&#123; Reduce(f[i][j],f[i-1][j]+calc(sum,i,j)); Reduce(f[i][j],f[i][j-1]+calc(sum,i,j)); &#125; return sum*sum+f[n][m];&#125;int main()&#123; init(); ans=inf; for(int sum=1;sum&lt;=S;++sum) Reduce(ans,dp(sum)); std::cout&lt;&lt;ans; return 0;&#125; T2:让你每次从一个区间向另一个区间连边,最后求起点到所有点的最短路. 很显然是线段树优化建图,开两颗线段树A,B,第一颗线段树从儿子节点向父亲连边,另外一条线段树从父亲向儿子连边.但是一个点一个点的向区间连边太麻烦了,所以我们需要建一个虚点,每次从区间[l1,r1]向一个虚点连边,然后再用这个虚点向区间[l2,r2]连边,这样就可以了. (但是我被卡常了) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; const int N = 500010;const int M = 2210000;int n , m , p , tot , cnt , root_f , root_s;struct edge&#123; int to; int next; int date;&#125;e[11000000];struct Node&#123; int lc; int rc;&#125;tree[N&lt;&lt;2];int head[M] , dis[M] , pos[N];bool vis[M];std :: priority_queue &lt; std :: pair &lt; int , int &gt; , std :: vector &lt; std :: pair &lt; int , int &gt; &gt; , std :: greater &lt; std :: pair &lt; int , int &gt; &gt; &gt; q; inline void add(int x,int y,int date)&#123; e[++cnt].to=y; e[cnt].next=head[x]; head[x]=cnt; e[cnt].date=date; return;&#125;void FBuild(int &amp;root,int l,int r)&#123; root=++tot; if ( l == r ) &#123; pos[l]=root; return; &#125; int mid=l+r&gt;&gt;1; FBuild(tree[root].lc,l,mid); FBuild(tree[root].rc,mid+1,r); add(tree[root].lc,root,0); add(tree[root].rc,root,0); return;&#125;void SBuild(int &amp;root,int l,int r)&#123; root=++tot; if(l==r)&#123; add(root,pos[l],0); return; &#125; int mid=l+r&gt;&gt;1; SBuild(tree[root].lc,l,mid); SBuild(tree[root].rc,mid+1,r); add(root,tree[root].lc,0); add(root,tree[root].rc,0); return;&#125;void FAdd(int root,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; add(root,tot,1); return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) FAdd(tree[root].lc,l,mid,x,y); if(y&gt;mid) FAdd(tree[root].rc,mid+1,r,x,y);&#125;void SAdd(int root,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; add(tot,root,1); return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) SAdd(tree[root].lc,l,mid,x,y); if(y&gt;mid) SAdd(tree[root].rc,mid+1,r,x,y); return;&#125;inline void Dijkstra()&#123; memset(dis,0x3f3f3f3f,sizeof(dis)); q.push(std :: make_pair(0,pos[p])); dis[pos[p]]=0; while(!q.empty())&#123; int x=q.top().second; q.pop(); if(vis[x]) continue; vis[x]=1; for(int i=head[x];i;i=e[i].next)&#123; int y=e[i].to; if(dis[x]+e[i].date&lt;dis[y])&#123; dis[y]=dis[x]+e[i].date; q.push(std ::make_pair(dis[y],y)); &#125; &#125; &#125; return;&#125;int main ( void ) &#123; freopen("road.in","r",stdin); freopen("road.out","w",stdout); n = read(); m = read(); p = read(); FBuild ( root_f , 1 , n ); SBuild ( root_s , 1 , n ); while ( m-- ) &#123; int x1 = read() , y1 = read() , x2 = read() , y2 = read(); tot++; FAdd(root_f,1,n,x1,y1); SAdd(root_s,1,n,x2,y2); tot++; FAdd(root_f,1,n,x2,y2); SAdd(root_s,1,n,x1,y1); &#125; Dijkstra(); for(int i=1;i&lt;=n;++i) printf("%d\n",dis[pos[i]]/2); return 0;&#125; T3:给你一个矩阵,让你求出这个矩阵中的一个最大的子矩阵,使得这个子矩阵的每一行和每一列都是等差数列 暂时咕咕咕一会,不会 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邪教算法学习小结]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%82%AA%E6%95%99%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[qwq 事实证明,邪教算法是很有用的qwq(以下材料大多抄袭OI-wiki)qwq Part1:随机函数:但是并找不到什么随机化好题qwq,,,,,先Pass了再说qwq… Part2:爬山算法:个人理解就是一个比较跳的贪心(真的是个贪心)….一般常用于单峰函数的求解,但是单峰函数为啥不写三分呢? 爬山算法的一般流程其实就是:选定一个初始答案,通过某种方法计算出另外一个答案,if 另一个答案更优 then 转移否则不变, 很形象的就是了爬山这种东西. 例题 JSOI2008球形空间产生器 空间模型的爬山就是很正常的模板了,直接给代码了qwq 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10005;int n;double tot , f[1005][1005];double ans[N] , cans[N] , dis[N];inline void check () &#123; tot = 0; for ( int i = 1 ; i &lt;= n + 1 ; i++ ) &#123; cans[i] = 0; dis[i] = 0; for ( int j = 1 ; j &lt;= n ; j++ ) dis[i] += ( f[i][j] - ans[j] ) * ( f[i][j] - ans[j] ); dis[i] = sqrt ( dis[i] ); tot += dis[i]; &#125; tot /= ( n + 1 ); for ( int i = 1 ; i &lt;= n + 1 ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) cans[j] += ( dis[i] - tot ) * ( f[i][j] - ans[j] ) / tot; return;&#125;int main() &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n + 1 ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) &#123; scanf ( "%lf" , &amp;f[i][j] ); ans[j] += f[i][j]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) ans[i] /= ( n + 1 ); for ( double T = 10001 ; T &gt;= 0.0000001 ; T *= 0.99995 ) &#123; check (); for ( int j = 1 ; j &lt;= n ; j++ ) ans[j] += cans[j] * T; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%.3lf " , ans[i] ); return 0;&#125; Part3. 模拟退火理解了爬山算法了之后,可以发现爬山算法存在的很显然的一个局限性:只能贪心,而这种在处理一些多峰函数时往往会只找到函数的某个极大值而不是最大值.所以我们就要引入模拟退火这种方法.,那么$What is $模拟退火呢? (以下内容来自WIKI) : 1234567模拟退火来自冶金学的专有名词退火。退火是将材料加热后再经特定速率冷却，目的是增大晶粒的体积，并且减少晶格中的缺陷。材料中的原子原来会停留在使内能有局部最小值的位置，加热使能量变大，原子会离开原来位置，而随机在其他位置中移动。退火冷却时速度较慢，使得原子有较多可能可以找到内能比原先更低的位置。模拟退火的原理也和金属退火的原理近似：我们将热力学的理论套用到统计学上，将搜寻空间内每一点想像成空气内的分子；分子的能量，就是它本身的动能；而搜寻空间内的每一点，也像空气分子一样带有“能量”，以表示该点对命题的合适程度。算法先以搜寻空间内一个任意点作起始：每一步先选择一个“邻居”，然后再计算从现有位置到达“邻居”的概率。可以证明，模拟退火算法所得解依概率收敛到全局最优解。 听起来很懵逼是不是qwq..没关系,其实就是如果你通过现在的这个状态,以某种方式得到了另外一个答案时,你不再像爬山算法那样直接转移,而已要像下图: 发生转移之后,随着温度T的不断降低,可以发现$\frac{-\Delta E}{T}$是不断减小的(因为在新状态更劣的情况下,$-\Delta E$一定为负数),那么$e^\frac{-\Delta E}{T}$一定也是不断减小的并且趋向于0.即模拟退火算法在温度较低时退化为爬山算法.这时只能寻找当前的函数极大值,所以怎么调参使得温度$T$较大时转移到正确的峰函数区间是解决问题的关键(但是还是只能靠运气qwq) 一般模拟退火的代码大概框架如下: 123456789101112inline void SA () &#123; for ( double T = StartTemplature ; T &gt;= EndTemplature ; T *= Coolingcoefficient ) &#123; Typename Newans = Getans();//此处Getans为某个获得新答案的函数. Typename delta = ans - Newans; if ( Newans &gt; ans ) //这里假设当值大时答案更优 ans = Newans; else if ( exp ( -delta / T ) &lt; ( double ) rand () / RAND_MAX ) ans = Newans; &#125; return;&#125; 其实为了保证答案的正确性,一般都会跑多次模拟退火从而增加求得最优解的概率.(调参也是个非常痛苦的过程,因为模拟退火比爬山算法更为看脸随机,所以每个参数的小差别可能导致答案的天壤之别.) 例题 [TJOI2010]分金币 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt; #include &lt;ctime&gt;#define int long longconst int N = 1005;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int n , ans = 2147483647;int num[N];inline int get () &#123; int sum1 = 0 , sum2 = 0; for ( int i = 1 ; i &lt;= ( n + 1 ) / 2 ; i++ ) sum1 += num[i]; for ( int i = ( n + 1 ) / 2 + 1 ; i &lt;= n ; i++ ) sum2 += num[i]; return abs ( sum1 - sum2 );&#125;inline void SA () &#123; double T = 5000; while ( T &gt;= 1e-10 ) &#123; int l = rand () % n + 1 , r = rand () % n + 1; std :: swap ( num[l] , num[r] ); int sum = get (); if ( sum &lt; ans ) ans = sum; else if ( exp ( ( ans - sum ) / T ) &lt; (double(rand())/RAND_MAX) ) std :: swap ( num[l] , num[r] ); T *= 0.98; &#125; return;&#125;signed main ( void ) &#123; srand ( rand() ); int T = read (); while ( T-- ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) num[i] = read (); for ( int i = 1 ; i &lt;= 100 ; i++ ) SA (); printf ( "%lld\n" , ans ); ans = 2147483647; &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Noip2018游记]]></title>
    <url>%2F2018%2F11%2F17%2FNoip2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[真没想到我能活着苟到写游记的一天$qwq$ Day-1最近几天有点累，早上就不去学校了（然而事实证明这是很正确的抉择）。早上一觉睡到了$8:20$，早上起来想起来$wucstdio$大佬说过立过的$flag$不拔在$Noip$会掉$rp$然后早睡起来就开始肝猪国杀，一直到$10:40$左右重构完了（历时$3$天终于写完了）下午回到学校，发现早上是信心鼓励赛幸好没去23333然后下午+晚上一直在写模板题。（顺便凑出来了$AC520$） Day 0早上教练居然给我们请假不用早来了哎$qwq….$上午开始走，一开始的时候还想在车上背个板子什么的然后SCP真好看又颓了会知乎然后就发现到了$cyyz$了 住宿安排完成了之后居然才$2:30$多一点，然后在宿舍里不知道该干啥。不过感觉$cyyz$的移动信号貌似比$SDSC$的时候快了一点（大雾）然后$wucstdio$给我打电话说楼下有很多大佬，自己迅速下楼去膜神仙。 终于见到了$rqy$姐姐本人了好兴奋$qwq$，不过$rqy$姐姐好像比自己想的稍微内敛了一点。 但是这并改变不了rqy姐姐是人赢的性质据说看见神仙可以rp++,（但是rp貌似被rqy姐姐吸走了QAQ) 晚上全宿舍都在打板子，但是试机的时候$wyxdrqc$和$zyp$大佬还有很多人（包括我）试机的时候线段树都打错了（大雾）。给自己喜欢的人打了个电话，加油qaq… Day 1早上起来，自己冷静了一下，打开题目一看$T1$，哎我为什么$T1$只会$70$分啊….，然后自己又推了1h还是没有推出来，心态当场爆炸qwq…T2当成数论推了半天，然后自己冷静的写了一个乱搞做法，也不知道能得多少分。T3完全不会，打一个直径分滚粗了。 出考场：啊你们怎么都做过原题吗？啊T2是个裸背包吗？啊T3你们都会写70分吗？心态崩了我要妹子QWQ….. 下午心态一直RE中，在宿舍里颓了一下午。不管怎么说第二天都想翻盘。 Day 2第二天睡了一觉，发现心情稍微好了一点。到了考场之后，看到第一题$m=n$我就感觉药丸…. 为什么$Noip$的$T1$要考基环树啊….. 写了个$60$分的树上贪心，然后开始想环上怎么做。然而我很$zz$的没有看数据范围可以$n^2$过，一直在写$O(n)$的做法。然后我就写挂了，自己补了只有环的做法，$72分滚了$。 T2看的时候：啊？读题读了$10mins$确定我不会，然后就决定打表了。 T3：……为什么$Noip$要考$ddp$啊。。。。 出了考场发现大家都说D2不会做当时甚至有些开心。 然后晚上就回去上晚自习了。 一年半的OI一场空，$D1TI$见祖宗说我是再适合不过的了。本来还以为自己能去$PKUWC$,好吧，我还是太$naive$了，感觉自己要与省一擦肩而过….剩下一年自己就养生好了，再来一年起码要拿一个$1=$啊$qwq…..$ 回家之后心态一直RE,,,,不过幸好$wucstdio$大佬能和我谈了谈人生….瞬间感觉$wucstdio$成了我的人生导师qaq…. 以后的路自己就要自己决定了，不过自己决定那些比赛也是要一起参加的qaq… 那些能进入省选的$OIer$们要加油鸭$qaq…$我会一直陪着你们的$@wyxdrqc @wucstdio @lingyuqing$ 你们的$wqyzstql$也要和你们一起努力了。 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考前模板整理]]></title>
    <url>%2F2018%2F11%2F07%2F%E8%80%83%E5%89%8D%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[$Noip$之前在这里整理一波模板….集成了一下所有的$TG$和$PJ$应该会考的模板 PS:所有模板纯属现场手搓，不保证正确性（比如手抖打错字母什么的），如果找到错误请及时告知我qwq 快速排序最基本的板子了吧,$C++$选手表示开心$qaq$。1234567891011121314151617#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5 + 10int n;int num[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;num[i] ); sort ( num + 1 , num + 1 + n ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , num[i] , i == n ? '\n' : ' ' ); return 0;&#125; 并查集12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5 + 10;int n , m;int find ( int x ) &#123; if ( x != father[x] ) father[x] = find ( father[x] ); return father[x];&#125;int main ( void ) &#123; scanf ( "%d%d" , &amp;n , &amp;m ); for ( int i = 1 ; i &lt;= n ; i++ ) father[i] = i; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x , y , z; scanf ( "%d%d%d" , &amp;z , &amp;x , &amp;y ); if ( z == 1 ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; &#125; else if ( z == 2 ) &#123; x = find ( x ) , y = find ( y ); if ( x == y ) puts ( "Y" ); else puts ( "N" ); &#125; &#125; return 0;&#125; 快速幂个人感觉这个还是个挺重要的板子了吧…..12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int Fast_Power ( int x , int y ) &#123; int sum = 1; while ( y ) &#123; if ( y &amp; 1 ) sum = sum * x; x = x * x; y &gt;&gt;= 1; &#125; return sum;&#125;int main ( void ) &#123; int n , m; scanf ( "%d%d" , &amp;n , &amp;m ); printf ( "%d\n" , Fast_Power ( n , m ) ); return 0;&#125; 线性筛素数这个其实只是筛素数的话是挺简单的，但是我决定连$\phi$一起筛出来（如果用不到的话就把$phi$数组自动忽略掉就好了）12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 5e5 + 10;int n , cnt;int prime[N] , phi[N];bool flag[N];int main ( void ) &#123; flag[1] = 1; phi[1] = 1; scanf ( "%d" , &amp;n ); for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; flag[i] = 1; prime[++cnt] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; for ( int i = 1 ; i &lt;= cnt ; i++ ) printf ( "%d " , prime[i] ); puts ( "" ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d " , phi[i] ); return 0;&#125; 【模板】堆又是一个$C++$党的福利$qwq$,直接用$priority$_$queue$模拟就好啦123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using std :: priority_queue;int n;priority_queue &lt; int , std :: vector &lt; int &gt; , std :: greater &lt; int &gt; &gt; qu;int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int opts; scanf ( "%d" , &amp;opts ); if ( opts == 1 ) &#123; int x; scanf ( "%d" , &amp;x ); qu.push ( x ); &#125; else if ( opts == 2 ) printf ( "%d\n" , qu.top () ); else if ( opts == 3 ) qu.pop (); &#125; return 0;&#125; 字符串蛤希其实我个人比较倾向于写自然溢出或者直接随机一个质数$qwq$12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;typedef unsigned long long ull;const ull base = 233;const int N = 1e4;const int M = 1e3;int n;char s[N][M];ull has[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%s" , s[i] + 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int len = strlen ( s[i] + 1 ); for ( int j = 1 ; j &lt;= len ; j++ ) has[i] = has[i] * base + s[i][j]; &#125; std :: sort ( has + 1 , has + 1 + n ); int ans = 0; for ( int i = 1 ; i &lt;= n ; i++ ) if ( has[i] != has[i + 1] ) ans++; printf ( "%d\n" , ans ); return 0;&#125; 最小生成树不会写$prim$的蒟蒻瑟瑟发抖….123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e4 + 10;const int M = 2e5 + 10;int n , m;struct Edge &#123; int from; int to; int data;&#125;e[M];int father[N];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline bool cmp ( Edge x , Edge y ) &#123; return x.data &lt; y.data;&#125;int find ( int x ) &#123; if ( x != father[x] ) father[x] = find ( father[x] ); return father[x];&#125;void Union ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; return;&#125;inline bool Judge ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); return ( x == y ) ? true : false;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) father[i] = i; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); e[i].from = x; e[i].to = y; e[i].data = z; &#125; std :: sort ( e + 1 , e + 1 + m , cmp ); int NowEdge = 0 , NowVal = 0; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int l = e[i].from , r = e[i].to; if ( Judge ( l ,r ) ) continue; Union ( l , r ); NowEdge++; NowVal += e[i].data; if ( NowEdge == n - 1 ) break; &#125; if ( NowEdge == n - 1 ) printf ( "%d\n" , NowVal ); else puts ( "orz" ); return 0;&#125; 单源最短路 （有负权边）这张图有负权边，所以只能写某已经死掉的$SPFA$了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N = 1e4 + 10;const int M = 1e5 + 10;using std :: queue;int n , m , t;struct Edge &#123; int to; int data; int next;&#125;e[M];int head[N] , dis[N];bool inque[N];inline int read () &#123; int s = 0; bool flag = 0; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '0' ) flag = 1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return ( flag ) ? -s : s;&#125;void Spfa ( int x ) &#123; memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[x] = 1;dis[x] = 0; qu.push ( x ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].data ) &#123; dis[k] = dis[j] + e[i].data; if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; return;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); add ( x , y , z ); &#125; Spfa ( 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , dis[i] == 0x3f3f3f3f ? 2147483647 : dis[i] , i == n ? '\n' : ' ' ); return 0;&#125; 单源最短路 （无负权边）在题目明确说没有负权边的情况下，跑堆优化的$Dijkstra$一定是最稳的其实代码长得都差不多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define F(i,a,b) for ( int i = a ; i &lt;= b ; i++ )#define MP std::make_pair#define se second#define fi firsttypedef std::pair &lt; int , int &gt; pll;const int N = 1e5 + 10; const int M = 4e5 + 20;std::priority_queue &lt; pll , std::vector &lt; pll &gt; , std::greater &lt; pll &gt; &gt; qu;int n , m , s , t;struct Edge &#123; int to; int data; int next;&#125;e[M];int head[N] , dis[N];bool inque[N];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void Heap_Dijkstra ( int x ) &#123; memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); dis[x] = 0; qu.push ( MP ( dis[x] , x ) ); while ( !qu.empty () ) &#123; int j = qu.top ().se; qu.pop (); if ( inque[j] ) continue; inque[j] = 1; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].data ) &#123; dis[k] = dis[j] + e[i].data; qu.push ( MP ( dis[k] , k ) ); &#125; &#125; &#125; return;&#125;int main ( void ) &#123; n = read (); m = read (); s = read (); F ( i , 1 , m ) &#123; int x = read () , y = read () , z = read (); add ( x , y , z ); &#125; Heap_Dijkstra ( s ); F ( i , 1 , n ) printf ( "%d " , dis[i] ); return 0;&#125; 割点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 20005;const int M = 200005;int n , m , t , idx;int head[N] , dfn[N] , low[N];bool flag[N];struct Edge &#123; int to; int next;&#125; e[M];inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;void Tarjan ( int cur , int father ) &#123; int child = 0; dfn[cur] = low[cur] = ++idx; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( !dfn[j] ) &#123; Tarjan ( j , father ); low[cur] = std :: min ( low[cur] , low[j] ); if ( low[j] &gt;= dfn[cur] &amp;&amp; cur != father ) flag[cur] = 1; if ( cur == father ) child++; &#125; low[cur] = std :: min ( low[cur] , dfn[j] ); &#125; if ( father == cur &amp;&amp; child &gt;= 2 ) flag[cur] = 1; return;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read (); add ( x , y ); add ( y , x ); &#125; for ( int i = 1 ; i &lt;= n ; i++ ) if ( !dfn[i] ) Tarjan ( i , i ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( flag[i] ) printf ( "%d\n" , i ); return 0;&#125; 线性求逆元1234567const int HA = 998244353;int main ( void ) &#123; inv[1] = 1; for ( int i = 2 ; i &lt;= n ; i++ ) inv[i] = ( HA - HA / i ) * inv[HA % i] % HA; return 0;&#125; 树状数组区间修改区间求和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define ll long long#define MP make_pair#define F(i,a,b) for(int i=a;i&lt;=b;i++)#define D(i,a,b) for(int i=a;i&gt;=b;i--)#define PB push_backinline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;const int N = 100005;int n , m;ll num[N];inline int lowbit ( int x ) &#123; return x &amp; -x;&#125; struct Tree &#123; ll tree[N]; inline void add ( ll x , int pos ) &#123; while ( pos &lt;= n ) &#123; tree[pos] += x; pos += lowbit ( pos ); &#125; return; &#125; inline ll query ( int pos ) &#123; ll res = 0; while ( pos ) &#123; res += tree[pos]; pos -= lowbit ( pos ); &#125; return res; &#125; &#125;t[2];int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; num[i] = read (); t[0].add ( num[i] - num[i - 1] , i ); t[1].add ( ( num[i] - num[i - 1] ) * i , i ); &#125; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int opts = read () , l = read () , r = read (); if ( opts == 1 ) &#123; ll val = read (); t[0].add ( val , l ); t[0].add ( -val , r + 1 ); t[1].add ( val * l , l ); t[1].add ( -val * ( r + 1 ) , r + 1 ); &#125; else if ( opts == 2 ) &#123; ll ValR = ( r + 1 ) * t[0].query ( r ) - t[1].query ( r ); ll ValL = ( l ) * t[0].query ( l - 1 ) - t[1].query ( l - 1 ); printf ( "%lld\n" , ValR - ValL ); &#125; &#125; return 0;&#125; 矩阵快速幂(求fib数列)123456789101112131415161718192021222324252627282930313233343536373839struct Matx &#123; ll rec[3][3];&#125; ms , lab , ans , st;Matx operator * ( Matx x , Matx y ) &#123; Matx tmp; for ( ll i = 0 ; i &lt; 3 ; i++ ) for ( ll j = 0 ; j &lt; 3 ; j++ ) tmp.rec[i][j] = 0; for ( ll i = 1 ; i &lt;= 2 ; i++ ) for ( ll j = 1 ; j &lt;= 2 ; j++ ) for ( ll k = 1 ; k &lt;= 2 ; k++ ) tmp.rec[i][j] = ( tmp.rec[i][j] + ( 1ll * x.rec[i][k] * y.rec[k][j] ) % HA ) % HA; return tmp;&#125;int main ( void ) &#123; m = read (); while ( m-- ) &#123; std :: cin &gt;&gt; s; ll nn = read (); for ( ll i = 0 ; i &lt; 3 ; i++ ) for ( ll j = 0 ; j &lt; 3 ; j++ ) ans.rec[i][j] = 0; ms.rec[1][1] = 0 , ms.rec[1][2] = 1 , ms.rec[2][1] = 1 , ms.rec[2][2] = 1; lab.rec[1][1] = 1 , lab.rec[1][2] = 0 , lab.rec[2][1] = 0 , lab.rec[2][2] = 1; st.rec[1][1] = 1 , st.rec[1][2] = 1; ll yy = nn; while ( yy ) &#123; if ( yy &amp; 1ll ) lab = lab * ms; ms = ms * ms; yy &gt;&gt;= 1ll; &#125; for ( ll i = 1 ; i &lt;= 1 ; i++ ) for ( ll j = 1 ; j &lt;= 2 ; j++ ) for ( ll k = 1 ; k &lt;= 2 ; k++ ) ans.rec[i][j] = ( ans.rec[i][j] + ( 1ll * st.rec[i][k] * lab.rec[k][j] ) % HA ) % HA; writeln ( ans.rec[1][1] ); puts ( "" ); &#125; return 0; &#125; 扩展欧几里得(同余方程)12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define int long longusing namespace std;int a , b , x , y;void exgcd ( int a , int b ) &#123; if ( !b ) &#123; x = 1; y = 0; return; &#125; exgcd ( b , a % b ); int tx = x; x = y; y = tx - a / b * y; return; &#125;signed main ( void ) &#123; cin &gt;&gt; a &gt;&gt; b; exgcd ( a , b ); x = ( x % b + b ) % b; cout &lt;&lt; x &lt;&lt; endl; return 0;&#125; 树的直径12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10005;int n , t;int head[N] , f[N][3];struct Edge &#123; int to; int date; int next;&#125;e[N &lt;&lt; 2];inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].date = z; e[t].next = head[x]; head[x] = t; return;&#125; void dfs1 ( int x , int fa ) &#123; for ( int i = head[x] ; i ; i = e[i].next ) &#123; int y = e[i].to; if ( y == fa ) continue; dfs1 ( y , x ); int temp = f[y][0] + e[i].date; if ( temp &gt;= f[x][0] ) &#123; f[x][1] = f[x][0]; f[x][0] = temp; &#125; else if ( temp &gt; f[x][1] ) f[x][1] = temp; &#125; return;&#125;void dfs2 ( int x , int fa ) &#123; for ( int i = head[x] ; i ; i = e[i].next ) &#123; int y = e[i].to; if ( f[x][0] == f[y][0] + e[i].date ) f[y][2] = max ( f[x][2] , f[x][1] ) + e[i].date; else f[y][2] = max ( f[x][2] , f[x][0] ) + e[i].date; dfs2 ( y , x ); &#125; return;&#125;int main ( void ) &#123; while ( scanf ( "%d" , &amp;n ) != EOF ) &#123; t = 0; memset ( f , 0 , sizeof ( f ) ); memset ( head , 0 , sizeof ( head ) ); for ( int i = 2 ; i &lt;= n ; i++ ) &#123; int x , y; scanf ( "%d%d" , &amp;x , &amp;y ); add ( x , i , y ); &#125; dfs1 ( 1 , 0 ); dfs2 ( 1 , 0 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d\n" , max ( f[i][0] , f[i][2] ) ); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2010] 所驼门王的宝藏]]></title>
    <url>%2F2018%2F11%2F05%2Fi-t%2F</url>
    <content type="text"><![CDATA[一道思维难度很简单，代码实现难度非常$mmp$的毒瘤题…..(这很$SDOI…..$) 题目连接：SDOI2010 所驼门王的宝藏 好，我们直接跳过题目背景。 然后我们会发现，如果这道题能把图建出来，那么直接一遍$DAG$上$DP$就过了。 蒽，这不是$sb$题吗？ 然后让我们看数据范围：$1&lt;=n&lt;=1000000$ 笑容逐渐消失 但是我们考虑一下，既然我们要建一张$DAG$。那么，我们完全没有必要对所有的点进行两两连边。我们只需要对每一行和每一列进行连边，把他们连成一个环，这样的话，建边复杂度就会从$O(n^2)$变成$O(n)$了。 然后对于自由门的情况，对不起，我不知道怎么优化，所以我决定暴力建边。 （分析可以发现即使全是自由门，你暴力建边也不会$TLE$） 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;map&gt;const int N = 1e6 + 10;const int M = 5e6 + 10;using std :: map;using std :: stack;int ans = -0x3f3f3f3f;int n , r , c , t;int dx[] = &#123; 0 , 0 , 1 , 1 , 1 , -1 , -1 , -1 &#125;;int dy[] = &#123; 1 , -1 , 1 , 0 , -1 , 1 , 0 , -1 &#125;;struct Node &#123; int x; int y; int opts; int id;&#125;p[N];struct Edge &#123; int from; int to; int next; &#125;e[M];int idx , Bcnt;int head[N] , dfn[N] , low[N];int Belong[N] , size[N] , f[N];int degree[N];bool instack[N];map &lt; std :: pair &lt; int , int &gt; , int &gt; mp;map &lt; std :: pair &lt; int , int &gt; , int &gt; mat;stack &lt; int &gt; st;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].from = x; e[t].next = head[x]; head[x] = t; return;&#125;bool cmp1 ( Node a , Node b ) &#123; if ( a.x != b.x ) return a.x &lt; b.x; if ( a.opts == 1 ) return 1; if ( b .opts == 1 ) return 0; return a.y &lt; b.y;&#125;bool cmp2 ( Node a , Node b ) &#123; if ( a.y != b.y ) return a.y &lt; b.y; if ( a.opts == 2 ) return 1; if ( b.opts == 2 ) return 0; return a.x &lt; b.x;&#125;void Tarjan ( int cur ) &#123; dfn[cur] = low[cur] = ++idx; instack[cur] = 1; st.push ( cur ); for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( !dfn[j] ) &#123; Tarjan ( j ); low[cur] = min ( low[cur] , low[j] ); &#125; else if ( instack[j] ) low[cur] = min ( low[cur] , dfn[j] ); &#125; int k; if ( low[cur] == dfn[cur] ) &#123; Bcnt++; do &#123; k = st.top ();; st.pop (); instack[k] = 0; Belong[k] = Bcnt; size[Bcnt]++; &#125; while ( k != cur ); &#125; return;&#125;void dfs ( int cur , int father ) &#123; if ( f[cur] &gt; size[cur] ) return; f[cur] = size[cur]; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == father ) continue; dfs ( j , cur ); f[cur] = max ( f[cur] , f[j] + size[cur] ); &#125; return;&#125;int main ( void ) &#123; n = read () , r = read () , c = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; p[i].x = read (); p[i].y = read (); p[i].opts = read (); p[i].id = i; mp[std::make_pair ( p[i].x , p[i].y )] = i; &#125; std :: sort ( p + 1 , p + n + 1 , cmp1 ); int first = 1 , last = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( p[i].x != p[i + 1].x ) &#123; if ( first != last ) add ( p[last].id , p[first].id ); last = first = i + 1; &#125; else &#123; if ( p[last].opts == 1 ) add ( p[last].id , p[i + 1].id ); if ( p[i + 1].opts == 1 ) last = i + 1; if ( p[first].opts != 1 ) last = first = i + 1; &#125; &#125; first = last = 1; std :: sort ( p + 1 , p + 1 + n , cmp2 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( p[i].y != p[i + 1].y ) &#123; if ( first != last ) add ( p[last].id , p[first].id ); last = first = i + 1; &#125; else &#123; if ( p[last].opts == 2 ) add ( p[last].id , p[i + 1].id ); if ( p[i + 1].opts == 2 ) last = i + 1; if ( p[first].opts != 2 ) last = first = i + 1; &#125; &#125; //printf ( "%d\n" , t ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( p[i].opts == 3 ) for ( int j = 0 ; j &lt; 8 ; j++ ) &#123; int xx = p[i].x + dx[j]; int yy = p[i].y + dy[j]; if ( mp[std :: pair &lt; int , int &gt; ( xx , yy )] ) add ( p[i].id , mp[std :: pair &lt; int , int &gt; ( xx , yy )] ); &#125; // printf ( "%d\n" , t ); // for ( int i = 1 ; i &lt;= t ; i++ ) // printf ( "%d %d\n" , e[i].from , e[i].to ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( !Belong[i] ) Tarjan ( i ); for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = head[i] ; j ; j = e[j].next ) &#123; int k = e[j].to; if ( Belong[i] != Belong[k] ) mat[std :: make_pair ( Belong[i] , Belong[k] )] = 1; &#125; t = 0; memset ( head, 0 , sizeof ( head ) ); for ( auto it = mat.begin () ; it != mat.end() ; it++ ) &#123; add ( it -&gt; first.first , it -&gt; first.second ); degree[it -&gt; first.second]++; &#125; // for ( int i = 1 ; i &lt;= Bcnt ; i++ ) // printf ( "%d " , degree[i] ); for ( int i = 1 ; i &lt;= Bcnt ; i++ ) if ( degree[i] == 0 ) &#123; dfs ( i , 0 ); ans = max ( ans , f[i] ); &#125; printf ( "%d\n" , ans ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qbxt D2T2 Code 题解]]></title>
    <url>%2F2018%2F11%2F04%2F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[看了一眼之后完全就是一脸懵逼的题…. 首先先读题$qaq$…..题目的大致意思就是给你一个矩阵，然后问你把这个矩阵横竖填成异或值为$1$的矩阵的方案数。 很明显，这道题没有什么枚举上界，所以你想直接枚举的话是不太可能的。那么我们怎么办呢$?$ 我也不知道 既然枚举补星，那么我们就用一个比较常见的正难则反的思想。对于这道题，我们可以容斥的去做 那么，首先，所有的方案是什么呢？ All = 2^{n*m}为什么呢？一共有n+m个校验码，我们按位数考虑，在只有1位的情况下，那么这一位可能是$0$或者$1$。那么就是$(2^n)^m$的方案数了。 然后我们考虑对于每一位删掉不合法的情况：因为异或起来是$1$，那么对于没一行或者每一列，$1$的个数总是奇数。那么我们就可以根据这个东西来进行删除不合法状态的操作了 最后统计出来答案 我们发现，因为有$k$位，而我们是按位考虑的。所以我们最后要取答案的$k$次方。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define int long longconst int N = 505;const int MOD = 1e9 + 7;int c[N][N];int n , m , k , t , ans;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int Fast_Power ( int x , int y ) &#123; int sum = 1; while ( y ) &#123; if ( y &amp; 1 ) sum = sum * x % MOD; x = x * x % MOD; y &gt;&gt;= 1; &#125; return sum;&#125;signed main() &#123; for ( int i = 1 ; i &lt;= 500 ; i++ ) c[i][i] = c[i][0]=1; for ( int i = 2 ; i &lt;= 500 ; i++ ) for ( int j = 1 ; j &lt; i ; j++ ) c[i][j] = ( c[i - 1][j] + c[i - 1][j - 1] ) %MOD; t = read(); while ( t-- ) &#123; n = read () , m = read() , k = read (); int ans = Fast_Power ( 2 , n * m ); for ( int i = 0 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) &#123; if ( i == 0 &amp;&amp; j == 0 ) continue; if ( ( i + j ) &amp; 1 ) ans = ( ans + MOD - Fast_Power ( 2 , ( n - i ) * ( m - j ) ) * c[n][i] % MOD * c[m][j] % MOD ) % MOD; else ans = ( ans + Fast_Power ( 2 , ( n - i ) * ( m - j ) ) * c[n][i] % MOD * c[m][j] % MOD ) % MOD; &#125; ans = Fast_Power ( ans , k ); printf ( "%lld\n" , ans ); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解] Noip2016D1T3 换教室]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%8D%A2%E6%95%99%E5%AE%A4%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一道被天天爱跑步抢尽了风头的最没有排面的$T3…..$说实话，这道题我刚开始是不会的，然后我看了L_Y_T大爷的$Blog$之后才恍然大悟（$Blog$写的很好，赞一个）先安利完$Blog$再说L_Y_T大爷的Blog 看了$Blog$之后,突然发现，这东西要求的概率知识点我都是会的，只是DP式子想不出来而已$qaq…$(我好菜啊) 因为题目中说，我们最多可以换$m$次，而题目中说的你只能在开始之前选择方案的说法完全没用，毕竟谁会知道你是预测了未来呢（逃 然后，因为有$n$个课程，所以我们设$f[i][j][0/1]$来表示第i个点,第j次换,换不换 然后我们分情况来表示转移：每个教室分为两种情况 1.换2.不换这个是挺平常的然后复杂在换与不换的分情况上了~~~不换:不换是分为这样几种情况:上一个也不换 , 上一个换 且成功,上一个换但失败同理,换也有好多种情况:上一个点不换,这个点失败上一个点不换,这个点成功上一个点换成功,这个点成功上一个点换成功,这个点失败上一个点换失败,这个点成功上一个点换失败,这个点也失败 然后方程好复杂的，是：1234567891011121314151617181920212223242526 上一点不换:f[i-1][j-1][0]这一点换1.失败消耗体力: dis[c[i-1]][c[i]] 分析: 由于上一个点不换,所以上一个点一定是在c[]中的;假定这次失败,那么这次也只能去c[]中的教室;2.成功消耗体力: dis[c[i-1]][d[i]]分析: 由于上一个点不换,所以上一个点一定是在c[]中的;假定这次成功,那么这次能去d[]中的教室;那么,失败的概率是1-k[],成功的概率是k[].综上,这种情况就是:f[i-1][j-1][0]+dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1.0-k[i]) 同理,上一点换,这一点换1.上一点失败,这一点失败(以后省一点哈)消耗体力: dis[c[i-1]][c[i]]概率:都失败这运气也没谁了!!!! 概率:(1.0-k[i-1])*(1.0-k[i])2.失败,成功消耗体力: dis[c[i-1]][d[i]]概率 : (1.0-k[i-1])*k[i]3.成功,失败消耗体力 : dis[d[i-1]][c[i]]概率: k[i-1]*(1.0-k[i])4.成功,成功消耗体力: dis[d[i-1]][d[i]] 概率: k[i-1]*k[i] 然后对于不换的方程：12f[i][j][0] = min(f[i-1][j][0]+dis[c[i-1]][c[i]],f[i-1][j][1]+dis[c[i-1]][c[i]]*(1.0-k[i-1])+dis[d[i-1]][c[i]]*k[i-1]) ; 之前需要Floyd预处理一下，然后就好啦(这道题的确比天天爱跑步简单23333)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 2050;const int M = 350;int n , m , v , e;int c[N] , d[N] ;double G[M][M] , f[N][N][2];double k[N];template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;int main ( void ) &#123; scanf ( "%d%d%d%d" , &amp;n , &amp;m , &amp;v , &amp;e ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;c[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;d[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%lf" , &amp;k[i] ); for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) f[i][j][0] = f[i][j][1] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= v ; i++ ) G[i][i] = 0 ; for ( int i = 1 ; i &lt;= e ; i++ ) &#123; int x , y; double z; scanf ( "%d%d%lf" , &amp;x , &amp;y , &amp;z ); if ( G[x][y] &gt; z ) G[x][y] = G[y][x] = z; &#125; for ( int l = 1 ; l &lt;= v ; l++ ) for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = min ( G[i][j] , G[i][l] + G[l][j] ); f[1][0][0] = f[1][1][1] = 0.0000; for ( int i = 2 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= min ( i , m ) ; j++ ) &#123; f[i][j][0] = min ( f[i - 1][j][0] + G[c[i - 1]][c[i]] , f[i - 1][j][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1] ); if(j &gt;= 1) &#123; f[i][j][1] = min ( f[i - 1][j - 1][0] + G[c[i - 1]][d[i]] * k[i] + G[c[i - 1]][c[i]] * ( 1.0 - k[i] ) , f[i - 1][j - 1][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) * ( 1.0 - k[i] ) + G[c[i - 1]][d[i]] *k[i] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1]* ( 1.0 - k[i] ) + G[d[i - 1]][d[i]] * k[i - 1] * k[i] ); &#125; &#125; double ans = 0x7fffffff; for ( int i = 0 ; i &lt;= m ; i++ ) for ( int j = 0 ; j &lt;= 1 ; j++ ) ans = min ( ans , f[n][i][j] ); printf ( "%.2lf\n" , ans ) ; return 0 ;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率入门]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%A6%82%E7%8E%87%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[其实这道初赛题是我第一次做的概率题 我们来看一眼这道毒瘤题： 题面其实已经很清楚了，我们可以发现，当这个青蛙在第$1$块石头时，那么这只青蛙完全可以不用跳，我们设$f(k)$表示这只青蛙在$k$号荷叶上，期望需要$f(k)$次跳到$1$号荷叶，那么我们有： f(1)=0我们接着来考虑当这只青蛙在$2$号荷叶时的情况，它可以跳到$1$号和$2$号荷叶，当它跳到$1$号荷叶时，它完成了任务，跳了一步。当它跳到$2$号时，它还有$f(2)$步，因为每一次跳跃时，跳跃到每一个荷叶上的几率是相等的，所以我们有： f(2)=[1+(1+f(2))]/2同理，我们可以得到： f(3)=[1+(1+f(2))+(1+f(3))]/3推广到一般形式则有: f(k)=[\sum_{i=1}^k{f(i)+1}]/k我们化简一下，有： f(k)=1+\frac {1}{k}\sum_{i=1}^kf(i) 我们看到这个式子：$f(k)=1+\frac {1}{k}\sum_{i=1}^kf(i)$ 当$i==k$的时候,我们会发现式子里出现了一个$f(k)$….. 这咋求啊 我们展开这个式子，会发现原来的式子等价于： f(k)=1+\frac {1}{k}\sum_{i=1}^{k-1}f(i)+\frac 1kf(k)这时候如果把$f(k)$看作一个未知数的话，我们可以发现$f(k)$的这一项是可以合并的。但是我们先两边同乘一个$k$，把分母去掉，就会有： k*f(k)=k+\sum_{i=1}^{k-1}f(i)+f(k)这样答案就很显然了，合并掉等式两边相等的$f(k)$，会得到： (k-1)*f(k)=k+\sum_{i=1}^{k-1}f(i)最后，两边同除$(k-1)$，有最后答案上的公式： f(k)=\frac{k}{k-1}(1+\frac {\sum_{i=1}^{k-1}f(i)}{k-1})通过这个式子计算可以得到$f(5)=\frac{37}{12}$,也就是答案 做完了QAQ(写Markdown好累啊qwq…)因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2015]WIL-Wilcze题解]]></title>
    <url>%2F2018%2F11%2F02%2FPOI2015-WIL-Wilcze%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[其实这本来是$QBXT$的$T2$，但是由于毒瘤$zhw$跑得快（雾），导致我们发现这是某$poi$原题。 首先看题面:题目链接 详细读了一遍之后，其实对于这道题，我的第一反应是贪心（也许是因为我太菜了）。然后打了一遍，小样例过了，然后被大样例$hack$。 之后我又用命分析了一下。可以发现，因为题目中保证每个数的值全部$&gt;=0$，即每个数都是正整数。所以我们与其选长度不到$d$的区间删除，不如直接选择长度为$d$的区间删除。 那么在一段长度已知的序列中，长度为$d$的子序列个数是已知的，那么我们就可以预处理出每一段长度为$d$的子序列。然后我们又发现，题目中要求区间的长度不超过p，那么我们很明显的可以想到尺取法。 然后我们就可以用单调队列来维护我们预处理出的这些长度为$d$的子序列。然后对于区间长度取$max$就是答案了。 最后怒斥一波出原题的出题人$qaq$….(虽然$zhw$很帅) 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;deque&gt;typedef long long ll;using std::deque;const ll N=2000010;ll n,p,d;ll a[N];ll sum[N];ll hea[N];struct Node&#123; ll pos,val; Node(ll pos,ll val):pos(pos),val(val)&#123;&#125; Node()&#123;&#125;&#125;;inline void read(ll &amp;x)&#123; ll s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; x=s*w; return;&#125;deque&lt;Node&gt;q;int main()&#123; read(n);read(p);read(d); for(int i=1;i&lt;=n;i++)read(a[i]),sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n-d;i++) hea[i]=sum[i+d]-sum[i]; for(int i=n-d+1;i&lt;=n;i++) hea[i]=sum[n]-sum[i]; ll ans=0; int l=0; for(int i=d+1;i&lt;=n;i++) &#123; while(!q.empty()&amp;&amp;q.back().val&lt;hea[i-d])q.pop_back(); q.push_back(Node(i-d,hea[i-d])); while(l&lt;i-d&amp;&amp;sum[i]-sum[l]-q.front().val&gt;p) &#123; l++; while(l&gt;q.front().pos)q.pop_front(); &#125; ans=std::max(ans,(ll)i-l); &#125; printf("%lld",ans); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复赛冲刺Day1R1-Color题解]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%A4%8D%E8%B5%9B%E5%86%B2%E5%88%BADay1R1-Colory%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这道题是考试时的$T2$，我感觉这道题出的特别好（虽然当时并不会做 首先看题目:$emmmmm…..$什么鬼啊这个题是$QAQ$ 当时直接一脸懵逼，然后只会写2^n 枚举每一种填充方式，然后再检测的方法…然而这道题这么做只有10分啊$qaq….$ 然后赛后题解告诉我：这题TM是个欧拉回路！！！！当时我就懵逼了….然后当dalao们给我把这道题讲明白了之后，我才发现这道题思路的奇妙。 首先，我们发现，对于一个点，它对应着一个横坐标和一个纵坐标。蒽….一个点对应着两个数值，这个时候我们应该想到什么？二分图？对了，这东西还真的就是要你用二分图的思想来建图….(心态崩了我要妹子$QAQ$) 我们建图，然后我们发现，因为一个点对应着一个横坐标和一个纵坐标，那么我们想到：在二分图中，每一条边也是对应着两种点。那么受到这样的启发，我们就可以建图了：我们把横坐标和纵坐标分别看成一种点，然后将题目中给你的点看成这张图上的边，那么因为题目中要求：黑点和白点的绝对值差不大于1…..，那么我们能想到什么呢？我们要对这些边进行黑白染色，所以我们要一个点出发，一直走一条欧拉回路，这样能走遍所有的边。 但是这样做，我们会发现一个问题：只有$subtask4$的$30$分数据告诉你是偶数。而存在欧拉回路的图的特点是什么呢？每个点的度数都是偶数，那么当点的度数是奇数的时候，我们怎么办呢？ 我在这里选择了度数为奇数的点向一个虚拟节点连边，然后当所有点的度数都是偶数时，这时候没有其他点向这个点连边所以这时候这个虚拟节点对答案没有影响。 然后，我们就直接对边进行染色就可以了。 我只想说，这道题出的真的好，佩服出题人。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt; const int N = 5e5 + 10; struct Data &#123; int v; int p;&#125;data[N];struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int n , m , t = 1 , num;int head[N] , d[N];int x[N] , y[N] , ans[N];bool flag[N]; inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline bool cmp ( Data x , Data y ) &#123; return x.v&lt;y.v;&#125;void lisanhua () &#123; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = x[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; x[data[i].p] = num; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = y[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; y[data[i].p] = num; &#125; return;&#125;void dfs ( int cur , bool last ) &#123; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; if ( flag[i &gt;&gt; 1] ) continue; int j = e[i].to; flag[i &gt;&gt; 1] = 1; d[cur]--; d[j]--; ans[i &gt;&gt; 1] = !last; dfs ( j , !last ); &#125; return;&#125; int main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; x[i] = read (); y[i] = read (); &#125; lisanhua(); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; d[x[i]]++; d[y[i]]++; add ( x[i] , y[i] ); add ( y[i] , x[i] ); &#125; for ( int i = 1 ; i &lt;= num ; i++ ) if ( d[i] &amp; 1 ) &#123; d[i]++; d[num + 1]++; add ( i , num + 1 ); add ( num + 1 , i ); &#125; num++; memset ( ans , -1 , sizeof ( ans ) ); for ( int i = 1 ; i &lt;= num ; i++ ) while ( d[i] ) dfs ( i , 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , ans[i] , i == n ? '\n' : ' ' ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复赛冲刺Day1R1-Count题解]]></title>
    <url>%2F2018%2F11%2F01%2FqbxtD1T1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[其实我感觉这道数论题还是挺简单的（虽然我不会） 这道数论题，我初看的时候是挺一脸懵逼的，然后据$wucstdio$大爷提供的思路，我们可以发现：题意求的是$x$,$y$在$mod P$下的逆元，存在解的条件是$gcd(x,p)==1$，即x,p互质。所以由题解有设 1 到 P − 1 中与 P 互质的数有 s 个，考虑这 s 个数与它们的逆元组成的二元组，这些二元组一定符合条件，那么只要考虑去重的问题 所以我们只需要知道从$1$到$n$中和$n$互质的数的个数这个东西是什么呢？这个东西很明显是$phi$函数。所以我们只需要求出$\phi(p)$，再加上$x^2\equiv1\pmod{p}$的数，最后除$2$就好了。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e7 + 10;int n;int tot , prime[N] , phi[N];bool flag[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); flag[1] = 1; phi[1] = 1; for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; prime[++tot] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] *prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; long long ans = phi[n]; for ( long long i = 1 ; i &lt;= n ; i++ ) if ( i * i % n == 1 ) ans++; printf ( "%lld\n" , ( long long ) ( ans ) / 2 ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A*学习笔记]]></title>
    <url>%2F2018%2F10%2F19%2FA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[例题：$LuoguP2324$:骑士精神 $A*$嘛，很早时候就听说过，貌似是一种很神奇的算法。听长者讲过一遍，一直都想自己打一遍。但是一直没机会。所以来自己写一遍就好啦。 $A*$的重点就是一个叫做估价函数的东西，但是这个叫估价函数的东西你必须要好好写，不然你会搜出来$WA$的好成绩对于这道题，我就是将现在的棋盘和目标棋盘不同棋子数的差当作估价函数（其实是正确的)。然后，我们就可以加一个类似于剪枝的东西：如果现在的步数$+$估价函数估计的值$&gt;$现在的$max$，直接$return$就好。剩下的东西就是个大爆搜了， 以下是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int goal[7][7] = &#123; &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;, &#123; 0 , 1 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 2 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;&#125;;char mp[6][6];int now[6][6];bool flag;int dx[] = &#123; 0 , 1 , 1 , -1 , -1 , 2 , 2 , -2 , -2 &#125;;int dy[] = &#123; 0 , 2 , -2 , 2 , -2 , 1 , -1 , 1 , -1 &#125;;inline int calcu () &#123; int tmp = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) &#123; if ( now[i][j] != goal[i][j] ) tmp++; &#125; return tmp;&#125;inline void swap ( int &amp;x , int &amp;y ) &#123; int t = x; x = y; y = t; return;&#125;void A_Star ( int x , int y , int dep , int MaxStep ) &#123; if ( flag ) return; if ( dep == MaxStep ) &#123; if ( calcu () == 0 ) &#123; flag = 1; printf ( "%d\n" , MaxStep ); return; &#125; return; &#125; for ( int i = 1 ; i &lt;= 8 ; i++ ) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if ( xx &gt; 5 || xx &lt; 1 || yy &gt; 5 || yy &lt; 1 ) continue; swap ( now[x][y] , now[xx][yy] ); if ( calcu () + dep &lt;= MaxStep ) A_Star ( xx , yy , dep + 1 , MaxStep ); swap ( now[x][y] , now[xx][yy] ); &#125; return;&#125;int main ( void ) &#123; int ttt; scanf ( "%d" , &amp;ttt ); while ( ttt-- ) &#123; flag = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) scanf ( "%s" , mp[i] + 1 ); int st_x , st_y; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) if ( mp[i][j] == '*' ) &#123; st_x = i; st_y = j; now[i][j] = 2; &#125; else now[i][j] = mp[i][j] - '0'; if ( calcu () == 0 ) &#123; puts ( "0" ); return 0; &#125; for ( int i = 1 ; i &lt;= 15 ; i++ ) if ( !flag ) A_Star ( st_x , st_y , 0 , i ); if ( !flag ) puts ( "-1" ); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wucstdio的毒瘤模拟赛]]></title>
    <url>%2F2018%2F10%2F18%2Fwucstdio%E7%9A%84%E6%AF%92%E7%98%A4%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[$wucstdio$大爷的Flag还是没有倒…. T1: 反正我刚开始对这道题是完全没有什么信心的qaq（才不会告诉你我直接去看的$T2$）考虑$50$分的情况：一条链。所以就是一个等差数列了qwq考虑剩余的正解，我们可以把每一步的期望值当成这棵树的权值，然后因为从上向下和从下向上的期望值可能不太一样，所以我们需要两个函数来表示：（相当于两条边）。我们设$f(x) g(x)$分别表示从下向上和从上向下的情况，所以我们考虑求出$f(x)$时，我们要考虑以下情况：直接走到这个节点的父节点，所以这种情况下，对这个节点对答案的贡献就是$\frac {1}{d[x]}了$还有一种情况就是这个节点先跳到他的儿子，再跳回这个节点，再跳过去。这个时候，因为我们需要一步来跳过去，所以这种情况对答案的贡献就是:$\sum_{j=son} \frac {1}{d[x]}[1 + f(x) + f(j) ]$我们综合考虑一下这两种情况对答案的贡献值，将这两个式子加起来，我们就会得到下边的这个式子： f(x) = \frac{1}{d} + \sum_{j=son}\frac{1}{d}\times[1 +f(x) + f ( j )]我们安置我们做期望的一贯思路（好像我做过多少期望一样QwQ），因为$num[son]=p-1$，所以我们可以得到这样一个式子： d\times f(x)=1+d-1+(d-1)f(x)+\sum_{j}f(j)化简一下之后有： f(x)=d+\sum_{j}f(j)然后我们来考虑一下$g(x)$这个东西怎么求，当我们经过观察之后，我们可以发现这个式子有三种情况：他的父亲直接跳到他这里，这种情况对答案的贡献就是$\frac{1}{d[father]}$他的父亲先跳到他的爷爷，然后再跳回来，这种情况下，对答案的贡献就是：$\frac{1}{d[father]}\times (1 + g(p) +g(x) )$他的父亲跳到他的兄弟然后再跳到他自己。我们把这三种情况加起来，就会有： g(x)=\dfrac {1}{d[father]} \times(1+g(p)+g(x))+\dfrac {1}{d[father]}+\sum_{pa_j=pa_x\&\&j\not=x}\dfrac {1}{d[father]} (1+f(j)+g(x))继续化简有： g(x)=g(p)+f(p)-f(x)通过这种方式，我们就可以把$g(x) f(x)$算出来，相当于边长。 算出边长后，这个问题就转化成了：给你一颗树，求树的直径。我选择了DP求直径，就很简单了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;const int N = 2e5 + 10;int n , m , t;struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int head[N];int now_ans;int f[N] , g[N] , p[N];int LongDis[N][2] , SecondDis[N][2];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline int min ( int x , int y ) &#123; return x &lt; y ? x : y;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;void Find_f ( int root , int fa ) &#123; f[root] = p[root]; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Find_f ( j , root ); f[root] += f[j]; &#125; return;&#125;void Find_g ( int root , int fa ) &#123; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; g[j] = f[root] + g[root] - f[j]; Find_g ( j , root ); &#125; return;&#125;void Work ( int root , int fa ) &#123; int Frist = 0 , Second = 0; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Work ( j , root ); if ( LongDis[j][0] + g[j] &gt; LongDis[root][0] ) &#123; SecondDis[root][0] = LongDis[root][0]; LongDis[root][0] = LongDis[j][0] + g[j]; Frist = j; &#125; else if ( LongDis[j][0] + g[j] &gt; SecondDis[root][0] ) SecondDis[root][0] = LongDis[j][0] + g[j]; if ( LongDis[j][1] + f[j] &gt; LongDis[root][1] ) &#123; SecondDis[root][1] = LongDis[root][1]; LongDis[root][1] = LongDis[j][1] + f[j]; Second = j; &#125; else if ( LongDis[j][1] + f[j] &gt; SecondDis[root][1] ) SecondDis[root][1] = LongDis[j][1] + f[j]; &#125; if ( Frist != Second ) now_ans = max ( LongDis[root][0] + LongDis[root][1] , now_ans ); else if ( Frist == Second ) now_ans = max ( now_ans , max ( SecondDis[root][1] + LongDis[root][0] , SecondDis[root][0] + LongDis[root][1] ) ); return;&#125;int main ( void ) &#123; freopen ( "tree.in" , "r" , stdin ); freopen ( "tree.out" , "w" , stdout ); n = read (); for ( int i = 1 ; i &lt; n ; i++ ) &#123; int x = read () , y = read (); add ( x , y ); add ( y , x ); p[x]++; p[y]++; &#125; Find_f ( 1 , 0 ); Find_g ( 1 , 0 ); Work ( 1 , 0 ); printf ( "%d.00000\n" , now_ans ); return 0;&#125; T2:其实暴力还是挺显然的 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前排打出题人的一套题]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%89%8D%E6%8E%92%E6%89%93%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E4%B8%80%E5%A5%97%E9%A2%98%2F</url>
    <content type="text"><![CDATA[不管怎么样，先打死出题人再说qaq… T1:人贩子$LLFZ$ 题意很显然就是最优贸易啊…. 一眼看出来是缩点+DP….但是为什么我之前是SPFA过的啊QAQ…写SPFA比较稳….然后….就写了…. 上代码吧…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int N = 1e5 + 10;const int M = 1e6 + 10;const int INF = 2147483647;#define G(i,a,b,c) for ( int i = b[a] ; i ; i = c[i].next )int n , m , t , cnt;struct Edge &#123; int to; int data; int next;&#125;e[M] , e_[M];int head[N] , head_[N];int maxs[N] , mins[N];int dis[N] , value[N];bool inque[N];std :: queue &lt; int &gt; qu;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void add_ ( int x , int y , int z ) &#123; e_[++cnt].to = y; e_[cnt].data = z; e_[cnt].next = head_[x]; head_[x] = cnt; return;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;void Heap_Dijkstra () &#123; std :: memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[1] = 1 , dis[1] = value[1]; qu.push ( 1 ); while ( !qu.empty () ) &#123; int j = qu.front (); inque[j] = 0; qu.pop (); G ( i , j , head , e ) &#123; int k = e[i].to; if ( dis[k] &gt; min ( dis[j] , e[i].data ) ) &#123; dis[k] = min ( dis[j] , e[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) mins[i] = dis[i]; std :: memset ( dis , -0x3f3f3f3f , sizeof ( dis ) ); inque[n] = 1 , dis[n] = value[n]; qu.push ( n ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; G ( i , j , head_ , e_ ) &#123; int k = e_[i].to; if ( dis[k] &lt; max ( dis[j] , e_[i].data ) ) &#123; dis[k] = max ( dis[j] , e_[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) maxs[i] = dis[i]; return;&#125; int main ( void ) &#123; freopen ( "child.in" , "r" , stdin ); freopen ( "child.out" , "w" , stdout ); n = read (); m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) value[i] = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); if ( z == 1 ) &#123; add ( x , y , value[y] ); add_ ( y , x , value[x] ); &#125; else if ( z == 2 ) &#123; add ( x , y , value[y] ); add ( y , x , value[x] ); add_ ( y , x , value[x] ); add_ ( x , y , value[y] ); &#125; &#125; Heap_Dijkstra (); int ans = -INF; for ( int i = 1 ; i &lt;= n ; i++ ) ans = max ( ans , maxs[i] - mins[i] ); printf ( "%d\n" , ans ); return 0;&#125; T2 : food 再来拿出题人祭天祭一波… 话说我直接读题读错了然后写了个错误的DP然后还A了是什么鬼啊…. 话说我考虑了前缀和，那么我还过了，说明直接加起来然后除就可以? 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int N = 15;int n , ans = -1;int A , B , C;int p1 , p2 , p3;int MaxTime[N];int f[N][105][105][105];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;int main ( void ) &#123; freopen ( "food.in" , "r" , stdin ); freopen ( "food.out" , "w" , stdout ); A = read () , B = read () , C = read (); p1 = read () , p2 = read () , p3 = read (); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; MaxTime[i] = read (); MaxTime[i] = MaxTime[i - 1] + MaxTime[i]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = A ; j * p1 &lt;= MaxTime[i] &amp;&amp; j&lt;=100 ; j++ ) for ( int k = B; j * p1 + k * p2 &lt;= MaxTime[i] &amp;&amp; k &lt;= 100 ; k++ ) for ( int l = C ; j * p1 + k * p2 + l * p3 &lt;= MaxTime[i] &amp;&amp; l &lt;=100 ; l++ ) &#123; f[i][j][k][l] = max ( f[i][j][k][l] , max ( f[i - 1][j - A][k - B][l - C] + 1 , f[i][j - A][k - B][l - C] + 1 ) ); ans = max ( ans , f[i][j][k][l] ); &#125; printf ( "%d\n" , ans ); return 0;&#125; T3: Happy 再吐槽一波为什么Noip模拟赛会考离散对数（然而我并不会….） 其实应该是一道签到题吧。。。 暴力水过…. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int P , A , B;bool app[50005];int main ( void ) &#123; freopen ( "happy.in" , "r" , stdin ); freopen ( "happy.out" , "w" , stdout ); int T = read (); while ( T-- ) &#123; int now = 1; memset ( app , false , sizeof ( app ) ); P = read () , A = read () , B = read (); for ( int i = 1 ; ; i++ ) &#123; now = ( now * A ) % P; if ( now == B ) &#123; printf ( "%d\n" , i ); break; &#125; if ( app[now] ) &#123; puts ( "Couldn't Produce!" ); break; &#125; app[now] = 1; &#125; &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My_Code_Style]]></title>
    <url>%2F2018%2F10%2F13%2FMy_Code_Style%2F</url>
    <content type="text"><![CDATA[介绍下本蒟蒻的丑死的码风$qwq$…(码风大概是魔改了神犇$Menci$的) 在打CF时并不是这个码风 码风概述： 所有的#include后必须有一个空格,例如#include 无论什么样子的程序，都必须写cstdio cstring algorithm iostream这四个头文件。 在主程序的int main()中要加$void$，即为int main(void) 一般不写using namespace std; 所有的变量必须定义在第一个自定义函数之前，且变量和第一个自定义函数，最后一个自定义函数和$main$之间必须有一个换行 每个函数之后尽可能有$return$， 在一般情况下，在花括号内的内容不加逗号 缩进： 对于每个代码块，使用4空格或者等长的Tab缩进。 括号： 大括号不换行 空格： 个人感觉自己的空格比较的毒瘤。 1.在每个函数声明时，函数名后的括号与函数名之间必须有一个空格,而且括号内如果需要声明变量，则要先有一个空格，且逗号的前后都必须有一个空格。 2.在for循环的声明中，每一个字符（变量名除外），都要用空格隔开。 3.数组内一般不加空格，但是如果有运算符则运算符前后必须有空格。 4.每个可以前后匹配的括号前后必须有空格。 变量： 1.基本所有变量都是全局变量，但有些ans,sum最后统计答案时使用的变量可以定义为局部变量。 2.所有的变量名称都必须与要存储的东西的中文意思有沾边，比如树直接定义为tree而不是T。（极度不能容忍变量名直接为a,b,c,d,e,f,g,的情况。 3.定义N,M等时一般只用N,M为名称而不是MAXN,MAXM. 4.定义的结构体类型在定义变量时必须紧接着声明完成结构体后，并且结构体中变量需要定义一个加一个换行。 5.在变量命名时较长的变量名可以用_来连接，并且大小写交替使用，如Add_Tree_Val 把上边所有毒瘤的码风结合起来之后代码大概长这个样子qwq.. update:还是加上模板舒服qwq 不要吐槽我的丑逼$Splay…..$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register inttemplate &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt;typename T&gt; void write(T x) &#123;if (x &lt; 0) x = -x, putchar('-');if (x &gt; 9) write(x / 10);putchar(x % 10 + 48);return;&#125;template &lt;typename T&gt; void writeln(T x) &#123; write(x); printf ("\n"); &#125;/**********************************************************************************************************************************************************************************************************************************************************************/const int N = 1e6 + 5;int root , tot , n;struct Tree &#123; int ch[2]; int val; int father; int size; int cnt;&#125;tree[N];void pushup ( int cur ) &#123; tree[cur].size = tree[tree[cur].ch[0]].size + tree[tree[cur].ch[1]].size + tree[cur].cnt; return;&#125;void rotate ( int x ) &#123; int y = tree[x].father; int z = tree[y].father; int k = tree[y].ch[1] == x; tree[z].ch[tree[z].ch[1] == y] = x; tree[x].father = z; tree[y].ch[k] = tree[x].ch[k ^ 1]; tree[tree[x].ch[k ^1]].father = y; tree[x].ch[k ^ 1] = y; tree[y].father = x; pushup ( x ); pushup ( y ); return;&#125;void Splay ( int x , int goal ) &#123; while ( tree[x].father != goal ) &#123; int y = tree[x].father; int z = tree[y].father; if ( z != goal ) ( tree[y].ch[0] == x ) ^ ( tree[z].ch[0] == y ) ? rotate ( x ) : rotate ( y ); rotate ( x ); &#125; if ( goal == 0 ) root = x; return;&#125;void insert ( int x ) &#123; int cur = root , father = 0; while ( cur &amp;&amp; tree[cur].val != x ) &#123; father = cur; cur = tree[cur].ch[x &gt; tree[cur].val]; &#125; if ( cur ) tree[cur].cnt++; else &#123; cur = ++tot; if ( father ) tree[father].ch[x &gt; tree[father].val] = cur; tree[cur].ch[0] = tree[cur].ch[1] = 0; tree[cur].father = father; tree[cur].val = x; tree[cur].cnt = 1; tree[cur].size = 1; &#125; Splay ( cur , 0 ); return;&#125;void Find ( int x ) &#123; int cur = root; if ( !cur ) return; while ( tree[cur].ch[x &gt; tree[cur].val] &amp;&amp; x != tree[cur].val ) cur = tree[cur].ch[ x &gt; tree[cur].val]; Splay ( cur , 0 ); return;&#125;int Next ( int x , int f )&#123; Find ( x ); int cur = root; if ( tree[cur].val &gt; x &amp;&amp; f ) return cur; if ( tree[cur].val &lt; x &amp;&amp; !f ) return cur; cur = tree[cur].ch[f]; while ( tree[cur].ch[f ^ 1] ) cur = tree[cur].ch [f ^ 1]; return cur;&#125;void Delete ( int x ) &#123; int last = Next ( x , 0 ); int next = Next ( x , 1 ); Splay ( last , 0 ); Splay ( next , last ); int del = tree[next].ch[0]; if ( tree[del].cnt &gt; 1 ) &#123; tree[del].cnt--; Splay ( del , 0 ); &#125; else tree[next].ch[0] = 0; return;&#125;int kth ( int x ) &#123; int cur = root; if ( tree[cur].size &lt; x ) return 0; while ( 1 ) &#123; int y = tree[cur].ch[0]; if ( x &gt; tree[y].size + tree[cur].cnt ) &#123; x -= tree[y].size + tree[cur].cnt; cur = tree[cur].ch[1]; &#125; else if ( tree[y].size &gt;= x ) cur = y; else return tree[cur].val; &#125;&#125;int main ( void ) &#123; n = read (); insert ( 2147483647 ); insert ( -2147483647 ); while ( n-- ) &#123; int opt = read (); if ( opt == 1 ) &#123; int x = read (); insert ( x ); &#125; else if ( opt == 2 ) &#123; int x = read (); Delete ( x ); &#125; else if ( opt == 3 ) &#123; int x = read (); Find ( x ); printf ( "%d\n" , tree[tree[root].ch[0]].size ); &#125; else if ( opt == 4 ) &#123; int x = read (); printf ( "%d\n" , kth ( x + 1 ) ); &#125; else if ( opt == 5 ) &#123; int x = read (); printf ( "%d\n" , tree[Next ( x , 0 )].val ); &#125; else if ( opt == 6 ) &#123; int x = read (); printf ( "%d\n" , tree[Next ( x , 1 )].val ); &#125; &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeStyle</tag>
      </tags>
  </entry>
</search>
