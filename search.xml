<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round #595 (Div. 3)]]></title>
    <url>%2F2019%2F10%2F23%2FRound595%2F</url>
    <content type="text"><![CDATA[降智题真的可以为所欲为. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高失联测D7]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E8%81%94%E6%B5%8BD7%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开. dls的生日礼物还是首先考虑无解的话会是什么情况,无解的话,一定是某一段长度大于$1$的区间被覆盖了两次以上,这个显然可以离散化来统计.然后我们再来想有解的情况,我们考虑,这道题让你把原来的区间分成两个集合,而相交的区间必须颜色不同.所以我们考虑到二分图模型.如果两个区间相交的话,那么这两个区间是要有边相连的.而因为我们已经排除了无解的情况,所以有解的情况一定会是一张二分图.即所有的连通块都是二分图.但是我们发现,如果暴力枚举区间连边的话是$O(n^2)$的,需要考虑怎么优化.我们又发现在某个连通块中,因为连通块中的点都是区间看成的点,所以一个连通块也就代表了一个区间,我们只需要考虑一下互不相交的连通块的个数$x$然后答案就是$2^x$. dls的生日宴会首先我们发现,如果我们按照$k=\frac{n}{2} , \frac{n}{4} , \frac{n}{8}$不断选取$k$的值的话,那么轮数为$logn$轮,即轮数最多为$logn$(向上取整)轮.我们假设我们一共操作了$m$轮,第$i$轮我们选择的$k$的值为$k_i$,那么如果满足能找到$dls$的话,需要满足 m]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Global Round 5题解]]></title>
    <url>%2F2019%2F10%2F21%2FGrobalRound5%2F</url>
    <content type="text"><![CDATA[传说中集齐了五颗无限宝石的$tourist$一个响指能让所有人的$rating$消失一半 Balanced Rating Changes发现在答案一定存在的情况下,对于每个偶数,一定是直接把$i$变成$\frac{i}{2}$.我们要考虑的就只有奇数的情况.显然,对于每个正数奇数和每个负数奇数,他们分别向上取整和向下取整的次数应该是一样多的.所以我们不如钦定刚开始无论正的奇数向下取整,负的奇数向上取整,然后扫一遍$check$即可.12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int change;int num[20000],ans[20000];int main()&#123; int T; scanf("%d",&amp;T); for(int i=1;i&lt;=T;i++)&#123; scanf("%d",&amp;num[i]); ans[i]=num[i]/2; change+=ans[i]; &#125; if(change==0) for(int i=1;i&lt;=T;i++) printf("%d\n",ans[i]); else&#123; if(change&gt;0)&#123; for(int i=1;i&lt;=T&amp;&amp;change!=0;i++)&#123; if(num[i]&lt;0&amp;&amp;num[i]%2==-1)&#123; change--; ans[i]--; &#125; &#125; &#125; else for(int i=1;i&lt;=T&amp;&amp;change!=0;i++) if(num[i]%2==1&amp;&amp;num[i]&gt;0)&#123; ans[i]++; change++; &#125; for(int i=1;i&lt;=T;i++) printf("%d\n",ans[i]); &#125; return 0;&#125; Balanced Tunnel考虑如果有一辆车在进入隧道行使的过程中没有被其他车超车的话,那么本来在它前边的车出去之后应该还在它前边(废话).考虑怎么判断这个东西,我们对于初始位置的车辆,我们记录一个$id_i$,即初始在$i$这个位置的车辆,它的$id$为$i$.然后我们发现在$id$这个东西,如果有一辆车$j$在车$i$的前方,那么$id_j$一定大于$id_i$.而如果本来有一辆车在它后边超过了它,那么在新的车辆中一定有一个$max(id_{i+1}…id_{n})&gt;id_i$(注意这里的标号为重排之后的标号.)那么我们只需要记录一个重排之后的车的$id$的后缀最大值,然后对于每辆车$i$,我们$check$一下前缀最大值是不是有比它小的从而可以不重不漏的$check$它有没有超车,然后统计答案即可.123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+10;int n;int pos[N],fin[N];int mins[N];int main()&#123; memset(mins,0x3f,sizeof(mins)); ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; pos[x]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; fin[i]=pos[x]; &#125; for(int i=n;i&gt;=1;i--) mins[i]=min(mins[i+1],fin[i]); int ans=0; for(int i=1;i&lt;n;i++) if(mins[i+1]&lt;fin[i]) ans++; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Balanced Removals (Easier)发现我们需要一个$O(n^2)$的算法.我们发现对于某个点$i$,那么距离它最近的点一定是最优的(因为中间不可能有其他的点).所以我们只需要对于每个点枚举一下目前没有用过的点中距离它最近的点即可.1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=2005;int n;struct Node&#123; int x,y,z;&#125; node[N];bool rem[N];inline int calc(int x,int y)&#123; return abs(node[x].x-node[y].x)+abs(node[x].y-node[y].y)+abs(node[x].z-node[y].z);&#125;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;node[i].x&gt;&gt;node[i].y&gt;&gt;node[i].z; for(int i=1;i&lt;=n;i++)&#123; if(rem[i]) continue; int mins=1e16,sign; for(int j=i+1;j&lt;=n;j++)&#123; if(rem[j]) continue; int val=calc(i,j); if(val&lt;mins)&#123; mins=val; sign=j; &#125; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;sign&lt;&lt;endl; rem[i]=1; rem[sign]=1; &#125; return 0;&#125; Balanced Removals (Harder)发现我们需要一个$O(nlogn)$的算法.而直接优化$Eazy$难度的算法貌似不怎么可能,所以我们考虑换方法.我们首先想怎么降维,我们对于$x$和$y$相等的先用贪心取最短的处理的话,那么发现$z$这一维就没啥用了.那么这个问题就转化成了二维的问题,然后我们再对于所有$x$相等的重复贪心取最短处理,这样的话我们只需要排两次序即可. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柯学上网教程]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%9F%AF%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[感觉我人要没.jpg “欸,你为啥能上Google啊?”这都$9102$年了,如果你还说你是用的某虚拟专线网络的话那你就8太彳亍了.毕竟…国外用着靠谱的那些东西,他们的价格是这样的:这样的还有这样的 emmmmm…如果你家里有矿的话你现在可以不要往下阅读了. 显然对于一般的家里没矿的普通人来说,这东西的价格显然不现实对趴.所以怎么办呢? 没钱,没办法,没钱你想什么柯学上网其实百度也挺好用的,不要想着用$Google$了,好好的做一个社会主义好青年趴(doge).]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>柯学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大图床稳定性测试]]></title>
    <url>%2F2019%2F10%2F21%2F%E5%9B%9B%E5%A4%A7%E5%9B%BE%E5%BA%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%B5%8B%E8%AF%95x%2F</url>
    <content type="text"><![CDATA[众所周知的360,新浪,百度,搜狗图床,到底谁最容易挂稳定呢 统一上传一张图,看看哪一个图床最后挂掉(我感觉退役之前是挂不完了) 新浪图床: 搜狗图床: 百度图床:打假赛的百度图床选手提前倒下(doge) 360图床:打假赛的360图床选手提前倒下(doge) 感觉竞争并不会太激烈.jpg 我自己的github图床: 做个对比吧万一github没了就尴尬了 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>无聊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普转提D5题解]]></title>
    <url>%2F2019%2F10%2F20%2F%E6%99%AE%E8%BD%AC%E6%8F%90D5%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 Zbox loves keyboard首先考虑直接递推,但是由于$Backspace$操作的存在,使得出现了后效性,所以貌似无法直接递推.然后我们考虑一下先不考虑$Backspace$怎么做.我们引入图论模型,把$[1,10^6]$中的每个值都看做一个点.然后我们考虑前几个操作,那么 对于每个点$x$,由$x$向$x+1$连接一条边. 对于每个点$x$,我们从小到大枚举$k$使得从$x$到$x \times k &lt;= n$连接一条边. 然后我们只需要从$x$向$n$跑一遍最短路即可(目测会卡某死掉的算法).然后我们再来考虑一下有$Backspace$怎么做.我们发现,如果我们从某个点$i$超级加倍到了$2 \times i$,而$2 \times i$比$n$大好多好多,那么我们在一个一个$Backspace$的时候一定会遇到一个$j (n&lt;j&lt;i)$可以从$x$转移到.所以我们瞎猜看题解看出来了$Backspace$操作的上界$100$,然后我们对于每个$i$,都向$[max(1,i-100),i-1]$的区间的点连边就好了. 这样的话我们计算一下时间复杂度发现边的数量为调和级数为$nInn$的复杂度,而我们跑一遍$Heap$_$Dijkstra$是$O(nlog_2m)$的.所以总复杂度为$O(n{log^2_2n})$.注意到$n$其实挺大的,所以需要卡卡常数(比如用斐波那契堆跑$Heap$_$Dijkstra$什么的) Zbox loves graph这道题正解好像真的是暴力(首先发现如果我们缩点缩出来一个$DAG$之后,对于每一个强连通分量我们可以开一个$bitset$来统计.但是如果强连通分量很多的话不行?发现一个题目中给定的一个重要的条件:因为这是一张随机图,所以强连通分量的个数一定不会太多,而且弱联通分量也不会太多.既然是暴力,那么我们考虑一下怎么卡常.首先$bitset$的常数小的一批.但是貌似直接做还是有点困难.我们考虑把所有的弱联通分量分别拿出来对里边的点进行重标号之后再分别做出来,然后直接对$bitset$进行一次$or$操作这样可以省去很多时间.剩下的….不说了我继续去卡常了 Zbox loves memory这个真的连正解是啥都不知道块状链表套$tire$,嗯这很SCP. ISN这道题听说树状数组优化下$DP$就过了,咱也不敢问. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取石子(概率期望)]]></title>
    <url>%2F2019%2F10%2F16%2F%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B%E5%85%A5%E9%97%A8%E5%8F%96%E7%9F%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[我看我是完全不懂哦 题面:其中$1&lt;=n&lt;=10^5$,$1&lt;=a_i&lt;=10^9$ 首先我们推广一下,概率具有可加性(也叫线性性).用公式解释就是$E(XY)=E(X)+E(Y)$.然后具体推广到这道题的话,我们设$E(t)$表示答案,那么$E(t)=[\sum_{i=2}^{n}P_i]+1$.其中$P_i$表示$i$这堆在$1$号堆之前被拿的期望.然后假设我们每次在$1$号堆和$x$号堆之间选择一堆的话,那么选择$x$号堆还是选择$1$号堆之间的相对概率是不受其他堆石子影响的.即$P_i=\frac{a_i}{a_i+a_1}$.那么答案很显然就是$ans=[\sum_{i=2}^{n}\frac{a_i}{a_1+a_i}]+ 1$时间复杂度为$O(n)$123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=1e5+10;int n;double a[N];signed main(void)&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; double ans=1.0; for(int i=2;i&lt;=n;i++) ans=ans+(a[i]/(a[1]+a[i])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Karen And SpuerMarket题解]]></title>
    <url>%2F2019%2F10%2F16%2FSuperMarket%2F</url>
    <content type="text"><![CDATA[九条可怜是个可爱的女孩子首先发现,题目中的对于使用优惠劵的条件的约束,如果建一张图出来,那么很容易就可以发现满足这是一棵树.所以我们考虑使用树形$DP$来解决问题.我们设$f_{i,j,0/1}$来表示在以$i$为根节点的子树中,选择$j$个使用优惠卷,当前的这个选/不选择优惠卷时能得到的最小花费.然后转移的时候枚举一下子树,因为体积都为$1$,所以可以根据经典的树上背包的优化把这道题优化到$O(n^2)$.考虑一下怎么转移,显然,当我们当前到达的$i$这个节点使用优惠券的话,那么它可以从它的子树中使用或者不用优惠卷的状态转移过来,如果当前的这个节点不适用优惠券的话,那么它就只能从它子树的不使用优惠券的状态转移过来. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define sz(x) ((int) (x).size())#define forn(i,n) for (int i = 0; i &lt; int(n); ++i)#define all(x) (x).begin(), (x).end()typedef long long ll;typedef long long i64;typedef long double ld;const int inf = int(1e9) + int(1e5);const ll infl = ll(2e18) + ll(1e10); const int maxn = 5005;int B;int c[maxn];int d[maxn];vector&lt;int&gt; g[maxn];int n; int kc[maxn][maxn];int kd[maxn][maxn];int cnt[maxn];int buf[2][maxn]; void merge(int *a, int *b, int *to, int c1, int c2) &#123; forn (i, c1 + c2 + 1) to[i] = inf; forn (i, c1 + 1) forn (j, c2 + 1) to[i + j] = min(to[i + j], a[i] + b[j]);&#125; void dfs(int u) &#123; for (int v: g[u]) dfs(v); int q = 0; forn (i, n + 1) buf[q][i] = inf; cnt[u] = 1; buf[q][0] = 0; buf[q][1] = c[u]; for (int v: g[u]) &#123; merge(buf[q], kc[v], buf[q ^ 1], cnt[u], cnt[v]); q ^= 1; cnt[u] += cnt[v]; &#125; forn (i, n + 1) kc[u][i] = buf[q][i]; q = 0; forn (i, n + 1) buf[q][i] = inf; cnt[u] = 1; buf[q][1] = c[u] - d[u]; for (int v: g[u]) &#123; merge(buf[q], kd[v], buf[q ^ 1], cnt[u], cnt[v]); q ^= 1; cnt[u] += cnt[v]; &#125; forn (i, n + 1) kd[u][i] = min(buf[q][i], kc[u][i]);&#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; B; forn (i, n) &#123; cin &gt;&gt; c[i] &gt;&gt; d[i]; if (i) &#123; int x; cin &gt;&gt; x; --x; g[x].push_back(i); &#125; &#125; dfs(0); int p = n; while (kd[0][p] &gt; B) --p; cout &lt;&lt; p &lt;&lt; '\n';&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces Round #592]]></title>
    <url>%2F2019%2F10%2F15%2FRound-592%2F</url>
    <content type="text"><![CDATA[我好菜啊 Pens and Pencils发现直接除一下,算出来分别需要多少铅笔和钢笔,最后看一下加起来是不是大于$k$即可.注意一个细节,假如我们有$8$个工作需求,然后一支铅笔可以解决$3$个的话,那么我们需要$3$支铅笔.所以我们不能直接算$a/x$,而是要算$(a+(x-1))/x$.1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int T; cin&gt;&gt;T; while(T--)&#123; int a,b,c,d,k; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;k; int ll=(a+(c-1))/c; int rr=(b+(d-1))/d; if(ll+rr&gt;k) puts("-1"); else cout&lt;&lt;ll&lt;&lt; " "&lt;&lt;rr&lt;&lt;endl; &#125; return 0;&#125; Rooms and Staircases首先考虑一下走楼梯对答案有什么好处.如果不走楼梯的话,那么答案一定就是$n$.我们设一个楼梯在房间$i$的位置,那么我们从$1$走到$i$时,如果选择从$i$这个点走下去的话.那么如果我们向右走,显然和直接不走楼梯没区别.而且根据题目中的限定,我们向初始走的位置的反方向走的时候就一定不能再回来了,所以我们的决策就是在每个楼梯的地方,判断一下是继续走的答案更优秀,还是走回去的答案更优秀,取最大值即可.123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int n;string s;int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin &gt;&gt; T; while (T--)&#123; cin&gt;&gt;n&gt;&gt;s; int ans=-1; for(int i=0;i&lt;n;i++) if(s[i]=='1') ans=max(ans,2*(i+1)); int now=1; for(int i=n-1;i&gt;=0;i--)&#123; if(s[i]=='1') ans=max(ans,2*(now)); now++; &#125; if(ans==-1) ans=n; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; The Football Season现在不会x. Paint the Tree首先考虑判断一下无解的情况,由于每相邻的三个点都不能同色,而我们只能把这些点染成三种颜色.那么考虑某个节点$i$,如果和$i$直接相邻的点多于$2$个,那么无论如何都会有两个节点同色的.发现在上图(样例二)中,因为与节点$3$直接相邻的点为$3$个.所以这个情况是无解的.所以发现有解的情况只有是链的情况.而在一条链的情况下,如果我们确定了前两个节点的颜色的话,那么这条链的颜色也是一定可以被确定下来的.又因为前两个点的颜色只有$3 \times 2=6$种情况,所以我们可以直接暴力统计答案即可.时间复杂度为$O(6 \times n)$.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 5;int n, tot, rt, len, ansx, ansy;ll f[N][5][5], ans;int fr[N][5][5];int c[5][N];int head[N], deg[N], sen[N], res[N];struct Edge &#123; int u; int v; int next;&#125; e[N &lt;&lt; 1]; inline void addedge(int u, int v) &#123; e[++tot] = (Edge) &#123;u, v, head[u]&#125;; head[u] = tot; e[++tot] = (Edge) &#123;v, u, head[v]&#125;; head[v] = tot; return; &#125; void dfs1(int u, int fa) &#123; sen[++len] = u; for(register int i = head[u]; i; i = e[i].next) &#123; int v = e[i].v; if(v == fa) continue; dfs1(v, u); &#125; return; &#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=4;j++) for(int k=0;k&lt;=4;k++) f[i][j][k]=1e16; for(int i = 1; i &lt;= 3; i++) for(int j = 1; j &lt;= n; j++) cin&gt;&gt;c[i][j]; for(int i = 1; i &lt; n; i++) &#123; int u, v; cin&gt;&gt;u&gt;&gt;v; deg[u]++; deg[v]++; addedge(u, v); &#125; for(int i = 1; i &lt;= n; i++) if(deg[i] &gt;= 3) &#123; puts("-1"); return 0; &#125; for(int i = 1; i &lt;= n; i++) if(deg[i] == 1) &#123; rt = i; break; &#125; dfs1(rt, 0); for(int i = 1; i &lt;= 3; i++) for(int j = 1; j &lt;= 3; j++) &#123; if(i == j) continue; f[2][i][j] = min(f[2][i][j], (ll)c[i][sen[1]] + c[j][sen[2]]); &#125; for(int i = 3; i &lt;= n; i++) for(int j = 1; j &lt;= 3; j++) for(int k = 1; k &lt;= 3; k++) for(int t = 1; t &lt;= 3; t++) &#123; if(j == k || j == t || k == t) continue; if(f[i][k][t] &gt; f[i - 1][j][k] + c[t][sen[i]]) &#123; f[i][k][t] = f[i - 1][j][k] + c[t][sen[i]]; fr[i][k][t] = j; &#125; &#125; ans = f[0][0][0]; for(int i = 1; i &lt;= 3; i++) for(int j = 1; j &lt;= 3; j++) if(f[n][i][j] &lt; ans) &#123; ans = f[n][i][j]; ansx = i; ansy = j; &#125; res[sen[n - 1]] = ansx; res[sen[n]] = ansy; for(int i = n; i &gt;= 3; i--) &#123; int go = fr[i][ansx][ansy]; ansy = ansx; ansx = go; res[sen[i - 2]] = go; &#125; cout&lt;&lt;ans&lt;&lt;endl; for(int i = 1; i &lt;= n; i++) cout&lt;&lt;res[i]&lt;&lt;" "; return 0;&#125; Minimizing Difference这不是一眼题吗为什么要放到E上,放到C上不行吗发现我们每次操作的话肯定是对最大值或者最小值进行操作.所以我们先把原来的数组排序.然后我们每次枚举一下我们要把第几大的和第几小的进行操作,而这个操作显然可以双指针优化.12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int inf = 1e18 + 7;const int N = 1e5 + 10;int n, k,ans;int a[N], sum[N], cnt[N];signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++ i)&#123; cin &gt;&gt; a[i]; cnt[i] = 1; &#125; sort(a + 1, a + n + 1); ans = a[n] - a[1]; for (int i = 0; i &lt; n; ++ i)&#123; int l = 1 + i; int r = n - i; if (l &gt;= r) break; if (l + 1 != r)&#123; int can = k / (i+1); if (can == 0) break; int lim = a[l+1]-a[l] + a[r]-a[r-1]; ans -= min(lim, can); k -= min(lim, can) * (i+1); if (lim &gt; can) break; &#125; if (l + 1 == r)&#123; int can = k / (i+1); if (can == 0) break; int lim = a[r]-a[l]; ans -= min(lim, can); k -= min(lim, can) * (i+1); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI普转提D4]]></title>
    <url>%2F2019%2F10%2F13%2FZROI%E6%99%AE%E8%BD%AC%E6%8F%90D4%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 控制人偶发现我们只要算出来在一个循环中,坐标的变化值$(\Delta x , \Delta y)$.然后将变化值去乘循环时间的个数,最后多出来的暴力即可. 复杂度计算来我们开始一步一步的推公式(题目中要我们求的时间复杂度,写成多项式的形式就是: \sum_{i=1}^n\sum_{j=1}^m\sum_{k=i}^n\sum_{l=j}^m\sum_{x=i}^k\sum_{y=j}^l 1首先我们可以发现,最后的$x$和$y$的两维,因为是直接加起来的,所以可以直接变成$(l-j+1) \times (k-i+1)$,那么原来式就变成了 \sum_{i=1}^n\sum_{j=1}^m\sum_{k=i}^n\sum_{l=j}^m(l-j+1) \times (k-i+1)然后我们发现,同样的$(l-j+1)$和$(k-i+1)$分别都是被统计了$(m-j+1)$次和$(n-i+1)$次,所以由乘法分配律可知 \sum_{k=i}^n\sum_{l=j}^m(l-j+1) \times (k-i+1) = \sum_{k=i}^n[\sum_{l=1}^{m-j+1} \times (k-i+1)]发现$(k-i+1)$的系数可以直接等差数列求和,然后再将$\sum_{k=i}^n$拆开和等差数列求和公式之后就会得到 \sum_{i=1}^n\sum_{j=1}^m\sum_{k=i}^n\sum_{l=j}^m(l-j+1) \times (k-i+1) = \sum_{i=1}^n\sum_{j=1}^m\frac{(n-i+1) \times (n-i+2)}{2} \times \frac{(m-j+1) \times (m-j+2)}{2}将分母提取出来之后,可以得到原式等价于 \frac{\sum_{i=1}^n\sum_{j=1}^m (n-i+1) \times (n-i+2) \times (m-j+1) \times (m-j+2)}{4}然后继续固定$i$,我们发现系数满足$A_i=i^2+i$,那么根据$\sum_{i=1}^n i^2=\frac{n \times (n+1) \times (2 \times n + 1)}{6}$有原式等价于$[\frac{m \times ( m + 1 ) \times ( 2 \times m + 1) }{6} \times \frac{m \times (m+1)}{2}] \times [\frac{n \times (n+1) \times (2 \times n + 1 )}{6}+\frac{n \times ( n + 1 )}{2}] / 4$预处理逆元之后可以直接$O(1)$求出 复印任务我们注意到$1&lt;=t_i&lt;=10^3$.所以我们可以在很少的时间内怼同类时间的复印机进行预处理.由于我们知道每个复印机的启动时间,所以我们可以维护三个值.我们用$c_i$表示周期为$i$的复印机个数,$f_{t,p}$表示周期为$t$的复印机,且它的工作的起始时间对$t$取膜以后是$p$的个数(同时我们用$g$)表示$f$的后缀和.同时我们记录$s_t$表示所有周期为$t$的时间的复印机进入打印状态所欲要的$t$的时间周期有多少个.通过处理这三个数组,我们可以很快的计算同类周期的复读机在一段时间内的打印个数. 所以我们可以选择二分一个时间$T$,假设我们现在枚举的复印机的时间周期为$t$,那么我们发现能产生的复印件个数为$c_t \times (T/t) - s_j - f_{j,Tmodt+1} $然后我们把每个时间的加起来就是答案. A+B Problem二维树状数组裸题….直接安利我学习的博客了qwq.. 写的挺好的一篇博客 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI普及五联测D3]]></title>
    <url>%2F2019%2F10%2F12%2FZROI%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8BD3%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开. 旋风回旋曲由于可能的情况非常的小,所以我们只需要判断一下的几种情况: 从$x$直接走到$y$. 从$x$走到$a$,再从$b$走到$y$. 从$x$走到$b$,再从$a$走到$y$.由于只有三种情况,直接$3$个$if$判断一下即可. 假面饭店首先第一反应就是枚举每个数字取还是不取,所以我们需要$2^{size}$枚举每个数,但是显然还得枚举每个数的顺序,复杂度明显过不了.所以我们考虑枚举$i$来得到$i^2$.这样的话,发现我们最多是只需要枚举到$\sqrt{10 \times n}$即可.枚举的时候注意一下剪枝,不然就会$T$掉. 疯狂外星人发现我们可以枚举一下不能放入的物品是哪个.那么显然如果第$i$个物品不能放入的话,重量比$i$小的物品一定要都被放进去.然后再来考虑一下重量比$i$大的物品.发现我们可以用计数类的$01$背包来解决.最后需要注意一点,如果全都能放进去的话,也需要算一种方案,所以我们要枚举到第$n+1$个物品. 流浪地球发现维护连通块的消失的话,显然不怎么可做.所以我们尝试离线,我们把询问按照从大到小排序,然后每次从一个询问过渡到另外一个询问的时候,会出现若干个新的”大陆”.然后我们的任务就变成了这些新的大陆能不能和其他的连通块连起来.对于这一个操作,显然我们可以维护一个并查集,每次判断+合并几个连通块即可. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round74题解]]></title>
    <url>%2F2019%2F10%2F10%2FRound74%2F</url>
    <content type="text"><![CDATA[又安排了队友一手….. Prime Subtraction可以发现,如果只是用质数的话,那么除了$1$之外的数都是可以由质数凑出来的.所以只需要判断一波是不是相差为$1$即可.123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long a,b; int T; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;a&gt;&gt;b; if(a-b==1) puts("NO"); else puts("YES"); &#125; return 0;&#125; Kill ‘Em All发现如果我们打了一个按照坐标排序之后中间的数,那么对于右边的数字来说一定是劣的.所以我们发现,如果我们排序之后,从右往左开始打的话,那么对于答案的贡献一定不会更劣.所以直接排序之后从右往左打然后判断即可. 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; return s*w;&#125; const int N=1e5+10;int n,r;int pos[N];bool dis[N];inline bool cmp(int x,int y)&#123; return x&gt;y;&#125;signed main()&#123; int T=read(); while(T--)&#123; memset(dis,0,sizeof(dis)); n=read(),r=read(); for(int i=1;i&lt;=n;i++) pos[i]=read(); sort(pos+1,pos+1+n,cmp); int tag=0,ans=0; for(int i=1;i&lt;=n;i++)&#123; if(dis[pos[i]]) continue; if(pos[i]-tag*r&lt;=0) break; dis[pos[i]]=1; ans++; tag++; &#125; printf("%lld\n",ans); &#125; return 0;&#125; Standard Free2play我们来模拟一下一个人从高处到低处”掉下来”的过程.我们假设本来在外面的是$1$,不在外面的是$0$.考虑一个序列$11100$,如果我们站在最左边的那个$1$上,如果我们想要往右(即往下跳)的话,我们使用最左边的这个按钮,那么序列就会变成$00100$,而我们现在位于中间的那个$1$上.发现如果我们当前的位置到下一个$1$的位置,如果是连续的$1$的区间的话,那么我们一定只能跳奇数个段.如果两者的高度差大于$2$(即跳一下会摔死的话),那么就要么改变现在的状态,要么使用一个膜法石.显然,如果我们要跳到的这个位置到我们现在的这个位置中间间隔了偶数个紧贴着的即$111$这样的话,我们就需要使用膜法石,否则我们就不需要用膜法石.但是注意一下发现开头和结尾的位置是不一样的所以对位于顶端和末尾的情况特殊讨论一下即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;#define fore(i, l, r) for(int i = int(l); i &lt; int(r); i++)#define sz(a) int((a).size())#define x first#define y secondconst int INF = int(1e9);int h, n;vector&lt;int&gt; p;inline bool read() &#123; if(!(cin &gt;&gt; h &gt;&gt; n)) return false; p.resize(n); fore(i, 0, n) cin &gt;&gt; p[i]; return true;&#125;inline void solve() &#123; int ans = 0; int lf = 0; fore(i, 1, n) &#123; if (i &gt; 0 &amp;&amp; p[i - 1] &gt; p[i] + 1) &#123; if (lf &gt; 0) ans += (i - lf) &amp; 1; else ans += 1 - ((i - lf) &amp; 1); lf = i; &#125; &#125; if (p[n - 1] &gt; 1) &#123; if (lf != 0) ans += (n - lf) &amp; 1; else ans += 1 - ((n - lf) &amp; 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int tc; cin &gt;&gt; tc; while(tc--) &#123; read(); solve(); &#125; return 0;&#125; AB-string发现直接求的话貌似不怎么好求,所以我们考虑下求出所有的不好的串然后从总答案中减去.考虑怎求出所有不好的字串.首先发现只有$A$和$B$这两种字符,那么有一个很显然的结论:如果$s_i!=s_{i+1}$或者$s_i!=s_{i-1}$,那么$s_i$和$s_{i+1}$所在的字串一定是不好的.所以我们直接正反判断两边即可.1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int N=3e5+10;int n;long long ans;char str[N];inline void Solve(int x)&#123; int now=1,d=x; for(int i=2;i&lt;=n;i++)&#123; // cout&lt;&lt;str[i]&lt;&lt;" "&lt;&lt;str[i-1]&lt;&lt;endl;3 if(str[i] == str[i-1]) now++; else &#123; ans -= now-d; now = 1; &#125; &#125; return;&#125; int main()&#123; scanf("%d",&amp;n); scanf("%s",str+1); ans = 1ll*n*(n-1)/2; Solve(0); std::reverse(str+1,str+n+1); Solve(1); printf("%lld\n",ans); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kruscal重构树学习笔记]]></title>
    <url>%2F2019%2F10%2F09%2FKruskal%E9%87%8D%E6%9E%84%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学不会啊…. 以上就是性质,讲完了 你们不要打我QAQ… 一道例题(货车运输)我们看一下第五条性质,哎妈呀这道题不是裸题吗.我们跑一遍$Kruscal$重构树,然后询问的时候每两个点的答案,就是这两个在重构树上$LCA$的点权.然后就没了. 另一道例题(有没有大佬知道是哪个OJ上的题话告诉我谢谢) 第一反应是考虑每条边在作为权值最小的边的时候的贡献,但是发现这样也并不好统计最终贡献.所以根据这篇博客的标题,我们来考虑$Kruscal$重构树的做法.我们发现$Kruscal$重构树满足大根堆的性质,那么我们考虑某一个边权节点,他有贡献的路径很显然是它连接的叶子节点的路径一直到某个不在它子树内而且父亲节点大于它的节点.但是发现这样也并不好统计最终贡献.发现,如果重构树满足小根堆的性质的话,那么我们发现两点间路径边权的最小值就是他们的$LCA$,这样就方便统计答案了.所以我们考虑把所有的边权同乘$-1$,这样之后再建重构树.然后就可以统计答案了. 还有一道例题(有没有大佬知道是哪个OJ上的题话告诉我谢谢)也是$Kruscal$重构树的套路题…对于边权最大值的限制， 完全可以等价地转化到它们在最小瓶颈生成树上路径边权最大值的限制。考虑$Kruskal$重构树上一个点在只允许走边权$&lt;=k$的边的情况下能够到的点的集合,发现它们是一棵子树,且根为$s$的某个祖先.具体来说,是$s$到根路径上深度最小的点权$&lt;=k$的祖先我们可以倍增地找到这个祖先,接下来问题就转化为了经典问题:求一个子树当中的权值第k大.使用主席树可以轻松解决. 最后一道例题(归程)题面就不放了….因为每天开始的时候车的位置都会被重置一次,所以我们对于每次询问都可以在起点进行一次$bfs$,然后答案就是这些点中到$1$号点距离最小的点.但是这样…显然过不了…发现每次进行询问的时候都去$bfs$一遍显然太慢了,而且这道题为强制在线,也不能按照这些询问的海拔排序.那么我们怎么办呢?根据标题,我们可以选择$Kruscal$重构树来解决掉这道题.首先我们发现,$Kruscal$重构树满足大根堆的性质,那么满足海拔大于水位线的边组成的点一定是某一颗子树.然后我们可以进行一次堆优化的$Dijkstra$进行预处理,然后把$1$号点到每个点的最短路的长度记为重构树上新的点的点权.然后对于每次查询,我们的任务就变成了查询某颗子树中的叶子的权值最小值,而且是静态的.显然可以$log$的复杂度随便搞一搞. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>学习笔记</tag>
        <tag>最小生成树</tag>
        <tag>Kruscal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF416E]]></title>
    <url>%2F2019%2F10%2F09%2FCF416E%2F</url>
    <content type="text"><![CDATA[$ZROI$杂题选讲…. 看到这道题之后,我们第一反应肯定是一遍$Floyd$.然后考虑一下怎么判断某条边是不是被最短路覆盖.朴素的想法是我们每次枚举边,然后以这条边两条边的端点$u,v$再枚举这两个端点的所有最短路.即判断 dis(s,u)+w+dis(v,t)==dis(s,t)或者 dis(s,v)+w+dis(u,t)==dis(s,t)但是这样统计答案的话,由于边的条数为$n^2$的,所以这种算法的总复杂度为$O(n^4)$的.显然过不了所以我们考虑一下怎么优化.我们考虑上一个算法的时间复杂度的瓶颈,显然在我们枚举了$s,t$之后,因为还需要枚举每一条边,所以枚举边显然会超时.所以我们考虑一下枚举完$s,t$之后不再枚举每一条边,而是去枚举每一个中转点$p$.然后如果我们发现 dis(s,p)+dis(p,t)==dis(s,t)那么显然在$dis(s,p)$上以$p$结尾的边都是可以被加入的.所以我们现在的问题就只剩下了怎么求在$dis(s,p)$上的点了.发现我们就算暴力枚举每条边然后验证也并不会超时.所以直接这样做就可以了 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GXOI/GZOI2019]旅行者]]></title>
    <url>%2F2019%2F10%2F08%2FSNOI2017-%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[$ZROI$杂题选讲…..多点最短路?floyd直接莽啊我知道你很勇,但是这道题$10^5$真的没法直接莽啊… 考虑那$K$组特殊的点,我们发现如果我们把它们分成两组,然后由一组向另一种跑最短路,很明显可以得到答案.但是很显然不能只是分组分一次.我们考虑优化分组的过程.发现在考虑二进制之后,每两个互不相同的值一定最少会有一个不同的地方.所以我们如果对于每个点的编号,按照$1&lt;&lt;i$进行分类的话.一定可以保证在某一次分类的过程中,有任意两个点被分到了不同的集合内部.所以我们对这$K$组关键点进行二进制分组,然后建一个超级源点和一个超级汇点分别连接入集合和出集合.然后查询这个超级源和超级汇之间的最短路即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;inline LL read()&#123; LL x = 0,f = 1; char c = getchar(); while (c != EOF &amp;&amp; !isdigit(c)) &#123;if (c == '-') f = -1;c = getchar();&#125; while (isdigit(c)) &#123;x = x * 10 + c - '0';c = getchar();&#125; return x * f;&#125;inline void write(LL x)&#123; if (x &lt; 0) putchar('-'),x = -x; if (x &gt; 9) write(x/10); putchar(x%10+'0');&#125;inline void writeln(LL x)&#123; write(x),putchar('\n'); &#125;const int N = 100005,M = 500005;int Fr[M&lt;&lt;2],To[M&lt;&lt;2],Ne[M&lt;&lt;2],Dis[M&lt;&lt;2],He1[N],He2[N],_k;inline void add(int *He,int x,int y,int z)&#123; ++_k,Fr[_k] = x,To[_k] = y,Dis[_k] = z,Ne[_k] = He[x],He[x] = _k;&#125;int T,n,m,k,p[N];const LL INF = 1ll&lt;&lt;60;int f1[N],f2[N];LL dis1[N],dis2[N];LL ans;struct Node&#123; int x; LL d; Node (int xx = 0,LL dd = 0)&#123; x = xx,d = dd; &#125; inline bool operator &lt; (Node x) const&#123; return d &gt; x.d; &#125;&#125;t;priority_queue&lt;Node&gt;Heap;void Dij_1()&#123; int i; while (!Heap.empty()) Heap.pop(); for (i = 1; i &lt;= n; ++i) &#123; dis1[i] = INF; f1[i] = -1; &#125; for (i = 1; i &lt;= k; ++i) &#123; dis1[p[i]] = 0; f1[p[i]] = p[i]; Heap.push(Node(p[i],0)); &#125; int p,x; while (!Heap.empty())&#123; t = Heap.top(); Heap.pop(); if (t.d == dis1[t.x]) for (p = He1[t.x]; p ; p = Ne[p]) if (dis1[To[p]] &gt; dis1[t.x] + Dis[p])&#123; dis1[To[p]] = dis1[t.x] + Dis[p]; f1[To[p]] = f1[t.x]; Heap.push(Node(To[p],dis1[To[p]])); &#125; &#125; return;&#125;void Dij_2()&#123; int i; for (i = 1; i &lt;= n; ++i) &#123; dis2[i] = INF; f2[i] = -1; &#125; for (i = 1; i &lt;= k; ++i) &#123; dis2[p[i]] = 0; f2[p[i]] = p[i]; Heap.push(Node(p[i],0)); &#125; int p,x; while (!Heap.empty())&#123; t = Heap.top(); Heap.pop(); if (t.d == dis2[t.x]) for (p = He2[t.x]; p ; p = Ne[p]) if (dis2[To[p]] &gt; dis2[t.x] + Dis[p])&#123; dis2[To[p]] = dis2[t.x] + Dis[p]; f2[To[p]] = f2[t.x]; Heap.push(Node(To[p],dis2[To[p]])); &#125; &#125; return;&#125;int main(void)&#123; int i,u,v,w; T = read(); while (T--)&#123; _k = 0; memset(He1,0,sizeof(He1)); memset(He2,0,sizeof(He2)); n = read(),m = read(),k = read(); while (m--)&#123; u = read(); v = read(); w = read(); if (u^v) &#123; add(He1,u,v,w); add(He2,v,u,w); &#125; &#125; for (i = 1; i &lt;= k; ++i) p[i] = read(); Dij_1(); Dij_2(); ans = INF; for (i = 1; i &lt;= n; ++i) if (f1[i] ^ f2[i]) ans = min(ans,dis1[i] + dis2[i]); for (i = 1; i &lt;= _k; i += 2) if (f1[Fr[i]]^f2[To[i]]) ans = min(ans,dis1[Fr[i]] + dis2[To[i]] + Dis[i]); writeln(ans); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF938D题解]]></title>
    <url>%2F2019%2F10%2F08%2FCF938D%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$ZROI$杂题选讲…..刚开始的时候看见题目中要求的这个式子貌似不知道从何开始想….首先发现$2 \times d(i,j)$这个东西可以直接在存边的时候把边权变成两倍即可.但是剩下的那个加$a_j$貌似很难处理,每次暴力枚举么?显然不行.我们考虑一下,对于这个数据范围来说,显然只能跑一遍最短路,所以我们考虑怎么在一遍最短路的过程中求出每个点的答案.但是这样做的话,显然要把所有的$a_i$联系起来,怎么办呢?建虚点√我们新建一个虚点,然后由这个虚点向每个点$i$连一条边权为$a_i$的边.然后我们考虑一下原来的那个式子,发现这样的话原来的式子就变成了求$min(2\times d(i,j)+d(new,j))$.再考虑一下最短路的松弛操作,是不是发现了啥.我们直接从新建的虚点开始跑一遍最短路,然后对于每个点,$dis_i$就是答案了.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define int long long#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , date = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) date = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * date;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , date = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) date = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * date;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 1e6 + 10;int n , m , t;int head[N];struct Edge&#123; int to; int date; int next;&#125;e[N];int dis[N];bool vis[N];std :: priority_queue &lt; std :: pair &lt; int , int &gt; , std :: vector &lt; std :: pair &lt; int , int &gt; &gt; , std :: greater &lt; std :: pair &lt; int , int &gt; &gt; &gt;qu;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].date = z; e[t].next = head[x]; head[x] = t; return;&#125;signed main ( void ) &#123; read ( n , m ); for(int i=1;i&lt;=m;i++)&#123; int x,y,z; read(x,y,z); add(x,y,2*z); add(y,x,2*z); &#125; for(int i=1;i&lt;=n;i++)&#123; int x=_read(); add(n+1,i,x); &#125; memset(dis,0x3f,sizeof(dis)); dis[n+1]=0; qu.push(MP(0,n+1)); while ( !qu.empty () ) &#123; int j = qu.top().se; qu.pop (); if ( vis[j] ) continue; vis[j] = 1; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].date ) &#123; dis[k] = dis[j] + e[i].date; if ( !vis[k] ) qu.push ( MP ( dis[k] , k ) ); &#125; &#125; &#125; F ( i , 1 , n ) printf ( "%lld%c" , dis[i] , i == n ? '\n' : ' ' ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4479题解]]></title>
    <url>%2F2019%2F10%2F08%2FHDU4479%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$ZROI$杂题总结… 发现我们需要保证边权递增,但是似乎并没有什么方法.所以我们考虑将边权排个序,然后将边权从小到大开始考虑.这样之后,当我们先默认边权都互不相同时,我们每次以一条边去更新它两端的节点.如果能更新的话,显然在经过的节点上,一定是先经过边权较小的路径,再经过边权较大的路径.这样之后可以保证我们求的就一定是题目中要求的答案.然后发现其实边权并不是互不相同的,所以可以将边权一样的边分成一组,每次操作的过程中去用这组中的一坨边去更新. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; return s*w;&#125;const int N=1e4+10;const int M=1e5+10;const LL oo=0x3f;int n,m,t;LL dis[N];bool updated[N];struct Edge&#123; int from; int to; LL date;&#125;lis[M];int v[N];LL vdis[N];inline bool cmp(Edge x,Edge y)&#123; return x.date&lt;y.date;&#125;inline void work(int l,int r)&#123; int cnt=0; for(int i=l;i&lt;=r;i++)&#123; int ll=lis[i].from,rr=lis[i].to; if(updated[ll]&amp;&amp;dis[rr]&gt;lis[i].date+dis[ll])&#123; v[++cnt]=rr; vdis[cnt]=lis[i].date+dis[ll]; &#125; if(updated[rr]&amp;&amp;dis[ll]&gt;lis[i].date+dis[rr])&#123; v[++cnt]=ll; vdis[cnt]=lis[i].date+dis[rr]; &#125; &#125; for(int i=1;i&lt;=cnt;i++)&#123; dis[v[i]]=min(dis[v[i]],vdis[i]); updated[v[i]]=1; &#125; return;&#125;int main(void)&#123; int T=read(); while(T--)&#123; t=0; memset(updated,0,sizeof(updated)); n=read(),m=read(); for(int i=1;i&lt;=n;i++)dis[i]=oo; dis[1]=0; updated[1]=1; for(int i=1;i&lt;=m;i++)&#123; int x=read(),y=read(); LL z=read(); lis[++t].from=x; lis[t].to=y; lis[t].date=z; &#125; sort(lis+1,lis+1+t,cmp); lis[t+1].date=oo; for(int i=1;i&lt;=t;i++)&#123; int l=lis[i].from,r=lis[i].to; int j; for(j=i+1;j&lt;=t+1;j++) if(lis[j].date!=lis[i].date) break; work(i,j-1); i = j-1; &#125; if(dis[n]&gt;=oo) puts("No answer"); else printf("%lld\n",dis[n]); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI国庆七天乐D5]]></title>
    <url>%2F2019%2F10%2F07%2FZROI%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%90D5%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开要是CSP的D1这么考我估计我今年又凉了 添经过观察之后发现,在没有任意三线共点的情况下,答案只可能是$1,2,3$当中的一个.然后发现答案吧为$1$的情况只有在所有直线都相互平行或者$n$小于$2$的情况下会成立.然后考虑答案为$2$的情况,发现只有两组平行线集合,而且总线段的个数大于$2$的情况时,会发现答案为$2$.剩下的情况就是答案为$3$的情况. 罐装首先按照国王游戏的套路来推一波贪心的式子.然后发现得到了$p_i \times t_j &gt; p_j \times t_i$移项之后就有$\frac{p_i}{t_i}&gt;\frac{p_j}{t_j}$.然后我们按照这个东西排序,每次修改的时候都暴力做一遍,总复杂度为$O(m\times nlogn)$,就可以拿到$70$分的好成绩.然后我们又发现,每次修改时只会修改一个点,这样的话每次修改的时候都重新做一遍,感觉非常的浪费.我们考虑一下,我们修改一个点的时候,对其他点的贡献的影响.我们发现如果我们修改的那个位置,在排完序之后在原来序列中的位置为$pos$的话,我们如果把这个点先去掉的话,那么从$pos+1$到$n$的位置的数的贡献都会增加$t_{pos} \times \sum_{i=pos+1}^np_i$然后我们考虑一下修改的过程,等价于我们把一个位置删去,然后再在这个区间中插入我们要修改的数值,这个过程中要进行两次区间$sum$. 所以用权值线段树或者平衡树等数据结构维护即可. 三千米这道题是不可能补的,这辈子都不可能补的 总结:难度差不多$noip$的$d1$难度吧(甚至还要低)….但是我这个得分就….算了我太菜了/kk 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国庆七天乐D1]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E4%B9%90D1%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开w 幸福题目中要我们去求$\sum_{i=0}^n F_i$我们发现直接去由$f$数组去递推$F$数组的话时间复杂度是$O(n^2)$的,显然过不了,所以我们要推一波式子.由题意可知 F_i=\sum_{i=0}^n f_i\times f_{n-i}我们发现$f_i=f_{i-1}+f_{i-2}$,那么我们把$f_0$和$f_1$单独拿出来之后,上边的式子就可以拆成 F_i=\sum_{i=2}^n [(f_{i-1}+f_{i-2}) \times f_{n-i}]+f_0 \times f_n + f_1 \times f_{n-1}再根据万能的加法结合律,我们把上式中的几个$\sum$拆分魔改之后得到 F_i=\sum_{i=0}^{n-1} f_i \times f_{n-i-1} + \sum_{i=0}^{n-2} f_i \times f_{n-i-2} + f_0 \times f_n - f_1 \times f_n + f_0 \times f_n然后发现前边那两个$\sum$的式子分别是$F_{i-1}和F_{i-2}$,又因为$f_0=f_1=1$,带入这个式子之后我们可以得到: F_i=F_{i-1}+F_{i-2}+f_i然后就可以愉快的矩乘求出来了.但是因为我比较菜,只会用矩阵快速幂求第$i$项,但是题目中要求你求$\sum_{i=0}^nF_i$,我们怎么办呢?然后我们来考虑一下怎么用矩阵快速幂的过程中直接求出前缀和. 我们想一下矩阵乘法的过程,因为我们的目标矩阵是由原来的矩阵和我们构造的矩阵相乘得到的,如果我们中间构造一个$01$矩阵的话,矩阵乘法就可以看成是矩阵中的元素不断的相加,所以原理上在矩阵快速幂的过程中是可以直接求出我们要求的数列的前缀和的.我们以求斐波那契数列的前缀和为例子,因为我们知道,一个$n \times m$的矩阵与一个$m \times k$的矩阵相乘之后,我们得到的矩阵是一个$n \times k$的矩阵.所以我们考虑在我们原来构造的矩阵中加上一位,这样的话矩阵就变成了{$f_i,f_{i+1},\sum_{j=1}^{i+1}f_j$}.相应的,在我们构造的矩阵中,我们可以通过使$f_i与f_{i+1}$都被加入我们新加的一维来达到更新前缀和的目的.综上,我们可以在求$F_i$的矩阵中加一维表示前缀和,然后直接矩阵快速幂即可.时间复杂度为$O(logn)$,可以通过本题 树链剖分先考虑暴力怎么写.我们发现如果根节点被确定了的话,我们提前用树上差分统计出每个点被经过了多少次之后,可以直接贪心的去找答案.所以这样的话我们必须要枚举根节点.这样的话复杂度也是显然过不了.我们先钦定一个节点作为根节点,然后我们考虑每个节点作为根节点的情况.显然发现某个点的在原树上的儿子节点是不受影响的,所以我们可以预先进行一次$dfs$来确定我们发现,如果某个节点$i$与我们当前的这个即将要成为根的节点不相邻的话,那么这个点$i$是很显然不会受到影响的(该怎么走还得怎么走)我们考虑从上往下的顺序进行$DFS$，然后每次求出当前节点作为根时的最小代价。显然，与当前节点不相邻的边不受这个节点的影响，因此我们可以直接求出.又因为孩子方向的在第一次$DFS$中预处理了，而父亲方向的在刚刚$DFS$的过程中求出。然后求出与当前节点相邻的边中，最大的以及次大的，根据$DFS$的孩子选择是去掉最大的还是次大的即可。 小E和小F strikes again这道题是不可能补的,这辈子都不可能补的 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #588 (Div. 2)题解]]></title>
    <url>%2F2019%2F09%2F27%2FCF588%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[lyt我对不起你啊/ll Dawid and Bags of Candies其实我们按照大小排序了之后,我们发现可能的答案只有第$1,4$组成或者第$4$个单独组成,判断一下即可.注意精度,不然直接除$2$的时候可能会被卡. Ania and Minimizing发现如果把高位变小了之后,那么答案一定会变得更优.所以我们直接从高位向低位贪心即可.注意判断$k$为$0$的情况. Anadi and Domino$emmmmm….$看题面就非常高大上然后我们认真读了读题发现真的很高大上.看一眼数据范围,$n&lt;=7$,所以我们考虑一下枚举与每个点相连的边的颜色.然后我们直接暴力$check$即可.对不起数据范围小真的可以为所欲为1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;int G[10][10];int col[8],ans;bool used[7],uc[7][7];void Prep()&#123; memset(uc,false,sizeof(uc)); return;&#125;inline void check()&#123; Prep(); int tmp=0; for(int i=1;i&lt;=n;i++)&#123; if(col[i]==0) continue; for(int j=i+1;j&lt;=n;j++)&#123; if(!G[i][j]||!col[j]) continue; if(!uc[col[i]][col[j]])&#123; uc[col[i]][col[j]]=1; uc[col[j]][col[i]]=1; tmp++; &#125; &#125; &#125; ans=max(ans,tmp);// if(tmp==21)&#123;// for(int i=1;i&lt;=n;i++)// cout&lt;&lt;col[i]&lt;&lt;" ";// exit(0); // &#125; return;&#125;void dfs(int x)&#123; if(x==n+1)&#123; check(); return; &#125; for(int i=0;i&lt;=6;i++)&#123; col[x]=i; dfs(x+1); &#125; return;&#125;int main ( void ) &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; G[x][y]=1; G[y][x]=1; &#125; memset(col,-1,sizeof(col)); dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;// Main Code Marcin and Training Camp我们考虑到,如果一个人$i$和另一个人$j$能看顺眼的话,只有$j$是$i$的子集才可以.然后如果在某个分组里,$j$已经是某个$i$人的子集了,那么$j$一定是可以被选出的.所以我们的任务就变成了找到所有的$a_k$只出现过一次或者不是其他出现过两次或多次的$a_i$的子集合的$k$.然后从$sum$中将这些不合法的状态删去即可. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习笔记]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数论果然博大精深,但是我啥都没听懂 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCP-114514]]></title>
    <url>%2F2019%2F09%2F23%2FSCP1%2F</url>
    <content type="text"><![CDATA[qwq SCP-114514 研究社 等级: Keter 特殊收容措施: 目前SCP-114514无法被收容,目前基金会的目的是使SCP-114514保持不再发生变化. 项目描述: 已知SCP-114514曾经的名称有信息学,OI,国际象棋,围棋,五子棋,羽毛球,篮球,OSU,植物大战僵尸,外卖K歌研究社.已知项目会在随机的时间进行名称上的变化.目前已经证实,在每次项目的名称发生改变时,项目内的人员(称之为$SCP-114514-1919810$)的兴趣爱好会随着研究社的名称发生变化. 经过研究发现,SCP-114514内的人员爱好需要的物件似乎并不需要从外界获取,会有一个被称为$SCP-114514-1$的被称为$Z$主任的人形实体供给,而供给的物品似乎是从内部自然产生的. 在每次项目的名称发生改变时,会强制将项目周边距离不超过$10m$的人员强制转化为$SCP-114514-1919810$,已知这一影响不可逆.而且在普通人员被强制转化后,会在[数据删除]的时间之内丧失对文化课学习的兴趣. 常人暴露在SCP-114514面前是致命的,所以对于SCP-114514的任何接触需要3名及以上四级权限者的允许,且实验者在实验后将被强制隔离$3$天,如果在隔离时间之内实验者表现了明显的兴趣爱好变化,那么实验者将会被处决. 对于SCP-114514的进一步研究报告为致命媒介模因,需要得到O5议会的批准之后访问. 您好,监督者,已取消对机动特遣队的派遣指令.]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>SCP乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #587题解]]></title>
    <url>%2F2019%2F09%2F22%2FCodeforcesRound-587%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[LYT我对不起你啊/ll Prefixes经过观察私信找规律之后发现,对于每个偶数的前缀$i$,如果$i&gt;2$且$i$这个前缀满足条件,那么$i/2$也一定会满足条件.所以我们要满足的就是对于每个最小的间隔为$2$的区间,使他们当中有一个$a$和一个$b$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 2e5 + 10; int n , ans;char ss[N]; int main() &#123; read ( n ); scanf ( "%s" , ss + 1 ); int s1 = 0 , s2 = 0; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( ss[i] == 'a' ) s1++; else s2++; if ( i % 2 == 0 ) &#123; if ( s1 == s2 ) continue; ans++; if ( s1 &gt; s2 ) ss[i] = 'b'; else ss[i] = 'a'; s1 = 0; s2 = 0; &#125; &#125; writeln ( ans ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%c" , ss[i] ); return 0; &#125; Shooting通过观察样例可知,从大到小排序即可qwq… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 1005; int n;struct Node &#123; int val; int pos;&#125;ls[N]; ll ans; inline bool cmp ( Node x , Node y ) &#123; return x.val &gt; y.val;&#125; int main() &#123; read ( n ); F ( i , 1 , n ) &#123; ls[i].val = _read (); ls[i].pos = i; &#125; std :: sort ( ls + 1 , ls + 1 + n , cmp ); F ( i , 1 , n ) ans += ls[i].val * ( i - 1 ) + 1; writeln ( ans ); F ( i , 1 , n ) printf ( "%d " , ls[i].pos ); return 0; &#125; White Sheet发现如果这个白色矩形的四条边都被覆盖了的话,那么中间一定也被覆盖了.然后暴力枚举判断即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ struct Point&#123; int x; int y;&#125;p[7];int main ( void )&#123; for(int i=1;i&lt;=6;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); if(p[3].x&lt;=p[1].x&amp;&amp;p[3].y&lt;=p[1].y&amp;&amp;p[4].x&gt;=p[2].x&amp;&amp;p[4].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[5].x&lt;=p[1].x&amp;&amp;p[5].y&lt;=p[1].y&amp;&amp;p[6].x&gt;=p[2].x&amp;&amp;p[6].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[3].x&lt;=p[1].x&amp;&amp;p[4].x&gt;=p[2].x&amp;&amp;p[5].x&lt;=p[1].x&amp;&amp;p[6].x&gt;=p[2].x)&#123; if(p[3].y&lt;=p[1].y&amp;&amp;p[4].y&gt;=p[5].y&amp;&amp;p[6].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[5].y&lt;=p[1].y&amp;&amp;p[6].y&gt;=p[3].y&amp;&amp;p[4].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; &#125; if(p[3].y&lt;=p[1].y&amp;&amp;p[4].y&gt;=p[2].y&amp;&amp;p[5].y&lt;=p[1].y&amp;&amp;p[6].y&gt;=p[2].y)&#123; if(p[3].x&lt;=p[1].x&amp;&amp;p[4].x&gt;=p[5].x&amp;&amp;p[6].x&gt;=p[2].x)&#123; printf("NO\n"); return 0; &#125; if(p[5].x&lt;=p[1].x&amp;&amp;p[6].x&gt;=p[3].x&amp;&amp;p[4].x&gt;=p[2].x)&#123; printf("NO\n"); return 0; &#125; &#125; printf("YES\n"); return 0;&#125; Swords发现求个$gcd$就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 2e5 + 10; int n , maxs;int num[N];ll ans , sum; int main() &#123; read ( n ); F ( i , 1 , n ) &#123; num[i] = _read (); maxs = max ( maxs , num[i] ); &#125; F ( i , 1 , n ) &#123; int res = ( maxs - num[i] ); ans = std :: __gcd ( ans , res * 1ll ); &#125; if ( ans == 0 ) &#123; puts ( "0 0" ); return 0; &#125; else &#123; F ( i , 1 , n ) sum += ( maxs - num[i] ) / ans; printf ( "%I64d %I64d\n" , sum , ans ); &#125; return 0; &#125; Numerical Sequence (easy version)发现$k$只有$10^9$的范围,所以就暴力跳就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std; #define LL long long#define N 40010 LL sum[N],T; int judge(int x) &#123; int count = (int)log10((double)x) + 1; return count;&#125;int fun(int x) &#123; int sum = pow(10,x); return sum;&#125;void solve() &#123; int sumn = 0; memset(sum, 0,sizeof(sum)); for(int i = 1 ; i &lt; 40005 ; ++i) &#123; sumn += judge(i); sum[i] = sum[i - 1] +sumn; &#125;&#125;void answer(int x) &#123; int j,ans,summ,i = 1; while(sum[i] &lt; x) i++; ans = x - sum[i -1]; summ = 0; for(j = 1 ; j &lt;= i ; ++j) &#123; summ += judge(j); if(summ &gt;= ans) break; &#125; if(summ == ans) printf("%d\n", j %10); if(summ &gt; ans) printf("%d\n", (j / fun(summ -ans)) % 10);&#125; int main() &#123; scanf("%lld",&amp;T); solve(); while(T--) &#123; int pos; scanf("%d",&amp;pos); answer(pos); &#125; //system("pause"); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普转提七连测D3]]></title>
    <url>%2F2019%2F09%2F22%2FP%E8%BD%ACTD3%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 序列我们考虑化简式子: (x^2+y)^2\equiv(x^2-y)^2+1\pmod{p}两边的平方式展开之后再合并同类项之后可有 4x^2y\equiv1\pmod{p}我们发现,如果我们把$4x^2$看作一个整体,那么$y$就是$4x^2$在膜$p$意义下的逆元.所以我们现在的任务变成了找对于每个$num_i$,$4num_i$的逆元有多少个又因为题面中说了数字互不相等,所以我们完全可以使用$unordered$_$map$统计.注意去重即可,时间复杂度$O(nlogINTMAX)$ 汽水乍一看并莫得啥思路.然后我们想一下,如果我们把每个糖浆的浓度都减少$n$的话,那么我们的任务就变成了怎么凑出$0$浓度的任务.然后我们建立一个图论模型:我们设$dis_i$表示凑到$i+n$这个浓度时最少用的糖浆是多少,显然可以使用$bfs$求最短路. 树我们发现,最优解一定是原来的某些连通块相互连接形成的,然后就没了qwq DAG首先推广一个结论:如果最长路是$x$,那么一定存在一个$x+1$的染色方案.我们对于每一条边$(i-&gt;j)$,我们规定只能从颜色小的点走向颜色大的点.然后考虑这样的话我们就划分成了一个分层图.然后又因为我们要让最短路最长,说白了就是要让层数最少.而我们又发现同层的点之间没有边,等价于一个独立集.所以我们的任务就转化成了把这张图划分成最少的独立集个数,使得他们的并集为这一张图.又因为我们发现数据范围很小,只有$17$,所以我们可以考虑状压$DP$来解决这个问题.我们设$f_i$表示我们目前选择的点的总集为$i$的时候的最小的独立集个数.我们预处理出从$0$到$(1&lt;&lt;n)-1$中的每个状态是否为独立集,然后我们在每次枚举状态$i$的时候,显然$i$这个状态只能从它的某个为独立集的子集转移过来.转移很显然,$f_i=min(f_j+1)$$(j$为$i$的子集且$j$这个集合为独立集). 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高失联测D4]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E8%81%94%E6%B5%8BD4%2F</url>
    <content type="text"><![CDATA[罗小黑真尼玛好看 罗其实暴力有$60$分,只需要判断一下上下是否相等即可.对于其他的情况,我们发现如果我们只有一个*的话,就可以匹配所有的字符串,所以*的个数最多只有一个.然后我们再考虑一下万能字符串(能匹配所有长度有下界的字符串的字符串)长什么样子.显然是*???????????????然后我们考虑一下,我们对于某两个字符串xxxx*xxxxx*xxx和xxxx*xxxxxx.我们发现答案中的那个*一定会匹配原来两个串中所有的*.那么我们最终构造出来的那个串的长度一定就是原来两个字符串中所有非*的最小值加一. 然后我们考虑了之前的条件之后,发现我们可以枚举我们的这个*之前的长度$L_1$.对于*之后的长度我们可以算出来.然后对于原来的两个字符串之前的$L_1$位,我们可以像白给的$60$分那样做匹配来这样的话我们最后把所有答案拿出来,比较一下字典序和$?$的个数,就能在$O(n)$的复杂度内解决这道题.但是这样的复杂度对于这道题来说显然不够优秀,所以我们考虑怎么优化这个算法.我们发现两个答案不一样的地方一定是*,所以我们可以分别从左向右和从右向左递推出以$i$为*的位置时,左边$?$的个数和右边$?$的个数.这样的话我们就可以用$O(n)$的时间复杂度构造出所有断点$i$的左边和右边的符号是不是问号以及问号的个数,而通过这些东西就可以构造出答案.然后我们在所有的答案中,贪心的先找出一个$?$的个数最小的串,然后再在这些串里找出$L_1$最小的串(因为$L_1$小的话说明第一个出现的*位置靠前,字典序小).然后根据这个构造最后的串就好了. 小首先有一个结论:一个不超过$T$的数有$loglogT$个质因子.这样的话,如果我们每次枚举区间,然后$check$答案的话,就得到了一个$O(n^3loglogT)$的方法.发现这个方法还是太$naive$,我们来尝试优化一下,我们发现,如果我们枚举区间,然后在区间右移的时候维护现在出/进区间的元素的话,我们可以把枚举+$check$的复杂度从$O(n^2)$降低到$O(n)$这样的话就是$O(n^2loglogT)$了,可以通过$60$分. 考虑每个质因子在每个区间中的贡献,假设我们现在枚举的质因子是$p$,那么对于位置$i$上的数字$num_i$如果存在质因子$p$,那么我们记$pre_{i,p}=1$,否则的话记录$pre_{i,p}=-1$.这样枚举区间的时候,我们可以直接从这个区间的区间和是否大于等于$0$来判断.这样之后复杂度还是$O(n^2loglogT)$,还需要进一步优化. 我们还是先枚举每个质因子,然后我们令$p_1,p_2,……,p_k$为这个质因子第$1,2,3….k$次出现的位置.在我们把$p$数组排序之后,我们发现,如果我们能找到一个$p_j-p_i+1&lt;=2\times(j-i+1){j&gt;i}$,那么我们就找到了一组$2\times(j-i+1)$的解.我们把这个式子移项之后有$p_j-2\times j&lt;=p_i-2\times i+1$.显然,我们可以按照$p_i-2\times i$来排序.最后我们枚举$j$之后,由于我们的排序方式,我们可以发现$p_j-2\times j&lt;=p_i-2\times i$一定是会被满足的,所以我们只需要找一个$max(j-i+1)$即可.然后我们发现这个东西显然是可以二分或者双指针直接找的,总复杂度为$O(nloglogTlogn)$. 黑暂时先黑一会~ 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普及五连测D2]]></title>
    <url>%2F2019%2F09%2F21%2FPJ%E4%BA%94%E8%BF%9E%E6%B5%8BD2%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 安排座位首先我们可以算出对于每一排,我们可以排出来多少座位,以及一共需要多少排才能把座位排完.然后我们考虑插入走廊的事情要使得尽量多的位置在走廊边上, 于是在 n 列中插入走廊的策略是显然的, 我们只要以两列为单位, 在其中插入即可．有一些边界情况需要考虑清楚． 加法问题我们考虑如果满足式子$a \times 10^x+b \times 10^y$=$c \times 10^z$,那么一定有$a,b,c$这三个数在乘方之后的位数最少是$len_c&gt;=len_{a,b}$首先我们将$c$的末位数补齐,然后我们发现,$c$一定是由$a,b$相加进位之后得到的. 我们固定$a,b$为$len_c$位和$len_{c-1}$位,然后我们枚举$0$的个数之后判断. 这样的话貌似要写高精度,其实不用,我们知道$hash$就是以一个$base$进制来表示数的方式,如果我们的$hash$中的$base$设为$10$,那么一个原本的$10$进制数在$hash$之后,可以直接用哈希值加减来判断. 有趣的数经过我们快乐的打表之后发现,对于$k$进制下的末尾有奇数个$0$的数,有$m=a \times k^p(p\equiv1\pmod{2},!a\equiv0\pmod{k})$.有了这个结论,我们就可以快速的统计出在$[1,n]$的区间中,符合条件的数字的个数.又因为两个数的相对大小关系不会因为进制而改变,所以我们可以二分区间上界来找到我们要找的第$n$个数. 与非门树我们发现,对于某一个节点,无论是否发生故障,那么它的状态一定只有$0$和$1$两种.所以我们可以设$f_{i,0/1,0/1}$,表示现在是第$i$个点,理论状态为$0/1$,实际状态为$0/1$时的方案数. 乍一看貌似不怎么可转移,我们想,对于理论状态为$0$,实际状态也为$0$的状态一定是只能从子树为全$0$和全$1$的状态转移而来.然后对于理论状态和实际状态相异或为$1$的状态,但是我们可以通过输入为$0$或者$1$的状态减去输入全$0$的状态快速得到．然后对于$f_{i,1,1}$的这种状态,我们可以用所有的总状态减去其他的所有状态达到. 总结:比较基础的树形$DP$+简单容斥即可.(气稽败坏.png) 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 73题解]]></title>
    <url>%2F2019%2F09%2F20%2FCF%E9%A2%98%E8%A7%A3%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[qwq A.2048 Game我们发现,我们可以忽略掉$2048$以上的数,剩下的数开桶统计然后贪心即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 105;int n; ll num[N];int used[2050];int main ( void ) &#123; int T = _read (); while ( T-- ) &#123; memset ( used , 0 , sizeof ( used ) ); n = _read (); F ( i , 1 , n ) &#123; num[i] = _read (); if ( num[i] &lt;= 2048 ) used[num[i]]++; &#125; if ( used[2048] ) &#123; puts ( "YES" ); continue; &#125; for ( int i = 1 ; i &lt;= 1024 ; i *= 2 ) used[i * 2] += ( used[i] / 2 ); if ( used[2048] ) puts ( "YES" ); else puts ( "NO" ); &#125; return 0;&#125; B.Knights我们贪心的考虑一下,如果我们现在这个位置的骑士,在它能移动的八个方向上,都会碰到其他的骑士,那么这个位置对答案的贡献一定是最优的. 结合样例,我们可以发现这样一种构造方法,我们从点$(1,1)$开始进行一次$bfs$,然后按照骑士的移动方法,每次更新一层,然后把这一层的骑士染色成和现在的骑士颜色不一样的颜色. 对于剩下的,那么可以证明没有任何点能跳到这个点,所以随便什么颜色都可以. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/int n;char mp[105][105];const int dx[] = &#123; 0 , 1 , 1 , -1 , -1 , 2 , 2 , -2 , - 2 &#125;;const int dy[] = &#123; 0 , 2 , -2 , 2 , -2 , 1 , -1 , 1 , -1 &#125;;void dfs ( int x , int y , char col ) &#123; mp[x][y] = col; for ( int i = 1 ; i &lt;= 8 ; i++ ) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if ( xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= n &amp;&amp; mp[xx][yy] != 'W' &amp;&amp; mp[xx][yy] != 'B' ) dfs ( xx , yy , col == 'W' ? 'B' : 'W' ); &#125; return;&#125;int main ( void ) &#123; n = _read (); dfs ( 1 , 1 , 'W' ); bool flag = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= n ; j++ ) &#123; if ( mp[i][j] == 'W' || mp[i][j] == 'B' ) printf ("%c",mp[i][j]); else &#123; printf ("%c" , flag?'B':'W'); flag ^= 1; &#125; &#125; puts(""); &#125; return 0;&#125;// Main Code C.Perfect Team一个直观的感觉就是你从$c,m$中取一个$Min$,然后我们会发现可能人数凑不够$Min*3$,所以我们判断一下$min(Min,sum/3)$就是答案了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/int n;int c , m , x;int main ( void ) &#123; int T = _read (); while ( T-- ) &#123; read ( c , m , x ); int mins = min ( c , m ); int sums = c + m + x; printf ( "%d\n" , min ( mins , sums / 3 ) ); &#125; return 0;&#125;// Main Code D.Make The Fence Great Again毒瘤出题人一个DP数据范围开3e5 看到$3e5$的数据范围,第一反应就是贪心,但是发现貌似不怎么可做?然后开始考虑$DP$,发现如果$i$这个点被升高了的话,貌似对后边的点是有影响的,有后效性,怎么办?我们经过观察可知,如果一个点要升高,那么它最多升高两次,所以我们可以设$f_{i,j}$表示现在是第$i$个位置,其中$i$这个位置升高了$j$次. 转移的话很显然,我们枚举一个最小的$f_{i-1,k}$并且要保证$fence_{i-1}.high+k$不等于$fence_i.high+j$然后转移就好了. 时间复杂度的话是$O(n*16)$硬核O(nlogn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define int long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 3e5 + 10;int n , idx;struct Node &#123; int hi; int vi;&#125;fence[N];int f[N][5];signed main ( void ) &#123; int T = _read (); while ( T-- ) &#123; n = _read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; read ( fence[i].hi , fence[i].vi ); for ( int j = 0 ; j &lt;= 4 ; j++ ) f[i][j] = 1e17; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 0 ; j &lt;= 4 ; j++ ) &#123; for ( int k = 0 ; k &lt;= 4 ; k++ ) &#123; if ( fence[i].hi + j == fence[i - 1].hi + k ) continue; f[i][j] = min ( f[i][j] , f[i - 1][k] ); &#125; if ( f[i][j] == 1e17 ) continue; f[i][j] += 1ll * j * fence[i].vi; &#125; &#125; int ans = 1e17; for ( int i = 0 ; i &lt;= 4 ; i++ ) ans = min ( ans , f[n][i] ); writeln ( ans ); &#125; return 0;&#125;// Main Code 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO09FEB]改造路Revamping Trails题解]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%94%B9%E9%80%A0%E8%B7%AF%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[复习了一波分层图…. 可以发现这道题就是分层图裸题.我们可以设$dis_{time,i}$表示现在已经用了$time$次免费机会,到达了$i$这个点的时候的最短路径.那么我们在进行堆优化$Dijkstra$时($SPFA$跑分层图一般会死的很惨),我们对于每次转移时,判断一下是否使用一次免费机会即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define K 25#define N 10005#define M 4200005#define F(i,a,b) for(int i=a;i&lt;=b;i++)#define G(i,a,b) for(int i=head[a];i;i=b[i].next)using namespace std;int n,m,k,t,start,end;struct Edge&#123; int to; int data; int next;&#125;e[M];struct Que&#123; int time,cur; Que(int a,int b):time(a),cur(b)&#123;&#125;&#125;;int head[N],vis[K][N];bool inque[K][N];int ans=2147483647;struct cmp &#123; bool operator () ( Que x , Que y ) &#123; return vis[x.time][x.cur] &gt; vis[y.time][y.cur]; &#125;&#125;;priority_queue &lt; Que , vector &lt; Que &gt; , cmp &gt; qu;void add (int x,int y,int z)&#123; e[++t].to=y; e[t].data=z; e[t].next=head[x]; head[x]=t; return;&#125;inline void spfa (int x)&#123; memset(vis,0x3f3f3f3f,sizeof(vis)); vis[0][x]=0; inque[0][x]=1; qu.push(Que(0,1)); while (!qu.empty())&#123; Que j=qu.top(); qu.pop(); inque[j.time][j.cur]=0; G(i,j.cur,e)&#123; int k=e[i].to; if (vis[j.time][k]&gt;vis[j.time][j.cur]+e[i].data)&#123; vis[j.time][k]=vis[j.time][j.cur]+e[i].data; if (!inque[j.time][k])&#123; inque[j.time][k]=1; qu.push(Que(j.time,k)); &#125; &#125; &#125; if (j.time&lt;k) G(i,j.cur,e)&#123; int k=e[i].to; if (vis[j.time+1][k]&gt;vis[j.time][j.cur])&#123; vis[j.time+1][k]=vis[j.time][j.cur]; if (!inque[j.time+1][k])&#123; inque[j.time+1][k]=1; qu.push(Que(j.time+1,k)); &#125; &#125; &#125; &#125; F(i,0,k) ans=min(ans,vis[i][n]); return;&#125;int main()&#123; scanf ("%d%d%d",&amp;n,&amp;m,&amp;k); F(i,1,m)&#123; int x,y,z; scanf ("%d%d%d",&amp;x,&amp;y,&amp;z); add (x,y,z); add (y,x,z); &#125; spfa(1); printf ("%d\n",ans); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>DP</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高失恋测D3]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E6%81%8B%E6%B5%8BD3%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 最长01子序列我们首先考虑暴力,我们发现,一个串的形式,是由它中间的$0$的个数所决定的,而中间$0$的个数是由前导$0$的个数所决定的.所以我们可以枚举前导$0$的个数,从而贪心匹配即可,这样复杂度为$O(n^2)$,能拿到60分. 我们接着来考虑怎么优化这个过程,我们发现,我们匹配的过程,就是经过一段$0$之后,找到下一个$1$的位置,而随着位置从左向右,前缀的$0$的个数是单调递增的,所以我们可以考虑二分优化.我们对于现在的位置$i$(初始情况下为$0$,且假设我们现在枚举的前导$0$的个数为$x$)我们要找的就是满足$fro[pos]-fro[i]&gt;=x$的最左边的位置,而这个位置显然可以二分处理.我们计算一下复杂度,发现这种方法的复杂度为$\sum_{i=1}^n\frac{n}{i}$=$O(nIn n)$.便可以通过此题. 路径长度先考虑暴力,我们可以把到达每一个点的所有值用背包记录下来,这样有$40$分. 然后我们考虑这个过程,我们发现,如果我们考虑三个距离$x,y,z$的话.如果这三个距离,满足$z&lt;=1.1x&lt;=1.1y&lt;=1.1z$的话,那么$y$这个距离完全可以不要.原因的话,我们发现,我们要求的是到一个点的距离满足在区间$[dis,1.1dis]$之间的路径,那么如果这里的$y$满足$dis&lt;=y&lt;=1.1dis$的话,那么$x$和$z$当中一定会有一个满足这个条件的.所以我们可以根据这个条件,不记录所有的距离.又因为$1.1^{420}$大概等于$10^{17}$,所以我们只需记录$420$个左右的距离.同时,在合并两个集合时,如果我们用归并排序时,可以做到$O(A+B)=O(logM)$. 动态矩阵最短路我们先考虑一维的情况:对于每一次的操作,我们可以把这一列看成一个点,然后我们维护一下这个点最后一次被清空的时间点.然后对于每次询问,我们只需要查询一下两个点中间的最前一次被清空的时间到现在是不是小于$v$即可. 发现这种做法貌似很容易推广到二维的情况,对于行和列,我们分别建线段树.然后我们判断一下两个点之间的各种连接情况然后判断答案即可.貌似需要写线段树上二分. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces round585题解]]></title>
    <url>%2F2019%2F09%2F15%2Fround585%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[A.傻逼题,暴力枚举即可(我也就只会傻逼题了) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)#define G(i,a,b,c) for(rint a=head[b];a;a=c[a].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 10005;int n , a1 , a2 , k1 , k2 , idx;int num[N];inline bool cmp1 ( int x , int y ) &#123; return x &gt; y;&#125;inline bool cmp2 ( int x , int y ) &#123; return x &lt; y;&#125;int main ( void ) &#123; read ( a1 , a2 , k1 , k2 , n ); for ( int i = 1 ; i &lt;= a1 ; i++ ) num[++idx] = k1; for ( int i = 1 ; i &lt;= a2 ; i++ ) num[++idx] = k2; std :: sort ( num + 1 , num + 1 + idx , cmp1 ); int ans = 0; int tmp = n; for ( int i = 1 ; i &lt;= idx ; i++ ) if ( tmp &lt; num[i] ) &#123; tmp = 0; break; &#125; else tmp -= num[i] - 1; if ( tmp == 0 ) printf ( "%d " , ans ); else printf ( "%d " , tmp ); std :: sort ( num + 1 , num + 1 + idx , cmp2 ); ans = 0 , tmp = n; for ( int i = 1 ; i &lt;= idx ; i++ ) if ( tmp &lt; num[i] ) break; else &#123; ans ++; tmp -= num[i]; &#125; printf ( "%d\n" , ans ); return 0;&#125;// Main Code B.分从后往前现在的数的正负性讨论即可,负负得正. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 4e5 + 10;int n;ll num[N] , s[N];ll tai,fro;ll odd,uodd;int main ( void ) &#123; read ( n ); F ( i , 1 , n ) &#123; num[i] = _read (); s[i] = s[i - 1] ^ ( num[i] &lt; 0 ); if ( s[i] == 1 ) &#123; tai += odd; fro += uodd; odd++; fro++; &#125; else &#123; tai += uodd; fro += odd; tai++; uodd++; &#125; &#125; std :: cout &lt;&lt; fro &lt;&lt; " " &lt;&lt; tai &lt;&lt; std :: endl; return 0;&#125; C.发现只有$A$和$B$,两种字符,很容易发现规律. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/char s[3][200005];int n , sum;int can1,can2,bc;int cnt1[200005],cnt2[200005];int main()&#123; read ( n ); scanf ( "%s%s" , s[1] , s[2] ); for(int i=0;i&lt;n;i++)&#123; if(s[1][i]!=s[2][i])&#123; if(s[1][i]=='a')&#123; can1++; cnt1[can1]=i+1; &#125; else&#123; can2++; cnt2[can2]=i+1; &#125; &#125; &#125; if(n%2==1)&#123; puts ( "-1" ); return 0; &#125; if(can1%2==1)&#123; sum+=2; sum+=(n-2)/2; writeln ( sum ); printf ( "%d %d\n" , cnt1[1] , cnt1[1] ); printf ( "%d %d\n" , cnt1[1] , cnt2[1] ); for(int i=2;i&lt;=can1;i+=2) printf ( "%d %d\n" , cnt1[i] , cnt1[i + 1] ); for(int i=2;i&lt;=can2;i+=2) printf ( "%d %d\n" , cnt2[i] , cnt2[i + 1] ); return 0; &#125; sum=(can1+can2)/2; writeln ( sum ); for(int i=1;i&lt;=can1;i+=2) printf ( "%d %d\n" , cnt1[i] , cnt1[i + 1] ); for(int i=1;i&lt;=can2;i+=2) printf ( "%d %d\n" , cnt2[i] , cnt2[i + 1] ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普转提七连测D2]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%99%AE%E4%B8%93%E6%8F%90D2%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 T1.首先$naive$的做法就是枚举一下从$L$到$R$的数然后判断是否合法,复杂度为$O((R-L)*log_{10}n$) 然后正解是暴力暴力出奇迹 我们可以发现这种数是十分稀疏的,所以我们可以考虑枚举每一个特殊的数字,然后判断每一个数字是否在区间$[L,R]$之内.时间复杂度为$O(17^2*9^2)$. T2.我们首先记录一下每个字符的前缀和$A_i,B_i,C_i$我们考虑怎么判断一个区间合法:如果在一个区间$[l,r]$当中,$A_{l-1}-B_{l-1}==A_{r}-B{r}$,同时$B_{l-1}-C_{l-1}==B_r-C_r$.所以我们考虑一下,如果对于每个$i$,我们把$A_i-B_i$和$B_i-C_i$看成两个二元组,那么我们的任务就是去寻找有几对二元组相同. T3.先考虑一下能组成$11$的倍数的数的特征:奇数位和偶数位的和的差的绝对值对$11$取模的结果为$0$.所以我们枚举一下每个数字分到奇数位还是偶数位即可,这样是$O(2^n)$的,可以通过$60$分的数据. 我们考虑一下,如果分到了奇数位或者偶数位,那么他的位置和被放的先后顺序是无关紧要的,换句话说,也就是无后效性.所以我们考虑用背包实现这个过程,我们可以设$f_{i,j,k}$表示前$i$个数中,选了$j$个放在奇数位,能不能使和变成$k$. 然后我们就可以统计答案了. T4.我们通过思考发现,如果现在面前只有$1$个或者$2$个怪物的话,如果我们放一次重击和放一次$AOE$,那么我们的收益是相同的(在现在生命值最小的怪物不能被一次打死的情况下).所以我们要按照生命值从小到大排序. 我们发现,如果现在怪物的数量$num &gt;= 3$,那么我们放一次群攻的话,收益一定比放一次重击要大.所以我们就可以直接贪心了. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据生成]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[图和树的数据生成器 图有向图和无向图同样适用的数据生成器,可生成随机图 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;using namespace std;int n,m,s,T;inline int random() &#123; static int seed = s; return seed = (int)(seed*48271ll%2147483647);&#125;set&lt;int&gt;to[100005];//去重int main() &#123; srand ( time ( NULL ) ) ; cin &gt;&gt; T; cout &lt;&lt; T &lt;&lt; endl; while(T--) &#123; s = rand(); n = 96; m = 102; printf("%d %d \n",n,m); for(int i = 1 ; i &lt;= m ; i++) &#123; int u = random() % n + 1; int v = random() % n + 1; while(to[u].find(v) != to[u].end() || u == v) &#123; u = random() % n + 1; v = random() % n + 1; &#125; printf("%d %d\n",u,v); to[u].insert(v); &#125; printf("\n"); &#125; return 0;&#125; 树保证数据为一棵随机树 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;using namespace std;int a[10005],e[10005][2];int n = 1000;bool flag[10005];int main() &#123; freopen("testdata.in","w",stdout); printf("%d\n",n); for(int i = 1 ; i &lt;= n ; i++) &#123; a[i] = rand() % n + 1; while(flag[a[i]]) a[i] = rand() % n + 1; flag[a[i]] = 1; &#125; for(int i = 2 ; i &lt;= n ; i++) &#123; e[i-1][0] = a[i]; e[i-1][1] = a[rand() % (i - 1) + 1]; &#125; memset(flag,0,sizeof(flag)); for(int i = 1 ; i &lt; n ; i++) &#123; int x = rand() % (n - 1) + 1; while(flag[x]) x = rand() % (n - 1) + 1; flag[x] = 1; int f = rand() % 2; if(f) printf("%d %d\n",e[x][0],e[x][1]); else printf("%d %d\n",e[x][1],e[x][0]); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>知识水平</category>
      </categories>
      <tags>
        <tag>数据制造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普及五联测D1]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8BD1%2F</url>
    <content type="text"><![CDATA[版权原因,题面不公开 T1.根据某些大佬说可以直接把所有的数加起来就是答案,但是因为我这个人比较弱所以就只会$DP$了我们设$f[i][0/1]$表示前$i$个数字中,在从第$i-1$次到第$i$次的转移时用了加/异或的最大值,转移显然. T2.我们可以发现每个数字,从他现在的位置开始,到他下一次出现的地方为止就是这个数字有贡献的区间,然后我们按照区间个数统计答案就好了 T3:我们发现如果按照题解从小到大排序之后,那么能被放下的一定是$[1,(n+1)/2]$这个区间里的数.然后我们可以双指针扫一下,遇到能装的就装一定更优. T4我们发现,一个性质,如果一条链的两个顶点的$LCA$在第三条链上,那么这两条链一定会有交点.所以我们可以用树上差分统计一下每个点被经过了多少次,然后我们考虑一下去重.我们发现,如果一个点被多条链的$LCA$同时经过了一个点的话,那么在这个点上,答案会被重复统计多次,所以我们只需要统计一下每个点上$LCA$出现的次数然后组合数学去重即可. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解:树]]></title>
    <url>%2F2019%2F09%2F12%2F%E9%A2%98%E8%A7%A3-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[暴力都不想写的题… 考虑到题目中要求的最小的那个东西不太好求所以我们可以找一个最大的符合条件的值,我们记为$tmp$,那么有$ans=tmp+1$ 那我们考虑一下这个$tmp$怎么求. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI普转提D1题解]]></title>
    <url>%2F2019%2F09%2F11%2FZROI%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[版权问题,题面不公开 T1.显然可以发现这个区间长度满足单调性(设$len1&gt;len2$,那么如果$len2$满足条件,$len1$一定满足条件.).所以我们可以考虑二分答案.我们设$buck[i][j]$数组来表示前$i$个数中,$j$这个数字出现了多少次(就是一个前缀和).但是这样的话我们会发现数据的权值是$10^9$范围的,直接开一个桶会挂掉(开$map$会$TLE$,,,不要问我咋知道的),所以我们考虑先对数据离散化.然后对于每一次二分,我们可以$O(n)$枚举区间,然后枚举权值,对于每个枚举的区间可以$O(n)$check每种权值,总复杂度为$O(n^2log_2n)$ T2.显然可以发现,题目中要求的个位数字只受要除的数的个位的影响,所以我们在求出来了倍数的个数$num$时,可以发现,个位数字的出现是有周期的,而这个周期和周期中的数字是由要除的数字的个位决定的.而因为要除的数字的个位最多只有10个,所以我们可以先预处理出每个数字的周期以及他们的和,再对多出来的部分直接暴力就可以了.T3.第一眼看上去发现限制有点多,但是分析一下,一个物品能不能放只受到了它放的时间以及它上边最多放多少东西的限制.所以对于时间这一方面的限制,我们可以考虑对时间这一维进行排序. 讲的很明白,但是我并不知道怎么证明qwq D.第一眼看来貌似不怎么可做… 自己观察之后我们发现直接求所有的方案数貌似不太可做…所以我们考虑一下容斥. 我们设$f_i$为包含了状态$i$以及状态$i$的所有子集的方案数.那么我们考虑一下怎么容斥. 我们以$n=3$的情况为示范.(不要吐槽我是灵魂画师) 我们可以发现,对于某个状态$j$,当这个状态中的$1$的个数的奇偶性等于$(1&lt;&lt;m)-1$的个数时,那么可以发现此状态的m容斥系数为$1$,否则,该状态的容斥系数为$-1$. 所以我们可以初步的列出一个式子: ans=\sum_{i=0}^{(1]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散步]]></title>
    <url>%2F2019%2F09%2F11%2F%E6%95%A3%E6%AD%A5%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这题好难啊 首先可以发现可以二分答案. 我们可以考虑二分一个最长的路径长度$mid$,然后将每个点看成不能在最多连续走$mid$个相同的路的情况下,从$1$号点到$n$号点是否联通. 然后现在的问题就变成了判断图的连通性的问题.我们发现,每个点只有两条出边.而且每种类型的出边只有一条,那么可以发现同样的类型的路径的走路的路径,可以看作一个集合.我们可以设$dis_{i,siz}$表示$i$这个点一直按照$siz$类型的路径一直走,最后一段$siz$路径的长度,然后我们发现,如果$i$这个点走到$j$这个点时,那么$dis_{j,siz}=dis_{i,siz}+1$,而我们发现这个东西显然可以用带权并查集来维护.在使用了带权并查集之后,我们每次就可以在$O(logn)$的时间复杂度内求出以某个点为起点走到最远能走到那个点了.然后我们可以进行一次$bfs$.在某次更新中,可以发现,如果现在到达这个点的最后的路径是$siz$类型的话,如果现在这个点连向的$siz xor 1$类型的点还没有被入队过,那么就将这个点扔进队里. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 2e5 + 10; int n;int G[N][2];int father[N][2] , dis[N][2];bool vis[N][2];struct Node &#123; int pos; int kid;&#125;;std :: queue &lt; Node &gt; qu;int find ( int x , int kd ) &#123; if ( father[x][kd] != x ) &#123; int tmp = father[x][kd]; father[x][kd] = find ( father[x][kd] , kd ); dis[x][kd] += dis[tmp][kd]; &#125; return father[x][kd];&#125;inline bool check ( int rdm ) &#123; memset ( vis , false , sizeof ( vis ) ); memset ( dis , 0 , sizeof ( dis ) ); F ( i , 1 , n ) father[i][0] = father[i][1] = i; qu.push ( Node &#123; 1 , 0 &#125; ); qu.push ( Node &#123; 1 , 1 &#125; ); while ( !qu.empty() ) &#123; int j = qu.front().pos; int siz = qu.front().kid; qu.pop(); int now = 0; while ( 1 ) &#123; int root = find ( j , siz ); now = dis[j][siz]; if ( now + 1 &gt; rdm ) break; int kt = G[root][siz]; int kj = find ( kt , siz ); if ( !vis[kt][siz ^ 1] ) &#123; vis[kt][siz ^ 1] = 1; qu.push ( Node &#123; kt , siz ^ 1 &#125; ); &#125; if ( kj == root ) break; father[root][siz] = kt; dis[root][siz] = 1; &#125; &#125; if ( vis[n][0] || vis[n][1] ) return 1; return 0;&#125;int main ( void ) &#123; read ( n ); F ( i , 1 , n ) &#123; G[i][0] = _read(); G[i][1] = _read(); &#125; int l = 0 , r = n + 1; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( check ( mid ) ) r = mid - 1; else l = mid + 1; &#125; if ( l &gt; n ) puts ( "-1" ); else writeln ( l ); return 0;&#125;// Main Code 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 72 题解报告]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[qwq A.第一眼看上去貌似是个找规律$O(1)$题,实际看了一下,确实是找规律$O(1)$题.所以就开始愉快的找规律,于是就有了以下的提交记录: emmm…. QAQ然后我们考虑一下正解. 我们设原来我们有$str in exp$,我们设我们分给$str x$点的$exp$,分给$in y$点的$exp$,那么显然有: x+y=exp \ and \ str+x>in+y发现上边的这个方程,通过将$y$用$exp-x$代替之后,我们可以解出$x$的具体范围.而且我们可以发现:所有$x$的取值范围一共只有$exp + 1$种,所以就可以愉快的求出答案了. 最后别忘了判断$exp$为$0$的情况. 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; int str,in,exp; cin&gt;&gt;str&gt;&gt;in&gt;&gt;exp; if (exp==0)&#123; if(str&gt;in) cout&lt;&lt;"1"&lt;&lt;endl; else cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; if(in+exp-str&lt;0)&#123; cout&lt;&lt;exp+1&lt;&lt;endl; continue; &#125; int ans=min(exp+1,(exp+1)-max(0ll,((in+exp-str)/2+1))); if ( ans &lt; 0 ) ans = 0; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; B.这么可爱的怪兽我怎么可能忍心去打它呢 我们看到题,首先想到,如果我们砍一刀,这个怪兽不死,那么它如果长出来的头大于我们我们这次砍掉的头.那么我们这次的操作显然没用.所以,在前几刀砍不死怪兽的情况下,我们需要最大化每一次砍头时的$d_i-h_i$,同时我们发现.在某一次砍头中,如果这次的$d_j$非常大,大到一下子可以把怪兽剩下的头砍完.我们就可以不用管这次砍头的副作用$h_j$了. 所以我们维护两个最大值,即$d_i-h_i$的最大值以及$d_i$的最大值,然后直接找题意做即可. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n,x;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; int maxs=-1e16; int Damage=-1e16; cin&gt;&gt;n&gt;&gt;x; for(int i=1;i&lt;=n;i++) &#123; int tx,ty; cin&gt;&gt;tx&gt;&gt;ty; maxs=max(maxs,tx); Damage=max(Damage,tx-ty); &#125; if ( x &lt;= maxs ) &#123; cout &lt;&lt; "1" &lt;&lt; endl; continue; &#125; if(Damage&lt;=0)&#123; cout&lt;&lt;"-1"&lt;&lt;endl; continue; &#125; int now = ( x - maxs ) / Damage; if ( now * Damage &lt; x - maxs ) now+=2; else now++; cout&lt;&lt;now&lt;&lt;endl; &#125; return 0;&#125; C.通过读题,我们可以发现一个很重要的东西:$\sum_{i=1}^t len_i&lt;=2*10^5$. 通过这个性质,我们可以发现,我们在枚举每一次的区间时,这个区间的最长长度为$log_2len$. 然后就做完了?? 我们枚举一下每个区间的左/右端点,然后直接暴力统计答案就好了. 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int N = 200000 + 10;int t,nex[N];char s[N];int main() &#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",s+1); int n=strlen(s+1); nex[n+1]=n+1; for(int i=n;i&gt;=1;i--) &#123; if(s[i]=='0') nex[i]=nex[i+1]; else nex[i]=i; &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; int now=0; for(int j=nex[i];j&lt;=min(n,nex[i]+20);j++)&#123; now=now*2+s[j]-'0'; if(now==j-i+1) ans++; &#125; &#125; printf("%d\n", ans); &#125;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round #582解题报告]]></title>
    <url>%2F2019%2F09%2F11%2FRound-2%2F</url>
    <content type="text"><![CDATA[qwq A.Chips Moving题意就是给你n个数,你每次可以选择一个数,对他进行免费的加2或者减2.或者花费1的代价,对某个数进行加一或者减一,求让所有的数变成一样的最小代价. 很显然可以发现,奇数和奇数之间可以相互转变,偶数和偶数之间也可以相互转变,那么我们只需要考虑让奇数全部变成偶数或者让偶数变成奇数就好了. 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int cnto = 0; for (int i = 0; i &lt; n; ++i) &#123; int x; cin &gt;&gt; x; cnto += x &amp; 1; &#125; cout &lt;&lt; min(cnto, n - cnto) &lt;&lt; endl; return 0;&#125; B.Bad Prices题意就是给你一个序列$A$,让你求出所有$A_i$中,$\sum_{i=1}^n[A_i&gt;A_{j(i&lt;j&lt;=n)}?0:1]$ 显然可以直接维护一个后缀最小值,然后判断一下当前$A_i$的值和当前后缀最小值的大小关系,如果$A_i&gt;num_i$,那么ans++ 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std; const int N=150005; int n;int num[N];int mins[N]; int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(mins,0x3f3f3f3f,sizeof(mins)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;num[i]); for(int i=n-1;i&gt;=1;i--) mins[i]=min(mins[i+1],num[i+1]); int ans=0; for(int i=1;i&lt;n;i++) if(num[i]&gt;mins[i]) ans++; printf("%d\n",ans); &#125; return 0;&#125; // C.Book Reading显然可以发现,题目中要求的个位数字只受要除的数的个位的影响,所以我们在求出来了倍数的个数$num$时,可以发现,个位数字的出现是有周期的,而这个周期和周期中的数字是由要除的数字的个位决定的.而因为要除的数字的个位最多只有10个,所以我们可以先预处理出每个数字的周期以及他们的和,再对多出来的部分直接暴力就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define int long long using namespace std; int n,m;int ned[10],idx[10];int sum[10][10]; signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); for(int i=1;i&lt;=9;i++)&#123; int now=i; sum[i][++idx[i]]=i; now+=i; while(now!=i)&#123; if(now&gt;=10) now-=10; sum[i][++idx[i]]=now; now+=i; &#125; &#125; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=idx[i];j++) ned[i]+=sum[i][j]; int T; cin&gt;&gt;T; while(T--)&#123; int ans=0; cin&gt;&gt;n&gt;&gt;m; int numm=n/m; int tmp = m; tmp%=10; if(tmp==0||numm==0)&#123; cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; int fir = numm/idx[tmp]; ans+=fir*ned[tmp]; // cout&lt;&lt;fir&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl; int sos=0; for(int i=fir*idx[tmp]+1;i&lt;=numm;i++) ans+=sum[tmp][i-fir*idx[tmp]]; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; // D.Equalizing by Division我们可以发现,对于某一个数$i$,他能变成的数的个数为$log_2i+1$个,而且题目中$i$的权值也不大,所以我们可以开一个桶,按照从小到大的顺序处理每一个数字,每次处理的时候将它能变成的$log_2i$个数字在桶中的权值全部+1,同时花费就是从原来的i到目前的数字要除几次二,当发现有桶中的数字大于给定的$k$时,更新答案. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std; const int N = 2e5 + 10; int n,k,ans=2147483647;int num[N];struct Node&#123; int val; int now;&#125;buck[N]; int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; buck[num[i]].now++; if(buck[num[i]].now&gt;=k)&#123; cout&lt;&lt;"0"&lt;&lt;endl; return 0; &#125; &#125; sort(num+1,num+1+n); for(int i=1;i&lt;=n;i++)&#123; int idx=1,tmp=num[i]/2; while(tmp)&#123; buck[tmp].now++; buck[tmp].val+=idx; if(buck[tmp].now&gt;=k) ans=min(ans,buck[tmp].val); tmp/=2; idx++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; // 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Qualification解题报告]]></title>
    <url>%2F2019%2F09%2F11%2FQualification%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[qwq T1:题目中给你一个$D$和一个$M$(一年有$D$个月,一个月有$M$天)让你求出: 的个数.其中$d_1$表示个位,$d_{10}$表示十位. 因为数据范围比较小,所以可以直接暴力枚举解决qwq… 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int m,d,ans;int main(void)&#123; scanf("%d%d",&amp;m,&amp;d); for(int i=1;i&lt;=m;i++)&#123; for(int sw=22;sw&lt;=d;sw++)&#123; int g=sw%10; int s=sw/10; if(g&gt;=2&amp;&amp;s&gt;=2&amp;&amp;s*g==i) ans++; &#125; &#125; printf("%d\n",ans); return 0;&#125; T2:给你一个数列$A$,将这个$A$不断$copy k$次变成数列$B$.最后让你求出数列$B$的逆序对个数.$k&lt;=10^9$ 看到$k$那么大,肯定可以$n^2$暴力了啊qwq 我们考虑这k组中的每一组.如果我们考虑原数列$A$中的每一位$A_i$,如果出现了一个$A_j&lt;A_i$,那么在从第$2$组开始,到第$k$组,这些比$A_i$小的数都会对$A_i$有贡献,而且第$3$组到第$k$组也会对第$2$组有贡献,这样一直递推下去,会发现有$1+(k-1)*(k-1)/2$次贡献,而且最后不要忘了一组中对自己的贡献. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=2004;const int HA=1e9+7;int n,k,ans;int num[N],dd[N];inline int ksm(int x,int y)&#123; int tmp=1; while(y)&#123; if(y&amp;1) tmp=(tmp*x)%HA; x=(x*x)%HA; y&gt;&gt;=1; &#125; return tmp%HA;&#125;signed main()&#123; scanf("%lld%lld",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;num[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; if(num[j]&lt;num[i]) dd[i]++; &#125; for(int i=1;i&lt;=n;i++)&#123; ans=(ans+k*(k-1)%HA*ksm(2,HA-2)%HA*dd[i]%HA)%HA; int tdp = 0; for(int j=i+1;j&lt;=n;j++) if(num[j]&lt;num[i]) tdp++; ans = ( ans + tdp * k ) % HA; &#125; printf("%lld\n",ans); return 0; &#125; T4:T3我不会欸qwq(捂脸) 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Atcoder题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round #573 (Div. 2)解题报告]]></title>
    <url>%2F2019%2F09%2F11%2FRound-1%2F</url>
    <content type="text"><![CDATA[qwq A:没啥可说的,直接按照$Mod 4$分类然后讨论就好了. B:显然可以发现答案只能是0,1,2,3中的某一个,我们只需要将读入记录下来,然后对于每一种胜利的情况分组枚举一下,记录一个最小的ans就可以了. C:考虑每一次操作中,这一页的最右边能消除几个.我们可以设我们已经消除了$sum$个数字,那么当前的$m_i$在消除之后中的书中的位置就是$m_i-sum$,我们就可以推导出来当前$m_i$的这一页的最右边的一个数字就是$((m_i-sum)/k+1)*k$,我们只需要开一个关于i的指针就可以了,时间复杂度为$O(m)$. D:考虑必胜情况:在另外一个人开始取的时候有$2$个或者以上的重复组.或者在有1个重复组时,取出一个重复组(因为不取就会输)之后回和另外一个元素再组成一个重复组. 我们再考虑完这种情况之后,可以发现,我们在将原来的数组排序之后,如果两边都按照最优方式取石子,那么最后的(在决定胜负之前),石子的序列一定是$B_i=i-1$的这样的一个等差数列.所以我们需要对原数组排序,然后统计一个$\sum_{i=1}^n A_i-(i-1)$,判断一下这个$sum$的奇偶性就可以了. PS:一定要先判断有没有例外的必胜情况(我就是这么WA了4发qwq….) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=1e5+10;int n,idxx;int num[N],dis[N];map&lt;int,bool&gt;mp;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; sort(num+1,num+1+n); int sum=0,dpp=0; for(int i=1;i&lt;=n;i++)&#123; if(num[i]==num[i-1]&amp;&amp;i&gt;=2)&#123; dpp++; dis[++idxx]=num[i]; &#125; sum+=num[i]-i+1; mp[num[i]]=1; &#125; if(n==1)&#123; if(sum&amp;1) cout&lt;&lt;"sjfnb"&lt;&lt;endl; else cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(dpp==1&amp;&amp;num[1]==0&amp;&amp;num[2]==0)&#123; cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(dpp==1&amp;&amp;n==2)&#123; cout&lt;&lt;"sjfnb"&lt;&lt;endl; return 0; &#125; if(dpp==1)&#123; if(mp[dis[1]-1]) cout&lt;&lt;"cslnb"&lt;&lt;endl; else &#123; if(!(sum&amp;1)) cout&lt;&lt;"cslnb"&lt;&lt;endl; else cout&lt;&lt;"sjfnb"&lt;&lt;endl; &#125; return 0; &#125; if(dpp&gt;=2)&#123; cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(!(sum&amp;1)) cout&lt;&lt;"cslnb"&lt;&lt;endl; else cout&lt;&lt;"sjfnb"&lt;&lt;endl; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round]]></title>
    <url>%2F2019%2F09%2F11%2FRound%2F</url>
    <content type="text"><![CDATA[qwq A:这道题能想到二进制转十进制然后判断满足的个数，但是转十进制范围已经超过了$long long$，直接模拟会溢出因为满足条件数值的都是4的次幂，所以二进制首位1后跟的$2k$个$0$即为$4$的$k$次幂直接对$0$的个数分析即可 B:很明显的一道贪心题目,当求最小的$sum$时,显然当$1$最多时,$sum$最小.当求$sum$最大时同理.又因为当$a_i$是一个偶数时,$\frac{a_i}{2}$肯定存在,而且$a_i$的最小值为1,所以显然$a_i$的值就只能是$2^j$. C:(个人感觉比$D$难$QAQ…$)让你在给定的序列$P$中求一个子序列,使得在图中按照该子序列进行最短路径移动时可以完整经过原序列$P$.乍一看一点思路都没有.但是仔细思考可以发现一点点思路.我们可以从题目中给出的起点(也就是一号点)开始进行移动,然后在原序列$P$中如果需要经过$P_{i}$和$P_{i+1}$,那么我们显然可以得到$P_i$与$P_{i+1}$一定是直接相连的(因为题目中没有给出无解的情况).那么我们可以扩展一下,假设我们现在在$P_j$号点,我们要走到$P_k$号点.那么如果$dis[P_j][P_k]==j-k$,那么在有解的情况下,一定是有$P_j$经过了所有的$j&lt;i&lt;k$的点(可以自己画个图证明一下).在这种情况下,我们就可以选择扩展答案了. (感觉还是放一下代码比较好qwq) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int oo = 0x3f3f3f3f;const int N = 105;const int M = 1e6 + 10;int n,m,idx;char mp[N][N];int G[N][N],point[M],ans[M];int qu[M&lt;&lt;1];int head=1,tai=0;int main()&#123; memset ( G , 0x3f3f3f3f , sizeof ( G ) ); scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%s" , mp[i] + 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= n ; j++ ) if ( mp[i][j] == '1' ) G[i][j] = 1; G[i][i] = 1; &#125; for ( int k = 1 ; k &lt;= n ; k++ ) for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) G[i][j] = min ( G[i][j] , G[i][k] + G[k][j] ); scanf("%d",&amp;m); for ( int i = 1 ; i &lt;= m ; i++ ) scanf ( "%d" , &amp;point[i] );// for(int i=1;i&lt;=n;i++)&#123;// for(int j=1;j&lt;=n;j++)// printf("%d " ,G[i][j]);// puts("");// &#125; int st=1,now=2; while(now&lt;=m)&#123; int diss=now-st; if(diss==G[point[st]][point[now]])&#123; if(head&lt;=tai) head++; qu[++tai]=now; now++; &#125; else &#123; ans[++idx]=point[st]; if(head&lt;=tai) st=qu[head++]; &#125; &#125; ans[++idx]=point[st]; if(ans[idx]!=point[m]) ans[++idx]=point[m]; printf("%d\n",idx); for(int i=1;i&lt;=idx;i++) printf ("%d ",ans[i]); return 0;&#125; D:感觉比$C$简单啊$QAQ$….让你求一个字符串使得这个字符串和给定01字符串的每一个子区间的最长单调不降区间长度一样长.我们自己理解了以后可以发现,一个区间的最长单调不降区间长度只是和每一个$1$后的$0$有关系,而和$0$后的$1$无关.(因为对于两个子串$11$和$01$,它们的最长不降区间是一样的).那么我们就可以考虑把原字符串的一些$1$变成$0$.就可以了. 但是怎么改变呢?我们考虑到,对于某一段连续的$1$,那么这段连续区间中的第一个1很显然是不必要的(而且不是最后一个1),那么我们可以把这些个1变成0.(然后就做完辣qwq) 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int tmpp;char ss[N] , tt[N];int main()&#123; scanf ( "%s" , ss + 1 ); int len = strlen ( ss + 1 ); for ( int i = 1 ; i &lt;= len ; i++ ) tt[i] = ss[i]; for ( int i = len ; i &gt;= 1 ; i-- ) &#123; if ( ss[i] == '1' &amp;&amp; tmpp &gt;= 0 ) tt[i] = '0'; int cur=ss[i] == '1' ? 1 : -1; tmpp = min ( tmpp + cur , cur ); &#125; for ( int i = 1 ; i &lt;= len ; i++ ) printf ( "%c" , tt[i] ); return 0;&#125;// E:现在还不会qwq 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190819模拟赛题解]]></title>
    <url>%2F2019%2F09%2F11%2F20190819%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[qwq 又是爆零的一次比赛欸qwq… T1: 让你在一个矩阵中,找出一条路径,使得经过的路径方差最小. 我就直接放题解了qwq… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;template &lt;class T&gt;bool Reduce(T &amp;a,T const &amp;b)&#123; return a&gt;b?a=b,1:0;&#125;const int N=31,inf=1e9+7,S=59*30;int n,m,ans;int a[N][N];int f[N][N];int cnt=0;void init()&#123; std::ios::sync_with_stdio(false); freopen("path.in","r",stdin); freopen("path.out","w",stdout); std::cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) std::cin&gt;&gt;a[i][j];&#125;int calc(const int &amp;sum,const int &amp;i,const int &amp;j)&#123; return (n+m-1)*a[i][j]*a[i][j]-2*sum*a[i][j];&#125;int dp(int sum)&#123; for(int i=0;i&lt;N;++i) for(int j=0;j&lt;N;++j) f[i][j]=inf; f[1][1]=calc(sum,1,1); for(int j=2;j&lt;=m;++j) Reduce(f[1][j],f[1][j-1]+calc(sum,1,j)); for(int i=2;i&lt;=n;++i) Reduce(f[i][1],f[i-1][1]+calc(sum,i,1)); for(int i=2;i&lt;=n;++i) for(int j=2;j&lt;=m;++j)&#123; Reduce(f[i][j],f[i-1][j]+calc(sum,i,j)); Reduce(f[i][j],f[i][j-1]+calc(sum,i,j)); &#125; return sum*sum+f[n][m];&#125;int main()&#123; init(); ans=inf; for(int sum=1;sum&lt;=S;++sum) Reduce(ans,dp(sum)); std::cout&lt;&lt;ans; return 0;&#125; T2:让你每次从一个区间向另一个区间连边,最后求起点到所有点的最短路. 很显然是线段树优化建图,开两颗线段树A,B,第一颗线段树从儿子节点向父亲连边,另外一条线段树从父亲向儿子连边.但是一个点一个点的向区间连边太麻烦了,所以我们需要建一个虚点,每次从区间[l1,r1]向一个虚点连边,然后再用这个虚点向区间[l2,r2]连边,这样就可以了. (但是我被卡常了) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; const int N = 500010;const int M = 2210000;int n , m , p , tot , cnt , root_f , root_s;struct edge&#123; int to; int next; int date;&#125;e[11000000];struct Node&#123; int lc; int rc;&#125;tree[N&lt;&lt;2];int head[M] , dis[M] , pos[N];bool vis[M];std :: priority_queue &lt; std :: pair &lt; int , int &gt; , std :: vector &lt; std :: pair &lt; int , int &gt; &gt; , std :: greater &lt; std :: pair &lt; int , int &gt; &gt; &gt; q; inline void add(int x,int y,int date)&#123; e[++cnt].to=y; e[cnt].next=head[x]; head[x]=cnt; e[cnt].date=date; return;&#125;void FBuild(int &amp;root,int l,int r)&#123; root=++tot; if ( l == r ) &#123; pos[l]=root; return; &#125; int mid=l+r&gt;&gt;1; FBuild(tree[root].lc,l,mid); FBuild(tree[root].rc,mid+1,r); add(tree[root].lc,root,0); add(tree[root].rc,root,0); return;&#125;void SBuild(int &amp;root,int l,int r)&#123; root=++tot; if(l==r)&#123; add(root,pos[l],0); return; &#125; int mid=l+r&gt;&gt;1; SBuild(tree[root].lc,l,mid); SBuild(tree[root].rc,mid+1,r); add(root,tree[root].lc,0); add(root,tree[root].rc,0); return;&#125;void FAdd(int root,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; add(root,tot,1); return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) FAdd(tree[root].lc,l,mid,x,y); if(y&gt;mid) FAdd(tree[root].rc,mid+1,r,x,y);&#125;void SAdd(int root,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; add(tot,root,1); return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) SAdd(tree[root].lc,l,mid,x,y); if(y&gt;mid) SAdd(tree[root].rc,mid+1,r,x,y); return;&#125;inline void Dijkstra()&#123; memset(dis,0x3f3f3f3f,sizeof(dis)); q.push(std :: make_pair(0,pos[p])); dis[pos[p]]=0; while(!q.empty())&#123; int x=q.top().second; q.pop(); if(vis[x]) continue; vis[x]=1; for(int i=head[x];i;i=e[i].next)&#123; int y=e[i].to; if(dis[x]+e[i].date&lt;dis[y])&#123; dis[y]=dis[x]+e[i].date; q.push(std ::make_pair(dis[y],y)); &#125; &#125; &#125; return;&#125;int main ( void ) &#123; freopen("road.in","r",stdin); freopen("road.out","w",stdout); n = read(); m = read(); p = read(); FBuild ( root_f , 1 , n ); SBuild ( root_s , 1 , n ); while ( m-- ) &#123; int x1 = read() , y1 = read() , x2 = read() , y2 = read(); tot++; FAdd(root_f,1,n,x1,y1); SAdd(root_s,1,n,x2,y2); tot++; FAdd(root_f,1,n,x2,y2); SAdd(root_s,1,n,x1,y1); &#125; Dijkstra(); for(int i=1;i&lt;=n;++i) printf("%d\n",dis[pos[i]]/2); return 0;&#125; T3:给你一个矩阵,让你求出这个矩阵中的一个最大的子矩阵,使得这个子矩阵的每一行和每一列都是等差数列 暂时咕咕咕一会,不会 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邪教算法学习小结]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%82%AA%E6%95%99%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[qwq 事实证明,邪教算法是很有用的qwq(以下材料大多抄袭OI-wiki)qwq Part1:随机函数:但是并找不到什么随机化好题qwq,,,,,先Pass了再说qwq… Part2:爬山算法:个人理解就是一个比较跳的贪心(真的是个贪心)….一般常用于单峰函数的求解,但是单峰函数为啥不写三分呢? 爬山算法的一般流程其实就是:选定一个初始答案,通过某种方法计算出另外一个答案,if 另一个答案更优 then 转移否则不变, 很形象的就是了爬山这种东西. 例题 JSOI2008球形空间产生器 空间模型的爬山就是很正常的模板了,直接给代码了qwq 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10005;int n;double tot , f[1005][1005];double ans[N] , cans[N] , dis[N];inline void check () &#123; tot = 0; for ( int i = 1 ; i &lt;= n + 1 ; i++ ) &#123; cans[i] = 0; dis[i] = 0; for ( int j = 1 ; j &lt;= n ; j++ ) dis[i] += ( f[i][j] - ans[j] ) * ( f[i][j] - ans[j] ); dis[i] = sqrt ( dis[i] ); tot += dis[i]; &#125; tot /= ( n + 1 ); for ( int i = 1 ; i &lt;= n + 1 ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) cans[j] += ( dis[i] - tot ) * ( f[i][j] - ans[j] ) / tot; return;&#125;int main() &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n + 1 ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) &#123; scanf ( "%lf" , &amp;f[i][j] ); ans[j] += f[i][j]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) ans[i] /= ( n + 1 ); for ( double T = 10001 ; T &gt;= 0.0000001 ; T *= 0.99995 ) &#123; check (); for ( int j = 1 ; j &lt;= n ; j++ ) ans[j] += cans[j] * T; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%.3lf " , ans[i] ); return 0;&#125; Part3. 模拟退火理解了爬山算法了之后,可以发现爬山算法存在的很显然的一个局限性:只能贪心,而这种在处理一些多峰函数时往往会只找到函数的某个极大值而不是最大值.所以我们就要引入模拟退火这种方法.,那么$What is $模拟退火呢? (以下内容来自WIKI) : 12345模拟退火来自冶金学的专有名词退火。退火是将材料加热后再经特定速率冷却，目的是增大晶粒的体积，并且减少晶格中的缺陷。材料中的原子原来会停留在使内能有局部最小值的位置，加热使能量变大，原子会离开原来位置，而随机在其他位置中移动。退火冷却时速度较慢，使得原子有较多可能可以找到内能比原先更低的位置。模拟退火的原理也和金属退火的原理近似：我们将热力学的理论套用到统计学上，将搜寻空间内每一点想像成空气内的分子；分子的能量，就是它本身的动能；而搜寻空间内的每一点，也像空气分子一样带有“能量”，以表示该点对命题的合适程度。算法先以搜寻空间内一个任意点作起始：每一步先选择一个“邻居”，然后再计算从现有位置到达“邻居”的概率。可以证明，模拟退火算法所得解依概率收敛到全局最优解。 听起来很懵逼是不是qwq..没关系,其实就是如果你通过现在的这个状态,以某种方式得到了另外一个答案时,你不再像爬山算法那样直接转移,而已要像下图: 发生转移之后,随着温度T的不断降低,可以发现$\frac{-\Delta E}{T}$是不断减小的(因为在新状态更劣的情况下,$-\Delta E$一定为负数),那么$e^\frac{-\Delta E}{T}$一定也是不断减小的并且趋向于0.即模拟退火算法在温度较低时退化为爬山算法.这时只能寻找当前的函数极大值,所以怎么调参使得温度$T$较大时转移到正确的峰函数区间是解决问题的关键(但是还是只能靠运气qwq) 一般模拟退火的代码大概框架如下: 123456789101112inline void SA () &#123; for ( double T = StartTemplature ; T &gt;= EndTemplature ; T *= Coolingcoefficient ) &#123; Typename Newans = Getans();//此处Getans为某个获得新答案的函数. Typename delta = ans - Newans; if ( Newans &gt; ans ) //这里假设当值大时答案更优 ans = Newans; else if ( exp ( -delta / T ) &lt; ( double ) rand () % RAND_MAX ) ans = Newans; &#125; return;&#125; 其实为了保证答案的正确性,一般都会跑多次模拟退火从而增加求得最优解的概率.(调参也是个非常痛苦的过程,因为模拟退火比爬山算法更为看脸随机,所以每个参数的小差别可能导致答案的天壤之别.) 例题 [TJOI2010]分金币 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt; #include &lt;ctime&gt;#define int long longconst int N = 1005;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int n , ans = 2147483647;int num[N];inline int get () &#123; int sum1 = 0 , sum2 = 0; for ( int i = 1 ; i &lt;= ( n + 1 ) / 2 ; i++ ) sum1 += num[i]; for ( int i = ( n + 1 ) / 2 + 1 ; i &lt;= n ; i++ ) sum2 += num[i]; return abs ( sum1 - sum2 );&#125;inline void SA () &#123; double T = 5000; while ( T &gt;= 1e-10 ) &#123; int l = rand () % n + 1 , r = rand () % n + 1; std :: swap ( num[l] , num[r] ); int sum = get (); if ( sum &lt; ans ) ans = sum; else if ( exp ( ( ans - sum ) / T ) &lt; (double(rand())/RAND_MAX) ) std :: swap ( num[l] , num[r] ); T *= 0.98; &#125; return;&#125;signed main ( void ) &#123; srand ( rand() ); int T = read (); while ( T-- ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) num[i] = read (); for ( int i = 1 ; i &lt;= 100 ; i++ ) SA (); printf ( "%lld\n" , ans ); ans = 2147483647; &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Noip2018游记]]></title>
    <url>%2F2018%2F11%2F17%2FNoip2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[真没想到我能活着苟到写游记的一天$qwq$ Day-1最近几天有点累，早上就不去学校了（然而事实证明这是很正确的抉择）。早上一觉睡到了$8:20$，早上起来想起来$wucstdio$大佬说过立过的$flag$不拔在$Noip$会掉$rp$然后早睡起来就开始肝猪国杀，一直到$10:40$左右重构完了（历时$3$天终于写完了）下午回到学校，发现早上是信心鼓励赛幸好没去23333然后下午+晚上一直在写模板题。（顺便凑出来了$AC520$） Day 0早上教练居然给我们请假不用早来了哎$qwq….$上午开始走，一开始的时候还想在车上背个板子什么的然后SCP真好看又颓了会知乎然后就发现到了$cyyz$了 住宿安排完成了之后居然才$2:30$多一点，然后在宿舍里不知道该干啥。不过感觉$cyyz$的移动信号貌似比$SDSC$的时候快了一点（大雾）然后$wucstdio$给我打电话说楼下有很多大佬，自己迅速下楼去膜神仙。 终于见到了$rqy$姐姐本人了好兴奋$qwq$，不过$rqy$姐姐好像比自己想的稍微内敛了一点。 但是这并改变不了rqy姐姐是人赢的性质据说看见神仙可以rp++,（但是rp貌似被rqy姐姐吸走了QAQ) 晚上全宿舍都在打板子，但是试机的时候$wyxdrqc$和$zyp$大佬还有很多人（包括我）试机的时候线段树都打错了（大雾）。给自己喜欢的人打了个电话，加油qaq… Day 1早上起来，自己冷静了一下，打开题目一看$T1$，哎我为什么$T1$只会$70$分啊….，然后自己又推了1h还是没有推出来，心态当场爆炸qwq…T2当成数论推了半天，然后自己冷静的写了一个乱搞做法，也不知道能得多少分。T3完全不会，打一个直径分滚粗了。 出考场：啊你们怎么都做过原题吗？啊T2是个裸背包吗？啊T3你们都会写70分吗？心态崩了我要妹子QWQ….. 下午心态一直RE中，在宿舍里颓了一下午。不管怎么说第二天都想翻盘。 Day 2第二天睡了一觉，发现心情稍微好了一点。到了考场之后，看到第一题$m=n$我就感觉药丸…. 为什么$Noip$的$T1$要考基环树啊….. 写了个$60$分的树上贪心，然后开始想环上怎么做。然而我很$zz$的没有看数据范围可以$n^2$过，一直在写$O(n)$的做法。然后我就写挂了，自己补了只有环的做法，$72分滚了$。 T2看的时候：啊？读题读了$10mins$确定我不会，然后就决定打表了。 T3：……为什么$Noip$要考$ddp$啊。。。。 出了考场发现大家都说D2不会做当时甚至有些开心。 然后晚上就回去上晚自习了。 一年半的OI一场空，$D1TI$见祖宗说我是再适合不过的了。本来还以为自己能去$PKUWC$,好吧，我还是太$naive$了，感觉自己要与省一擦肩而过….剩下一年自己就养生好了，再来一年起码要拿一个$1=$啊$qwq…..$ 回家之后心态一直RE,,,,不过幸好$wucstdio$大佬能和我谈了谈人生….瞬间感觉$wucstdio$成了我的人生导师qaq…. 以后的路自己就要自己决定了，不过自己决定那些比赛也是要一起参加的qaq… 那些能进入省选的$OIer$们要加油鸭$qaq…$我会一直陪着你们的$@wyxdrqc @wucstdio @lingyuqing$ 你们的$wqyzstql$也要和你们一起努力了。 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考前模板整理]]></title>
    <url>%2F2018%2F11%2F07%2F%E8%80%83%E5%89%8D%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[$Noip$之前在这里整理一波模板….集成了一下所有的$TG$和$PJ$应该会考的模板 PS:所有模板纯属现场手搓，不保证正确性（比如手抖打错字母什么的），如果找到错误请及时告知我qwq 快速排序最基本的板子了吧,$C++$选手表示开心$qaq$。1234567891011121314151617#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5 + 10int n;int num[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;num[i] ); sort ( num + 1 , num + 1 + n ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , num[i] , i == n ? '\n' : ' ' ); return 0;&#125; 并查集12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5 + 10;int n , m;int find ( int x ) &#123; if ( x != father[x] ) father[x] = find ( father[x] ); return father[x];&#125;int main ( void ) &#123; scanf ( "%d%d" , &amp;n , &amp;m ); for ( int i = 1 ; i &lt;= n ; i++ ) father[i] = i; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x , y , z; scanf ( "%d%d%d" , &amp;z , &amp;x , &amp;y ); if ( z == 1 ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; &#125; else if ( z == 2 ) &#123; x = find ( x ) , y = find ( y ); if ( x == y ) puts ( "Y" ); else puts ( "N" ); &#125; &#125; return 0;&#125; 快速幂个人感觉这个还是个挺重要的板子了吧…..12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int Fast_Power ( int x , int y ) &#123; int sum = 1; while ( y ) &#123; if ( y &amp; 1 ) sum = sum * x; x = x * x; y &gt;&gt;= 1; &#125; return sum;&#125;int main ( void ) &#123; int n , m; scanf ( "%d%d" , &amp;n , &amp;m ); printf ( "%d\n" , Fast_Power ( n , m ) ); return 0;&#125; 线性筛素数这个其实只是筛素数的话是挺简单的，但是我决定连$\phi$一起筛出来（如果用不到的话就把$phi$数组自动忽略掉就好了）12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 5e5 + 10;int n , cnt;int prime[N] , phi[N];bool flag[N];int main ( void ) &#123; flag[1] = 1; phi[1] = 1; scanf ( "%d" , &amp;n ); for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; flag[i] = 1; prime[++cnt] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; for ( int i = 1 ; i &lt;= cnt ; i++ ) printf ( "%d " , prime[i] ); puts ( "" ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d " , phi[i] ); return 0;&#125; 【模板】堆又是一个$C++$党的福利$qwq$,直接用$priority_queue$模拟就好啦123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using std :: priority_queue;int n;priority_queue &lt; int , std :: vector &lt; int &gt; , std :: greater &lt; int &gt; &gt; qu;int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int opts; scanf ( "%d" , &amp;opts ); if ( opts == 1 ) &#123; int x; scanf ( "%d" , &amp;x ); qu.push ( x ); &#125; else if ( opts == 2 ) printf ( "%d\n" , qu.top () ); else if ( opts == 3 ) qu.pop (); &#125; return 0;&#125; 字符串蛤希其实我个人比较倾向于写自然溢出或者直接随机一个质数$qwq$12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;typedef unsigned long long ull;const ull base = 233;const int N = 1e4;const int M = 1e3;int n;char s[N][M];ull has[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%s" , s[i] + 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int len = strlen ( s[i] + 1 ); for ( int j = 1 ; j &lt;= len ; j++ ) has[i] = has[i] * base + s[i][j]; &#125; std :: sort ( has + 1 , has + 1 + n ); int ans = 0; for ( int i = 1 ; i &lt;= n ; i++ ) if ( has[i] != has[i + 1] ) ans++; printf ( "%d\n" , ans ); return 0;&#125; 最小生成树不会写$prim$的蒟蒻瑟瑟发抖….123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e4 + 10;const int M = 2e5 + 10;int n , m;struct Edge &#123; int from; int to; int data;&#125;e[M];int father[N];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline bool cmp ( Edge x , Edge y ) &#123; return x.data &lt; y.data;&#125;int find ( int x ) &#123; if ( x != father[x] ) father[x] = find ( father[x] ); return father[x];&#125;void Union ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; return;&#125;inline bool Judge ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); return ( x == y ) ? true : false;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) father[i] = i; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); e[i].from = x; e[i].to = y; e[i].data = z; &#125; std :: sort ( e + 1 , e + 1 + m , cmp ); int NowEdge = 0 , NowVal = 0; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int l = e[i].from , r = e[i].to; if ( Judge ( l ,r ) ) continue; Union ( l , r ); NowEdge++; NowVal += e[i].data; if ( NowEdge == n - 1 ) break; &#125; if ( NowEdge == n - 1 ) printf ( "%d\n" , NowVal ); else puts ( "orz" ); return 0;&#125; 单源最短路 （有负权边）这张图有负权边，所以只能写某已经死掉的$SPFA$了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N = 1e4 + 10;const int M = 1e5 + 10;using std :: queue;int n , m , t;struct Edge &#123; int to; int data; int next;&#125;e[M];int head[N] , dis[N];bool inque[N];inline int read () &#123; int s = 0; bool flag = 0; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '0' ) flag = 1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return ( flag ) ? -s : s;&#125;void Spfa ( int x ) &#123; memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[x] = 1;dis[x] = 0; qu.push ( x ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].data ) &#123; dis[k] = dis[j] + e[i].data; if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; return;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); add ( x , y , z ); &#125; Spfa ( 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , dis[i] == 0x3f3f3f3f ? 2147483647 : dis[i] , i == n ? '\n' : ' ' ); return 0;&#125; 单源最短路 （无负权边）在题目明确说没有负权边的情况下，跑堆优化的$Dijkstra$一定是最稳的其实代码长得都差不多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define F(i,a,b) for ( int i = a ; i &lt;= b ; i++ )#define MP std::make_pair#define se second#define fi firsttypedef std::pair &lt; int , int &gt; pll;const int N = 1e5 + 10; const int M = 4e5 + 20;std::priority_queue &lt; pll , std::vector &lt; pll &gt; , std::greater &lt; pll &gt; &gt; qu;int n , m , s , t;struct Edge &#123; int to; int data; int next;&#125;e[M];int head[N] , dis[N];bool inque[N];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void Heap_Dijkstra ( int x ) &#123; memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); dis[x] = 0; qu.push ( MP ( dis[x] , x ) ); while ( !qu.empty () ) &#123; int j = qu.top ().se; qu.pop (); if ( inque[j] ) continue; inque[j] = 1; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].data ) &#123; dis[k] = dis[j] + e[i].data; qu.push ( MP ( dis[k] , k ) ); &#125; &#125; &#125; return;&#125;int main ( void ) &#123; n = read (); m = read (); s = read (); F ( i , 1 , m ) &#123; int x = read () , y = read () , z = read (); add ( x , y , z ); &#125; Heap_Dijkstra ( s ); F ( i , 1 , n ) printf ( "%d " , dis[i] ); return 0;&#125; 就先整理这些吧…留个坑等着填…. 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2010] 所驼门王的宝藏]]></title>
    <url>%2F2018%2F11%2F05%2Fi-t%2F</url>
    <content type="text"><![CDATA[一道思维难度很简单，代码实现难度非常$mmp$的毒瘤题…..(这很$SDOI…..$) 题目连接：SDOI2010 所驼门王的宝藏 好，我们直接跳过题目背景。 然后我们会发现，如果这道题能把图建出来，那么直接一遍$DAG$上$DP$就过了。 蒽，这不是$sb$题吗？ 然后让我们看数据范围：$1&lt;=n&lt;=1000000$ 笑容逐渐消失 但是我们考虑一下，既然我们要建一张$DAG$。那么，我们完全没有必要对所有的点进行两两连边。我们只需要对每一行和每一列进行连边，把他们连成一个环，这样的话，建边复杂度就会从$O(n^2)$变成$O(n)$了。 然后对于自由门的情况，对不起，我不知道怎么优化，所以我决定暴力建边。 （分析可以发现即使全是自由门，你暴力建边也不会$TLE$） 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;map&gt;const int N = 1e6 + 10;const int M = 5e6 + 10;using std :: map;using std :: stack;int ans = -0x3f3f3f3f;int n , r , c , t;int dx[] = &#123; 0 , 0 , 1 , 1 , 1 , -1 , -1 , -1 &#125;;int dy[] = &#123; 1 , -1 , 1 , 0 , -1 , 1 , 0 , -1 &#125;;struct Node &#123; int x; int y; int opts; int id;&#125;p[N];struct Edge &#123; int from; int to; int next; &#125;e[M];int idx , Bcnt;int head[N] , dfn[N] , low[N];int Belong[N] , size[N] , f[N];int degree[N];bool instack[N];map &lt; std :: pair &lt; int , int &gt; , int &gt; mp;map &lt; std :: pair &lt; int , int &gt; , int &gt; mat;stack &lt; int &gt; st;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].from = x; e[t].next = head[x]; head[x] = t; return;&#125;bool cmp1 ( Node a , Node b ) &#123; if ( a.x != b.x ) return a.x &lt; b.x; if ( a.opts == 1 ) return 1; if ( b .opts == 1 ) return 0; return a.y &lt; b.y;&#125;bool cmp2 ( Node a , Node b ) &#123; if ( a.y != b.y ) return a.y &lt; b.y; if ( a.opts == 2 ) return 1; if ( b.opts == 2 ) return 0; return a.x &lt; b.x;&#125;void Tarjan ( int cur ) &#123; dfn[cur] = low[cur] = ++idx; instack[cur] = 1; st.push ( cur ); for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( !dfn[j] ) &#123; Tarjan ( j ); low[cur] = min ( low[cur] , low[j] ); &#125; else if ( instack[j] ) low[cur] = min ( low[cur] , dfn[j] ); &#125; int k; if ( low[cur] == dfn[cur] ) &#123; Bcnt++; do &#123; k = st.top ();; st.pop (); instack[k] = 0; Belong[k] = Bcnt; size[Bcnt]++; &#125; while ( k != cur ); &#125; return;&#125;void dfs ( int cur , int father ) &#123; if ( f[cur] &gt; size[cur] ) return; f[cur] = size[cur]; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == father ) continue; dfs ( j , cur ); f[cur] = max ( f[cur] , f[j] + size[cur] ); &#125; return;&#125;int main ( void ) &#123; n = read () , r = read () , c = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; p[i].x = read (); p[i].y = read (); p[i].opts = read (); p[i].id = i; mp[std::make_pair ( p[i].x , p[i].y )] = i; &#125; std :: sort ( p + 1 , p + n + 1 , cmp1 ); int first = 1 , last = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( p[i].x != p[i + 1].x ) &#123; if ( first != last ) add ( p[last].id , p[first].id ); last = first = i + 1; &#125; else &#123; if ( p[last].opts == 1 ) add ( p[last].id , p[i + 1].id ); if ( p[i + 1].opts == 1 ) last = i + 1; if ( p[first].opts != 1 ) last = first = i + 1; &#125; &#125; first = last = 1; std :: sort ( p + 1 , p + 1 + n , cmp2 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( p[i].y != p[i + 1].y ) &#123; if ( first != last ) add ( p[last].id , p[first].id ); last = first = i + 1; &#125; else &#123; if ( p[last].opts == 2 ) add ( p[last].id , p[i + 1].id ); if ( p[i + 1].opts == 2 ) last = i + 1; if ( p[first].opts != 2 ) last = first = i + 1; &#125; &#125; //printf ( "%d\n" , t ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( p[i].opts == 3 ) for ( int j = 0 ; j &lt; 8 ; j++ ) &#123; int xx = p[i].x + dx[j]; int yy = p[i].y + dy[j]; if ( mp[std :: pair &lt; int , int &gt; ( xx , yy )] ) add ( p[i].id , mp[std :: pair &lt; int , int &gt; ( xx , yy )] ); &#125; // printf ( "%d\n" , t ); // for ( int i = 1 ; i &lt;= t ; i++ ) // printf ( "%d %d\n" , e[i].from , e[i].to ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( !Belong[i] ) Tarjan ( i ); for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = head[i] ; j ; j = e[j].next ) &#123; int k = e[j].to; if ( Belong[i] != Belong[k] ) mat[std :: make_pair ( Belong[i] , Belong[k] )] = 1; &#125; t = 0; memset ( head, 0 , sizeof ( head ) ); for ( auto it = mat.begin () ; it != mat.end() ; it++ ) &#123; add ( it -&gt; first.first , it -&gt; first.second ); degree[it -&gt; first.second]++; &#125; // for ( int i = 1 ; i &lt;= Bcnt ; i++ ) // printf ( "%d " , degree[i] ); for ( int i = 1 ; i &lt;= Bcnt ; i++ ) if ( degree[i] == 0 ) &#123; dfs ( i , 0 ); ans = max ( ans , f[i] ); &#125; printf ( "%d\n" , ans ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qbxt D2T2 Code 题解]]></title>
    <url>%2F2018%2F11%2F04%2F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[看了一眼之后完全就是一脸懵逼的题…. 首先先读题$qaq$…..题目的大致意思就是给你一个矩阵，然后问你把这个矩阵横竖填成异或值为$1$的矩阵的方案数。 很明显，这道题没有什么枚举上界，所以你想直接枚举的话是不太可能的。那么我们怎么办呢$?$ 我也不知道 既然枚举补星，那么我们就用一个比较常见的正难则反的思想。对于这道题，我们可以容斥的去做 那么，首先，所有的方案是什么呢？ All = 2^{n*m}为什么呢？一共有n+m个校验码，我们按位数考虑，在只有1位的情况下，那么这一位可能是$0$或者$1$。那么就是$(2^n)^m$的方案数了。 然后我们考虑对于每一位删掉不合法的情况：因为异或起来是$1$，那么对于没一行或者每一列，$1$的个数总是奇数。那么我们就可以根据这个东西来进行删除不合法状态的操作了 最后统计出来答案 我们发现，因为有$k$位，而我们是按位考虑的。所以我们最后要取答案的$k$次方。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define int long longconst int N = 505;const int MOD = 1e9 + 7;int c[N][N];int n , m , k , t , ans;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int Fast_Power ( int x , int y ) &#123; int sum = 1; while ( y ) &#123; if ( y &amp; 1 ) sum = sum * x % MOD; x = x * x % MOD; y &gt;&gt;= 1; &#125; return sum;&#125;signed main() &#123; for ( int i = 1 ; i &lt;= 500 ; i++ ) c[i][i] = c[i][0]=1; for ( int i = 2 ; i &lt;= 500 ; i++ ) for ( int j = 1 ; j &lt; i ; j++ ) c[i][j] = ( c[i - 1][j] + c[i - 1][j - 1] ) %MOD; t = read(); while ( t-- ) &#123; n = read () , m = read() , k = read (); int ans = Fast_Power ( 2 , n * m ); for ( int i = 0 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) &#123; if ( i == 0 &amp;&amp; j == 0 ) continue; if ( ( i + j ) &amp; 1 ) ans = ( ans + MOD - Fast_Power ( 2 , ( n - i ) * ( m - j ) ) * c[n][i] % MOD * c[m][j] % MOD ) % MOD; else ans = ( ans + Fast_Power ( 2 , ( n - i ) * ( m - j ) ) * c[n][i] % MOD * c[m][j] % MOD ) % MOD; &#125; ans = Fast_Power ( ans , k ); printf ( "%lld\n" , ans ); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解] Noip2016D1T3 换教室]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%8D%A2%E6%95%99%E5%AE%A4%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一道被天天爱跑步抢尽了风头的最没有排面的$T3…..$说实话，这道题我刚开始是不会的，然后我看了L_Y_T大爷的$Blog$之后才恍然大悟（$Blog$写的很好，赞一个）先安利完$Blog$再说L_Y_T大爷的Blog 看了$Blog$之后,突然发现，这东西要求的概率知识点我都是会的，只是DP式子想不出来而已$qaq…$(我好菜啊) 因为题目中说，我们最多可以换$m$次，而题目中说的你只能在开始之前选择方案的说法完全没用，毕竟谁会知道你是预测了未来呢（逃 然后，因为有$n$个课程，所以我们设$f[i][j][0/1]$来表示第i个点,第j次换,换不换 然后我们分情况来表示转移：每个教室分为两种情况 1.换2.不换这个是挺平常的然后复杂在换与不换的分情况上了~~~不换:不换是分为这样几种情况:上一个也不换 , 上一个换 且成功,上一个换但失败同理,换也有好多种情况:上一个点不换,这个点失败上一个点不换,这个点成功上一个点换成功,这个点成功上一个点换成功,这个点失败上一个点换失败,这个点成功上一个点换失败,这个点也失败 然后方程好复杂的，是：1234567891011121314151617181920212223242526 上一点不换:f[i-1][j-1][0]这一点换1.失败消耗体力: dis[c[i-1]][c[i]] 分析: 由于上一个点不换,所以上一个点一定是在c[]中的;假定这次失败,那么这次也只能去c[]中的教室;2.成功消耗体力: dis[c[i-1]][d[i]]分析: 由于上一个点不换,所以上一个点一定是在c[]中的;假定这次成功,那么这次能去d[]中的教室;那么,失败的概率是1-k[],成功的概率是k[].综上,这种情况就是:f[i-1][j-1][0]+dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1.0-k[i]) 同理,上一点换,这一点换1.上一点失败,这一点失败(以后省一点哈)消耗体力: dis[c[i-1]][c[i]]概率:都失败这运气也没谁了!!!! 概率:(1.0-k[i-1])*(1.0-k[i])2.失败,成功消耗体力: dis[c[i-1]][d[i]]概率 : (1.0-k[i-1])*k[i]3.成功,失败消耗体力 : dis[d[i-1]][c[i]]概率: k[i-1]*(1.0-k[i])4.成功,成功消耗体力: dis[d[i-1]][d[i]] 概率: k[i-1]*k[i] 然后对于不换的方程：12f[i][j][0] = min(f[i-1][j][0]+dis[c[i-1]][c[i]],f[i-1][j][1]+dis[c[i-1]][c[i]]*(1.0-k[i-1])+dis[d[i-1]][c[i]]*k[i-1]) ; 之前需要Floyd预处理一下，然后就好啦(这道题的确比天天爱跑步简单23333)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 2050;const int M = 350;int n , m , v , e;int c[N] , d[N] ;double G[M][M] , f[N][N][2];double k[N];template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;int main ( void ) &#123; scanf ( "%d%d%d%d" , &amp;n , &amp;m , &amp;v , &amp;e ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;c[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;d[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%lf" , &amp;k[i] ); for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) f[i][j][0] = f[i][j][1] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= v ; i++ ) G[i][i] = 0 ; for ( int i = 1 ; i &lt;= e ; i++ ) &#123; int x , y; double z; scanf ( "%d%d%lf" , &amp;x , &amp;y , &amp;z ); if ( G[x][y] &gt; z ) G[x][y] = G[y][x] = z; &#125; for ( int l = 1 ; l &lt;= v ; l++ ) for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = min ( G[i][j] , G[i][l] + G[l][j] ); f[1][0][0] = f[1][1][1] = 0.0000; for ( int i = 2 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= min ( i , m ) ; j++ ) &#123; f[i][j][0] = min ( f[i - 1][j][0] + G[c[i - 1]][c[i]] , f[i - 1][j][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1] ); if(j &gt;= 1) &#123; f[i][j][1] = min ( f[i - 1][j - 1][0] + G[c[i - 1]][d[i]] * k[i] + G[c[i - 1]][c[i]] * ( 1.0 - k[i] ) , f[i - 1][j - 1][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) * ( 1.0 - k[i] ) + G[c[i - 1]][d[i]] *k[i] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1]* ( 1.0 - k[i] ) + G[d[i - 1]][d[i]] * k[i - 1] * k[i] ); &#125; &#125; double ans = 0x7fffffff; for ( int i = 0 ; i &lt;= m ; i++ ) for ( int j = 0 ; j &lt;= 1 ; j++ ) ans = min ( ans , f[n][i][j] ); printf ( "%.2lf\n" , ans ) ; return 0 ;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率入门]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%A6%82%E7%8E%87%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[其实这道初赛题是我第一次做的概率题 我们来看一眼这道毒瘤题： 题面其实已经很清楚了，我们可以发现，当这个青蛙在第$1$块石头时，那么这只青蛙完全可以不用跳，我们设$f(k)$表示这只青蛙在$k$号荷叶上，期望需要$f(k)$次跳到$1$号荷叶，那么我们有： f(1)=0我们接着来考虑当这只青蛙在$2$号荷叶时的情况，它可以跳到$1$号和$2$号荷叶，当它跳到$1$号荷叶时，它完成了任务，跳了一步。当它跳到$2$号时，它还有$f(2)$步，因为每一次跳跃时，跳跃到每一个荷叶上的几率是相等的，所以我们有： f(2)=[1+(1+f(2))]/2同理，我们可以得到： f(3)=[1+(1+f(2))+(1+f(3))]/3推广到一般形式则有: f(k)=[\sum_{i=1}^k{f(i)+1}]/k我们化简一下，有： f(k)=1+\frac {1}{k}\sum_{i=1}^kf(i) 我们看到这个式子：$f(k)=1+\frac {1}{k}\sum_{i=1}^kf(i)$ 当$i==k$的时候,我们会发现式子里出现了一个$f(k)$….. 这咋求啊 我们展开这个式子，会发现原来的式子等价于： f(k)=1+\frac {1}{k}\sum_{i=1}^{k-1}f(i)+\frac 1kf(k)这时候如果把$f(k)$看作一个未知数的话，我们可以发现$f(k)$的这一项是可以合并的。但是我们先两边同乘一个$k$，把分母去掉，就会有： k*f(k)=k+\sum_{i=1}^{k-1}f(i)+f(k)这样答案就很显然了，合并掉等式两边相等的$f(k)$，会得到： (k-1)*f(k)=k+\sum_{i=1}^{k-1}f(i)最后，两边同除$(k-1)$，有最后答案上的公式： f(k)=\frac{k}{k-1}(1+\frac {\sum_{i=1}^{k-1}f(i)}{k-1})通过这个式子计算可以得到$f(5)=\frac{37}{12}$,也就是答案 做完了QAQ(写Markdown好累啊qwq…)因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2015]WIL-Wilcze题解]]></title>
    <url>%2F2018%2F11%2F02%2FPOI2015-WIL-Wilcze%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[其实这本来是$QBXT$的$T2$，但是由于毒瘤$zhw$跑得快（雾），导致我们发现这是某$poi$原题。 首先看题面:题目链接 详细读了一遍之后，其实对于这道题，我的第一反应是贪心（也许是因为我太菜了）。然后打了一遍，小样例过了，然后被大样例$hack$。 之后我又用命分析了一下。可以发现，因为题目中保证每个数的值全部$&gt;=0$，即每个数都是正整数。所以我们与其选长度不到$d$的区间删除，不如直接选择长度为$d$的区间删除。 那么在一段长度已知的序列中，长度为$d$的子序列个数是已知的，那么我们就可以预处理出每一段长度为$d$的子序列。然后我们又发现，题目中要求区间的长度不超过p，那么我们很明显的可以想到尺取法。 然后我们就可以用单调队列来维护我们预处理出的这些长度为$d$的子序列。然后对于区间长度取$max$就是答案了。 最后怒斥一波出原题的出题人$qaq$….(虽然$zhw$很帅) 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;deque&gt;typedef long long ll;using std::deque;const ll N=2000010;ll n,p,d;ll a[N];ll sum[N];ll hea[N];struct Node&#123; ll pos,val; Node(ll pos,ll val):pos(pos),val(val)&#123;&#125; Node()&#123;&#125;&#125;;inline void read(ll &amp;x)&#123; ll s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; x=s*w; return;&#125;deque&lt;Node&gt;q;int main()&#123; read(n);read(p);read(d); for(int i=1;i&lt;=n;i++)read(a[i]),sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n-d;i++) hea[i]=sum[i+d]-sum[i]; for(int i=n-d+1;i&lt;=n;i++) hea[i]=sum[n]-sum[i]; ll ans=0; int l=0; for(int i=d+1;i&lt;=n;i++) &#123; while(!q.empty()&amp;&amp;q.back().val&lt;hea[i-d])q.pop_back(); q.push_back(Node(i-d,hea[i-d])); while(l&lt;i-d&amp;&amp;sum[i]-sum[l]-q.front().val&gt;p) &#123; l++; while(l&gt;q.front().pos)q.pop_front(); &#125; ans=std::max(ans,(ll)i-l); &#125; printf("%lld",ans); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复赛冲刺Day1R1-Color题解]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%A4%8D%E8%B5%9B%E5%86%B2%E5%88%BADay1R1-Colory%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这道题是考试时的$T2$，我感觉这道题出的特别好（虽然当时并不会做 首先看题目:$emmmmm…..$什么鬼啊这个题是$QAQ$ 当时直接一脸懵逼，然后只会写2^n 枚举每一种填充方式，然后再检测的方法…然而这道题这么做只有10分啊$qaq….$ 然后赛后题解告诉我：这题TM是个欧拉回路！！！！当时我就懵逼了….然后当dalao们给我把这道题讲明白了之后，我才发现这道题思路的奇妙。 首先，我们发现，对于一个点，它对应着一个横坐标和一个纵坐标。蒽….一个点对应着两个数值，这个时候我们应该想到什么？二分图？对了，这东西还真的就是要你用二分图的思想来建图….(心态崩了我要妹子$QAQ$) 我们建图，然后我们发现，因为一个点对应着一个横坐标和一个纵坐标，那么我们想到：在二分图中，每一条边也是对应着两种点。那么受到这样的启发，我们就可以建图了：我们把横坐标和纵坐标分别看成一种点，然后将题目中给你的点看成这张图上的边，那么因为题目中要求：黑点和白点的绝对值差不大于1…..，那么我们能想到什么呢？我们要对这些边进行黑白染色，所以我们要一个点出发，一直走一条欧拉回路，这样能走遍所有的边。 但是这样做，我们会发现一个问题：只有$subtask4$的$30$分数据告诉你是偶数。而存在欧拉回路的图的特点是什么呢？每个点的度数都是偶数，那么当点的度数是奇数的时候，我们怎么办呢？ 我在这里选择了度数为奇数的点向一个虚拟节点连边，然后当所有点的度数都是偶数时，这时候没有其他点向这个点连边所以这时候这个虚拟节点对答案没有影响。 然后，我们就直接对边进行染色就可以了。 我只想说，这道题出的真的好，佩服出题人。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt; const int N = 5e5 + 10; struct Data &#123; int v; int p;&#125;data[N];struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int n , m , t = 1 , num;int head[N] , d[N];int x[N] , y[N] , ans[N];bool flag[N]; inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline bool cmp ( Data x , Data y ) &#123; return x.v&lt;y.v;&#125;void lisanhua () &#123; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = x[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; x[data[i].p] = num; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = y[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; y[data[i].p] = num; &#125; return;&#125;void dfs ( int cur , bool last ) &#123; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; if ( flag[i &gt;&gt; 1] ) continue; int j = e[i].to; flag[i &gt;&gt; 1] = 1; d[cur]--; d[j]--; ans[i &gt;&gt; 1] = !last; dfs ( j , !last ); &#125; return;&#125; int main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; x[i] = read (); y[i] = read (); &#125; lisanhua(); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; d[x[i]]++; d[y[i]]++; add ( x[i] , y[i] ); add ( y[i] , x[i] ); &#125; for ( int i = 1 ; i &lt;= num ; i++ ) if ( d[i] &amp; 1 ) &#123; d[i]++; d[num + 1]++; add ( i , num + 1 ); add ( num + 1 , i ); &#125; num++; memset ( ans , -1 , sizeof ( ans ) ); for ( int i = 1 ; i &lt;= num ; i++ ) while ( d[i] ) dfs ( i , 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , ans[i] , i == n ? '\n' : ' ' ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复赛冲刺Day1R1-Count题解]]></title>
    <url>%2F2018%2F11%2F01%2FqbxtD1T1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[其实我感觉这道数论题还是挺简单的（虽然我不会） 这道数论题，我初看的时候是挺一脸懵逼的，然后据$wucstdio$大爷提供的思路，我们可以发现：题意求的是$x$,$y$在$mod P$下的逆元，存在解的条件是$gcd(x,p)==1$，即x,p互质。所以由题解有设 1 到 P − 1 中与 P 互质的数有 s 个，考虑这 s 个数与它们的逆元组成的二元组，这些二元组一定符合条件，那么只要考虑去重的问题 所以我们只需要知道从$1$到$n$中和$n$互质的数的个数这个东西是什么呢？这个东西很明显是$phi$函数。所以我们只需要求出$\phi(p)$，再加上$x^2\equiv1\pmod{p}$的数，最后除$2$就好了。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e7 + 10;int n;int tot , prime[N] , phi[N];bool flag[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); flag[1] = 1; phi[1] = 1; for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; prime[++tot] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] *prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; long long ans = phi[n]; for ( long long i = 1 ; i &lt;= n ; i++ ) if ( i * i % n == 1 ) ans++; printf ( "%lld\n" , ( long long ) ( ans ) / 2 ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A*学习笔记]]></title>
    <url>%2F2018%2F10%2F19%2FA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[例题：$LuoguP2324$:骑士精神 $A*$嘛，很早时候就听说过，貌似是一种很神奇的算法。听长者讲过一遍，一直都想自己打一遍。但是一直没机会。所以来自己写一遍就好啦。 $A*$的重点就是一个叫做估价函数的东西，但是这个叫估价函数的东西你必须要好好写，不然你会搜出来$WA$的好成绩对于这道题，我就是将现在的棋盘和目标棋盘不同棋子数的差当作估价函数（其实是正确的)。然后，我们就可以加一个类似于剪枝的东西：如果现在的步数$+$估价函数估计的值$&gt;$现在的$max$，直接$return$就好。剩下的东西就是个大爆搜了， 以下是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int goal[7][7] = &#123; &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;, &#123; 0 , 1 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 2 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;&#125;;char mp[6][6];int now[6][6];bool flag;int dx[] = &#123; 0 , 1 , 1 , -1 , -1 , 2 , 2 , -2 , -2 &#125;;int dy[] = &#123; 0 , 2 , -2 , 2 , -2 , 1 , -1 , 1 , -1 &#125;;inline int calcu () &#123; int tmp = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) &#123; if ( now[i][j] != goal[i][j] ) tmp++; &#125; return tmp;&#125;inline void swap ( int &amp;x , int &amp;y ) &#123; int t = x; x = y; y = t; return;&#125;void A_Star ( int x , int y , int dep , int MaxStep ) &#123; if ( flag ) return; if ( dep == MaxStep ) &#123; if ( calcu () == 0 ) &#123; flag = 1; printf ( "%d\n" , MaxStep ); return; &#125; return; &#125; for ( int i = 1 ; i &lt;= 8 ; i++ ) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if ( xx &gt; 5 || xx &lt; 1 || yy &gt; 5 || yy &lt; 1 ) continue; swap ( now[x][y] , now[xx][yy] ); if ( calcu () + dep &lt;= MaxStep ) A_Star ( xx , yy , dep + 1 , MaxStep ); swap ( now[x][y] , now[xx][yy] ); &#125; return;&#125;int main ( void ) &#123; int ttt; scanf ( "%d" , &amp;ttt ); while ( ttt-- ) &#123; flag = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) scanf ( "%s" , mp[i] + 1 ); int st_x , st_y; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) if ( mp[i][j] == '*' ) &#123; st_x = i; st_y = j; now[i][j] = 2; &#125; else now[i][j] = mp[i][j] - '0'; if ( calcu () == 0 ) &#123; puts ( "0" ); return 0; &#125; for ( int i = 1 ; i &lt;= 15 ; i++ ) if ( !flag ) A_Star ( st_x , st_y , 0 , i ); if ( !flag ) puts ( "-1" ); &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wucstdio的毒瘤模拟赛]]></title>
    <url>%2F2018%2F10%2F18%2Fwucstdio%E7%9A%84%E6%AF%92%E7%98%A4%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[$wucstdio$大爷的Flag还是没有倒…. T1: 反正我刚开始对这道题是完全没有什么信心的qaq（才不会告诉你我直接去看的$T2$） 考虑$50$分的情况：一条链。所以就是一个等差数列了qwq 考虑剩余的正解，我们可以把每一步的期望值当成这棵树的权值，然后因为从上向下和从下向上的期望值可能不太一样，所以我们需要两个函数来表示：（相当于两条边）。 我们设$f(x) g(x)$分别表示从下向上和从上向下的情况，所以我们考虑求出$f(x)$时，我们要考虑以下情况： 直接走到这个节点的父节点，所以这种情况下，对这个节点对答案的贡献就是$\frac {1}{d[x]}了$ 还有一种情况就是这个节点先跳到他的儿子，再跳回这个节点，再跳过去。这个时候，因为我们需要一步来跳过去，所以这种情况对答案的贡献就是:$\sum_{j=son} \frac {1}{d[x]}[1 + f(x) + f(j) ]$ 我们综合考虑一下这两种情况对答案的贡献值，将这两个式子加起来，我们就会得到下边的这个式子： f(x) = \frac{1}{d} + \sum_{j=son}\frac{1}{d}\times[1 +f(x) + f ( j )]我们安置我们做期望的一贯思路（好像我做过多少期望一样QwQ），因为$num[son]=p-1$，所以我们可以得到这样一个式子： d\times f(x)=1+d-1+(d-1)f(x)+\sum_{j}f(j)化简一下之后有： f(x)=d+\sum_{j}f(j)然后我们来考虑一下$g(x)$这个东西怎么求，当我们经过观察之后，我们可以发现这个式子有三种情况： 他的父亲直接跳到他这里，这种情况对答案的贡献就是$\frac{1}{d[father]}$ 他的父亲先跳到他的爷爷，然后再跳回来，这种情况下，对答案的贡献就是：$\frac{1}{d[father]}\times (1 + g(p) +g(x) )$ 他的父亲跳到他的兄弟然后再跳到他自己。 我们把这三种情况加起来，就会有： g(x)=\dfrac {1}{d[father]} \times(1+g(p)+g(x))+\dfrac {1}{d[father]}+\sum_{pa_j=pa_x\&\&j\not=x}\dfrac {1}{d[father]} (1+f(j)+g(x))继续化简有： g(x)=g(p)+f(p)-f(x)通过这种方式，我们就可以把$g(x) f(x)$算出来，相当于边长。 算出边长后，这个问题就转化成了：给你一颗树，求树的直径。我选择了DP求直径，就很简单了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;const int N = 2e5 + 10;int n , m , t;struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int head[N];int now_ans;int f[N] , g[N] , p[N];int LongDis[N][2] , SecondDis[N][2];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline int min ( int x , int y ) &#123; return x &lt; y ? x : y;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;void Find_f ( int root , int fa ) &#123; f[root] = p[root]; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Find_f ( j , root ); f[root] += f[j]; &#125; return;&#125;void Find_g ( int root , int fa ) &#123; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; g[j] = f[root] + g[root] - f[j]; Find_g ( j , root ); &#125; return;&#125;void Work ( int root , int fa ) &#123; int Frist = 0 , Second = 0; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Work ( j , root ); if ( LongDis[j][0] + g[j] &gt; LongDis[root][0] ) &#123; SecondDis[root][0] = LongDis[root][0]; LongDis[root][0] = LongDis[j][0] + g[j]; Frist = j; &#125; else if ( LongDis[j][0] + g[j] &gt; SecondDis[root][0] ) SecondDis[root][0] = LongDis[j][0] + g[j]; if ( LongDis[j][1] + f[j] &gt; LongDis[root][1] ) &#123; SecondDis[root][1] = LongDis[root][1]; LongDis[root][1] = LongDis[j][1] + f[j]; Second = j; &#125; else if ( LongDis[j][1] + f[j] &gt; SecondDis[root][1] ) SecondDis[root][1] = LongDis[j][1] + f[j]; &#125; if ( Frist != Second ) now_ans = max ( LongDis[root][0] + LongDis[root][1] , now_ans ); else if ( Frist == Second ) now_ans = max ( now_ans , max ( SecondDis[root][1] + LongDis[root][0] , SecondDis[root][0] + LongDis[root][1] ) ); return;&#125;int main ( void ) &#123; freopen ( "tree.in" , "r" , stdin ); freopen ( "tree.out" , "w" , stdout ); n = read (); for ( int i = 1 ; i &lt; n ; i++ ) &#123; int x = read () , y = read (); add ( x , y ); add ( y , x ); p[x]++; p[y]++; &#125; Find_f ( 1 , 0 ); Find_g ( 1 , 0 ); Work ( 1 , 0 ); printf ( "%d.00000\n" , now_ans ); return 0;&#125; T2:其实暴力还是挺显然的 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前排打出题人的一套题]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%89%8D%E6%8E%92%E6%89%93%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E4%B8%80%E5%A5%97%E9%A2%98%2F</url>
    <content type="text"><![CDATA[不管怎么样，先打死出题人再说qaq… T1:人贩子$LLFZ$ 题意很显然就是最优贸易啊…. 一眼看出来是缩点+DP….但是为什么我之前是SPFA过的啊QAQ…写SPFA比较稳….然后….就写了…. 上代码吧…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int N = 1e5 + 10;const int M = 1e6 + 10;const int INF = 2147483647;#define G(i,a,b,c) for ( int i = b[a] ; i ; i = c[i].next )int n , m , t , cnt;struct Edge &#123; int to; int data; int next;&#125;e[M] , e_[M];int head[N] , head_[N];int maxs[N] , mins[N];int dis[N] , value[N];bool inque[N];std :: queue &lt; int &gt; qu;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void add_ ( int x , int y , int z ) &#123; e_[++cnt].to = y; e_[cnt].data = z; e_[cnt].next = head_[x]; head_[x] = cnt; return;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;void Heap_Dijkstra () &#123; std :: memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[1] = 1 , dis[1] = value[1]; qu.push ( 1 ); while ( !qu.empty () ) &#123; int j = qu.front (); inque[j] = 0; qu.pop (); G ( i , j , head , e ) &#123; int k = e[i].to; if ( dis[k] &gt; min ( dis[j] , e[i].data ) ) &#123; dis[k] = min ( dis[j] , e[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) mins[i] = dis[i]; std :: memset ( dis , -0x3f3f3f3f , sizeof ( dis ) ); inque[n] = 1 , dis[n] = value[n]; qu.push ( n ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; G ( i , j , head_ , e_ ) &#123; int k = e_[i].to; if ( dis[k] &lt; max ( dis[j] , e_[i].data ) ) &#123; dis[k] = max ( dis[j] , e_[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) maxs[i] = dis[i]; return;&#125; int main ( void ) &#123; freopen ( "child.in" , "r" , stdin ); freopen ( "child.out" , "w" , stdout ); n = read (); m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) value[i] = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); if ( z == 1 ) &#123; add ( x , y , value[y] ); add_ ( y , x , value[x] ); &#125; else if ( z == 2 ) &#123; add ( x , y , value[y] ); add ( y , x , value[x] ); add_ ( y , x , value[x] ); add_ ( x , y , value[y] ); &#125; &#125; Heap_Dijkstra (); int ans = -INF; for ( int i = 1 ; i &lt;= n ; i++ ) ans = max ( ans , maxs[i] - mins[i] ); printf ( "%d\n" , ans ); return 0;&#125; T2 : food 再来拿出题人祭天祭一波… 话说我直接读题读错了然后写了个错误的DP然后还A了是什么鬼啊…. 话说我考虑了前缀和，那么我还过了，说明直接加起来然后除就可以? 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int N = 15;int n , ans = -1;int A , B , C;int p1 , p2 , p3;int MaxTime[N];int f[N][105][105][105];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;int main ( void ) &#123; freopen ( "food.in" , "r" , stdin ); freopen ( "food.out" , "w" , stdout ); A = read () , B = read () , C = read (); p1 = read () , p2 = read () , p3 = read (); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; MaxTime[i] = read (); MaxTime[i] = MaxTime[i - 1] + MaxTime[i]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = A ; j * p1 &lt;= MaxTime[i] &amp;&amp; j&lt;=100 ; j++ ) for ( int k = B; j * p1 + k * p2 &lt;= MaxTime[i] &amp;&amp; k &lt;= 100 ; k++ ) for ( int l = C ; j * p1 + k * p2 + l * p3 &lt;= MaxTime[i] &amp;&amp; l &lt;=100 ; l++ ) &#123; f[i][j][k][l] = max ( f[i][j][k][l] , max ( f[i - 1][j - A][k - B][l - C] + 1 , f[i][j - A][k - B][l - C] + 1 ) ); ans = max ( ans , f[i][j][k][l] ); &#125; printf ( "%d\n" , ans ); return 0;&#125; T3: Happy 再吐槽一波为什么Noip模拟赛会考离散对数（然而我并不会….） 其实应该是一道签到题吧。。。 暴力水过…. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int P , A , B;bool app[50005];int main ( void ) &#123; freopen ( "happy.in" , "r" , stdin ); freopen ( "happy.out" , "w" , stdout ); int T = read (); while ( T-- ) &#123; int now = 1; memset ( app , false , sizeof ( app ) ); P = read () , A = read () , B = read (); for ( int i = 1 ; ; i++ ) &#123; now = ( now * A ) % P; if ( now == B ) &#123; printf ( "%d\n" , i ); break; &#125; if ( app[now] ) &#123; puts ( "Couldn't Produce!" ); break; &#125; app[now] = 1; &#125; &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My_Code_Style]]></title>
    <url>%2F2018%2F10%2F13%2FMy_Code_Style%2F</url>
    <content type="text"><![CDATA[介绍下本蒟蒻的丑死的码风$qwq$…(码风大概是魔改了神犇$Menci$的) 在打CF时并不是这个码风 码风概述： 所有的#include后必须有一个空格,例如#include 无论什么样子的程序，都必须写cstdio cstring algorithm iostream这四个头文件。 在主程序的int main()中要加$void$，即为int main(void) 一般不写using namespace std; 所有的变量必须定义在第一个自定义函数之前，且变量和第一个自定义函数，最后一个自定义函数和$main$之间必须有一个换行 每个函数之后尽可能有$return$， 在一般情况下，在花括号内的内容不加逗号 缩进： 对于每个代码块，使用4空格或者等长的Tab缩进。 括号： 大括号不换行 空格： 个人感觉自己的空格比较的毒瘤。 1.在每个函数声明时，函数名后的括号与函数名之间必须有一个空格,而且括号内如果需要声明变量，则要先有一个空格，且逗号的前后都必须有一个空格。 2.在for循环的声明中，每一个字符（变量名除外），都要用空格隔开。 3.数组内一般不加空格，但是如果有运算符则运算符前后必须有空格。 4.每个可以前后匹配的括号前后必须有空格。 变量： 1.基本所有变量都是全局变量，但有些ans,sum最后统计答案时使用的变量可以定义为局部变量。 2.所有的变量名称都必须与要存储的东西的中文意思有沾边，比如树直接定义为tree而不是T。（极度不能容忍变量名直接为a,b,c,d,e,f,g,的情况。 3.定义N,M等时一般只用N,M为名称而不是MAXN,MAXM. 4.定义的结构体类型在定义变量时必须紧接着声明完成结构体后，并且结构体中变量需要定义一个加一个换行。 5.在变量命名时较长的变量名可以用_来连接，并且大小写交替使用，如Add_Tree_Val 把上边所有毒瘤的码风结合起来之后代码大概长这个样子qwq.. update:还是加上模板舒服qwq 不要吐槽我的丑逼$Splay…..$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register inttemplate &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt;typename T&gt; void write(T x) &#123;if (x &lt; 0) x = -x, putchar('-');if (x &gt; 9) write(x / 10);putchar(x % 10 + 48);return;&#125;template &lt;typename T&gt; void writeln(T x) &#123; write(x); printf ("\n"); &#125;/**********************************************************************************************************************************************************************************************************************************************************************/const int N = 1e6 + 5;int root , tot , n;struct Tree &#123; int ch[2]; int val; int father; int size; int cnt;&#125;tree[N];void pushup ( int cur ) &#123; tree[cur].size = tree[tree[cur].ch[0]].size + tree[tree[cur].ch[1]].size + tree[cur].cnt; return;&#125;void rotate ( int x ) &#123; int y = tree[x].father; int z = tree[y].father; int k = tree[y].ch[1] == x; tree[z].ch[tree[z].ch[1] == y] = x; tree[x].father = z; tree[y].ch[k] = tree[x].ch[k ^ 1]; tree[tree[x].ch[k ^1]].father = y; tree[x].ch[k ^ 1] = y; tree[y].father = x; pushup ( x ); pushup ( y ); return;&#125;void Splay ( int x , int goal ) &#123; while ( tree[x].father != goal ) &#123; int y = tree[x].father; int z = tree[y].father; if ( z != goal ) ( tree[y].ch[0] == x ) ^ ( tree[z].ch[0] == y ) ? rotate ( x ) : rotate ( y ); rotate ( x ); &#125; if ( goal == 0 ) root = x; return;&#125;void insert ( int x ) &#123; int cur = root , father = 0; while ( cur &amp;&amp; tree[cur].val != x ) &#123; father = cur; cur = tree[cur].ch[x &gt; tree[cur].val]; &#125; if ( cur ) tree[cur].cnt++; else &#123; cur = ++tot; if ( father ) tree[father].ch[x &gt; tree[father].val] = cur; tree[cur].ch[0] = tree[cur].ch[1] = 0; tree[cur].father = father; tree[cur].val = x; tree[cur].cnt = 1; tree[cur].size = 1; &#125; Splay ( cur , 0 ); return;&#125;void Find ( int x ) &#123; int cur = root; if ( !cur ) return; while ( tree[cur].ch[x &gt; tree[cur].val] &amp;&amp; x != tree[cur].val ) cur = tree[cur].ch[ x &gt; tree[cur].val]; Splay ( cur , 0 ); return;&#125;int Next ( int x , int f )&#123; Find ( x ); int cur = root; if ( tree[cur].val &gt; x &amp;&amp; f ) return cur; if ( tree[cur].val &lt; x &amp;&amp; !f ) return cur; cur = tree[cur].ch[f]; while ( tree[cur].ch[f ^ 1] ) cur = tree[cur].ch [f ^ 1]; return cur;&#125;void Delete ( int x ) &#123; int last = Next ( x , 0 ); int next = Next ( x , 1 ); Splay ( last , 0 ); Splay ( next , last ); int del = tree[next].ch[0]; if ( tree[del].cnt &gt; 1 ) &#123; tree[del].cnt--; Splay ( del , 0 ); &#125; else tree[next].ch[0] = 0; return;&#125;int kth ( int x ) &#123; int cur = root; if ( tree[cur].size &lt; x ) return 0; while ( 1 ) &#123; int y = tree[cur].ch[0]; if ( x &gt; tree[y].size + tree[cur].cnt ) &#123; x -= tree[y].size + tree[cur].cnt; cur = tree[cur].ch[1]; &#125; else if ( tree[y].size &gt;= x ) cur = y; else return tree[cur].val; &#125;&#125;int main ( void ) &#123; n = read (); insert ( 2147483647 ); insert ( -2147483647 ); while ( n-- ) &#123; int opt = read (); if ( opt == 1 ) &#123; int x = read (); insert ( x ); &#125; else if ( opt == 2 ) &#123; int x = read (); Delete ( x ); &#125; else if ( opt == 3 ) &#123; int x = read (); Find ( x ); printf ( "%d\n" , tree[tree[root].ch[0]].size ); &#125; else if ( opt == 4 ) &#123; int x = read (); printf ( "%d\n" , kth ( x + 1 ) ); &#125; else if ( opt == 5 ) &#123; int x = read (); printf ( "%d\n" , tree[Next ( x , 0 )].val ); &#125; else if ( opt == 6 ) &#123; int x = read (); printf ( "%d\n" , tree[Next ( x , 1 )].val ); &#125; &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeStyle</tag>
      </tags>
  </entry>
</search>
