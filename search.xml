<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA['wucstdio的毒瘤模拟赛']]></title>
    <url>%2F2018%2F10%2F18%2Fwucstdio%E7%9A%84%E6%AF%92%E7%98%A4%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"></content>
      <tags>
        <tag>模拟赛心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['前排打出题人的一套题']]></title>
    <url>%2F2018%2F10%2F17%2F%E5%89%8D%E6%8E%92%E6%89%93%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E4%B8%80%E5%A5%97%E9%A2%98%2F</url>
    <content type="text"><![CDATA[不管怎么样，先打死出题人再说qaq… T1:人贩子$LLFZ$ 题意很显然就是最优贸易啊…. 一眼看出来是缩点+DP….但是为什么我之前是SPFA过的啊QAQ…写SPFA比较稳….然后….就写了…. 上代码吧…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int N = 1e5 + 10;const int M = 1e6 + 10;const int INF = 2147483647;#define G(i,a,b,c) for ( int i = b[a] ; i ; i = c[i].next )int n , m , t , cnt;struct Edge &#123; int to; int data; int next;&#125;e[M] , e_[M];int head[N] , head_[N];int maxs[N] , mins[N];int dis[N] , value[N];bool inque[N];std :: queue &lt; int &gt; qu;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void add_ ( int x , int y , int z ) &#123; e_[++cnt].to = y; e_[cnt].data = z; e_[cnt].next = head_[x]; head_[x] = cnt; return;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;void Heap_Dijkstra () &#123; std :: memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[1] = 1 , dis[1] = value[1]; qu.push ( 1 ); while ( !qu.empty () ) &#123; int j = qu.front (); inque[j] = 0; qu.pop (); G ( i , j , head , e ) &#123; int k = e[i].to; if ( dis[k] &gt; min ( dis[j] , e[i].data ) ) &#123; dis[k] = min ( dis[j] , e[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) mins[i] = dis[i]; std :: memset ( dis , -0x3f3f3f3f , sizeof ( dis ) ); inque[n] = 1 , dis[n] = value[n]; qu.push ( n ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; G ( i , j , head_ , e_ ) &#123; int k = e_[i].to; if ( dis[k] &lt; max ( dis[j] , e_[i].data ) ) &#123; dis[k] = max ( dis[j] , e_[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) maxs[i] = dis[i]; return;&#125; int main ( void ) &#123; freopen ( "child.in" , "r" , stdin ); freopen ( "child.out" , "w" , stdout ); n = read (); m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) value[i] = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); if ( z == 1 ) &#123; add ( x , y , value[y] ); add_ ( y , x , value[x] ); &#125; else if ( z == 2 ) &#123; add ( x , y , value[y] ); add ( y , x , value[x] ); add_ ( y , x , value[x] ); add_ ( x , y , value[y] ); &#125; &#125; Heap_Dijkstra (); int ans = -INF; for ( int i = 1 ; i &lt;= n ; i++ ) ans = max ( ans , maxs[i] - mins[i] ); printf ( "%d\n" , ans ); return 0;&#125; T2 : food 再来拿出题人祭天祭一波… 话说我直接读题读错了然后写了个错误的DP然后还A了是什么鬼啊…. 话说我考虑了前缀和，那么我还过了，说明直接加起来然后除就可以? 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int N = 15;int n , ans = -1;int A , B , C;int p1 , p2 , p3;int MaxTime[N];int f[N][105][105][105];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;int main ( void ) &#123; freopen ( "food.in" , "r" , stdin ); freopen ( "food.out" , "w" , stdout ); A = read () , B = read () , C = read (); p1 = read () , p2 = read () , p3 = read (); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; MaxTime[i] = read (); MaxTime[i] = MaxTime[i - 1] + MaxTime[i]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = A ; j * p1 &lt;= MaxTime[i] &amp;&amp; j&lt;=100 ; j++ ) for ( int k = B; j * p1 + k * p2 &lt;= MaxTime[i] &amp;&amp; k &lt;= 100 ; k++ ) for ( int l = C ; j * p1 + k * p2 + l * p3 &lt;= MaxTime[i] &amp;&amp; l &lt;=100 ; l++ ) &#123; f[i][j][k][l] = max ( f[i][j][k][l] , max ( f[i - 1][j - A][k - B][l - C] + 1 , f[i][j - A][k - B][l - C] + 1 ) ); ans = max ( ans , f[i][j][k][l] ); &#125; printf ( "%d\n" , ans ); return 0;&#125; T3: Happy 再吐槽一波为什么Noip模拟赛会考离散对数（然而我并不会….） 其实应该是一道签到题吧。。。 暴力水过…. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int P , A , B;bool app[50005];int main ( void ) &#123; freopen ( "happy.in" , "r" , stdin ); freopen ( "happy.out" , "w" , stdout ); int T = read (); while ( T-- ) &#123; int now = 1; memset ( app , false , sizeof ( app ) ); P = read () , A = read () , B = read (); for ( int i = 1 ; ; i++ ) &#123; now = ( now * A ) % P; if ( now == B ) &#123; printf ( "%d\n" , i ); break; &#125; if ( app[now] ) &#123; puts ( "Couldn't Produce!" ); break; &#125; app[now] = 1; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模拟赛心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[My_Code_Style]]></title>
    <url>%2F2018%2F10%2F13%2FMy_Code_Style%2F</url>
    <content type="text"><![CDATA[介绍下本蒟蒻的丑死的码风$qwq$…(码风大概是魔改了神犇$Menci$的) 在打CF时并不是这个码风 码风概述： 所有的#include后必须有一个空格,例如#include 无论什么样子的程序，都必须写cstdio cstring algorihtm iostream这四个头文件。 在主程序的int main()中要加void，即为int main(void) 一般不写using namespace std; 所有的变量必须定义在第一个自定义函数之前，且变量和第一个自定义函数，最后一个自定义函数和$main​$之间必须有一个换行 每个函数之后尽可能有$return$， 在一般情况下，在花括号内的内容不加逗号 缩进： 对于每个代码块，使用4空格或者等长的Tab缩进。 括号： 大括号不换行 空格： 个人感觉自己的空格比较的毒瘤。 1.在每个函数声明时，函数名后的括号与函数名之间必须有一个空格,而且括号内如果需要声明变量，则要先有一个空格，且逗号的前后都必须有一个空格。 2.在for循环的声明中，每一个字符（变量名除外），都要用空格隔开。 3.数组内一般不加空格，但是如果有运算符则运算符前后必须有空格。 4.每个可以前后匹配的括号前后必须有空格。 代码大概长这样… 1234567891011121314151617struct wqwqwqwqwq &#123; int qwwq; int qwq;&#125;wwq;void qweqweqweq ( wqwqwqwq x , qwqwqwqwqwq y ) &#123; qweqweqweqweqweqweqweqwe; if ( qweqweqweqweqwe ) &#123; qewqweqweqweqweq; qweqweqweqweq; &#125; else &#123; qweqweqweqweq; qweqweqwrreeqwqqwe; qweqewqweqweqewq; &#125; return;&#125; 变量： 1.基本所有变量都是全局变量，但有些ans,sum最后统计答案时使用的变量可以定义为局部变量。 2.所有的变量名称都必须与要存储的东西的中文意思有沾边，比如树直接定义为tree而不是T。（极度不能容忍变量名直接为a,b,c,d,e,f,g,的情况。 3.定义N,M等时一般只用N,M为名称而不是MAXN,MAXM. 4.定义的结构体类型在定义变量时必须紧接着声明完成结构体后，并且结构体中变量需要定义一个加一个换行。 5.在变量命名时较长的变量名可以用_来连接，并且大小写交替使用，如$Add_Tree_Val$ 把上边所有毒瘤的码风结合起来之后代码大概长这个样子qwq.. 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int N = 1005;const int M = 100005;int n , m , s , t;int l , r;struct Node &#123; int l; int r; int sum;&#125;tree[N &lt;&lt; 2];int main ( void ) &#123; std :: memset ( tree , 0 , sizeof ( tree ) ); scanf ( "%d%d" , &amp;n , &amp;m ); printf ( "%d\n" , n + m ); for ( int i = 1 ; i &lt;= n ; i++ ) m += i; if ( n + m &lt;= m + n ) &#123; puts ( "HA" ); return 0; &#125; else &#123; puts ( "AH" ); return 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>CodeStyle</tag>
      </tags>
  </entry>
</search>
