<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SCP-114514]]></title>
    <url>%2F2019%2F09%2F23%2FSCP1%2F</url>
    <content type="text"><![CDATA[qwq SCP-114514 研究社 等级: Keter 特殊收容措施: 目前SCP-114514无法被收容,目前基金会的目的是使SCP-114514保持不再发生变化. 项目描述: 已知SCP-114514曾经的名称有信息学,OI,国际象棋,围棋,五子棋,羽毛球,篮球,OSU,植物大战僵尸,外卖K歌研究社.已知项目会在随机的时间进行名称上的变化.目前已经证实,在每次项目的名称发生改变时,项目内的人员(称之为$SCP-114514-1919810$)的兴趣爱好会随着研究社的名称发生变化. 经过研究发现,SCP-114514内的人员爱好需要的物件似乎并不需要从外界获取,会有一个被称为$SCP-114514-1$的被称为$Z$主任的人形实体供给,而供给的物品似乎是从内部自然产生的. 在每次项目的名称发生改变时,会强制将项目周边距离不超过$10m$的人员强制转化为$SCP-114514-1919810$,已知这一影响不可逆.而且在普通人员被强制转化后,会在[数据删除]的时间之内丧失对文化课学习的兴趣. 常人暴露在SCP-114514面前是致命的,所以对于SCP-114514的任何接触需要3名及以上四级权限者的允许,且实验者在实验后将被强制隔离$3$天,如果在隔离时间之内实验者表现了明显的兴趣爱好变化,那么实验者将会被处决. 对于SCP-114514的进一步研究报告为致命媒介模因,需要得到O5议会的批准之后访问. 您好,监督者,已取消对机动特遣队的派遣指令.]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>SCP乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #587题解]]></title>
    <url>%2F2019%2F09%2F22%2FCodeforcesRound-587%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[LYT我对不起你啊/ll Prefixes经过观察私信找规律之后发现,对于每个偶数的前缀$i$,如果$i&gt;2$且$i$这个前缀满足条件,那么$i/2$也一定会满足条件.所以我们要满足的就是对于每个最小的间隔为$2$的区间,使他们当中有一个$a$和一个$b$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 2e5 + 10; int n , ans;char ss[N]; int main() &#123; read ( n ); scanf ( "%s" , ss + 1 ); int s1 = 0 , s2 = 0; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( ss[i] == 'a' ) s1++; else s2++; if ( i % 2 == 0 ) &#123; if ( s1 == s2 ) continue; ans++; if ( s1 &gt; s2 ) ss[i] = 'b'; else ss[i] = 'a'; s1 = 0; s2 = 0; &#125; &#125; writeln ( ans ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%c" , ss[i] ); return 0; &#125; Shooting通过观察样例可知,从大到小排序即可qwq… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 1005; int n;struct Node &#123; int val; int pos;&#125;ls[N]; ll ans; inline bool cmp ( Node x , Node y ) &#123; return x.val &gt; y.val;&#125; int main() &#123; read ( n ); F ( i , 1 , n ) &#123; ls[i].val = _read (); ls[i].pos = i; &#125; std :: sort ( ls + 1 , ls + 1 + n , cmp ); F ( i , 1 , n ) ans += ls[i].val * ( i - 1 ) + 1; writeln ( ans ); F ( i , 1 , n ) printf ( "%d " , ls[i].pos ); return 0; &#125; White Sheet发现如果这个白色矩形的四条边都被覆盖了的话,那么中间一定也被覆盖了.然后暴力枚举判断即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ struct Point&#123; int x; int y;&#125;p[7];int main ( void )&#123; for(int i=1;i&lt;=6;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); if(p[3].x&lt;=p[1].x&amp;&amp;p[3].y&lt;=p[1].y&amp;&amp;p[4].x&gt;=p[2].x&amp;&amp;p[4].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[5].x&lt;=p[1].x&amp;&amp;p[5].y&lt;=p[1].y&amp;&amp;p[6].x&gt;=p[2].x&amp;&amp;p[6].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[3].x&lt;=p[1].x&amp;&amp;p[4].x&gt;=p[2].x&amp;&amp;p[5].x&lt;=p[1].x&amp;&amp;p[6].x&gt;=p[2].x)&#123; if(p[3].y&lt;=p[1].y&amp;&amp;p[4].y&gt;=p[5].y&amp;&amp;p[6].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; if(p[5].y&lt;=p[1].y&amp;&amp;p[6].y&gt;=p[3].y&amp;&amp;p[4].y&gt;=p[2].y)&#123; printf("NO\n"); return 0; &#125; &#125; if(p[3].y&lt;=p[1].y&amp;&amp;p[4].y&gt;=p[2].y&amp;&amp;p[5].y&lt;=p[1].y&amp;&amp;p[6].y&gt;=p[2].y)&#123; if(p[3].x&lt;=p[1].x&amp;&amp;p[4].x&gt;=p[5].x&amp;&amp;p[6].x&gt;=p[2].x)&#123; printf("NO\n"); return 0; &#125; if(p[5].x&lt;=p[1].x&amp;&amp;p[6].x&gt;=p[3].x&amp;&amp;p[4].x&gt;=p[2].x)&#123; printf("NO\n"); return 0; &#125; &#125; printf("YES\n"); return 0;&#125; Swords发现求个$gcd$就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next) inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/ const int N = 2e5 + 10; int n , maxs;int num[N];ll ans , sum; int main() &#123; read ( n ); F ( i , 1 , n ) &#123; num[i] = _read (); maxs = max ( maxs , num[i] ); &#125; F ( i , 1 , n ) &#123; int res = ( maxs - num[i] ); ans = std :: __gcd ( ans , res * 1ll ); &#125; if ( ans == 0 ) &#123; puts ( "0 0" ); return 0; &#125; else &#123; F ( i , 1 , n ) sum += ( maxs - num[i] ) / ans; printf ( "%I64d %I64d\n" , sum , ans ); &#125; return 0; &#125; Numerical Sequence (easy version)发现$k$只有$10^9$的范围,所以就暴力跳就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std; #define LL long long#define N 40010 LL sum[N],T; int judge(int x) &#123; int count = (int)log10((double)x) + 1; return count;&#125;int fun(int x) &#123; int sum = pow(10,x); return sum;&#125;void solve() &#123; int sumn = 0; memset(sum, 0,sizeof(sum)); for(int i = 1 ; i &lt; 40005 ; ++i) &#123; sumn += judge(i); sum[i] = sum[i - 1] +sumn; &#125;&#125;void answer(int x) &#123; int j,ans,summ,i = 1; while(sum[i] &lt; x) i++; ans = x - sum[i -1]; summ = 0; for(j = 1 ; j &lt;= i ; ++j) &#123; summ += judge(j); if(summ &gt;= ans) break; &#125; if(summ == ans) printf("%d\n", j %10); if(summ &gt; ans) printf("%d\n", (j / fun(summ -ans)) % 10);&#125; int main() &#123; scanf("%lld",&amp;T); solve(); while(T--) &#123; int pos; scanf("%d",&amp;pos); answer(pos); &#125; //system("pause"); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Codeforces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普转提七连测D3]]></title>
    <url>%2F2019%2F09%2F22%2FP%E8%BD%ACTD3%2F</url>
    <content type="text"><![CDATA[你一定知道密码趴 Incorrect Password! No content to display! U2FsdGVkX1/K9cCms8Zr2QtH25aOuYCG5UhN44nq5CEeN1F/vlVTV+BH3wTVGHSQ+Eo8YBrIwI2qDSzKASYYJOwwCVjk84Zpv2atXZMM3Lxl+8z16DKSXC0stgTxM4O2wBQlfVKyIsxV4vw0BiTh47CAYjZor/drpsAmVTitThEHzFCo07PdnhaZmD2N8bHbKxECSnp/i+GpyKkhODYvtq74agj0FGwGyexVP+evaCmOsL6a54oTd4X2wrU7nxuBHiECD0vPnaUFu0qF4HU1B/w6/kN4Tu3Ph6jVWIJPghnJ0Xrait6LeAVFWVmJ6kjGPq/lMnzF1O+Zh+kKyltlRBSDQfkQ5iCdqEPfrYxPWN8C+9by6xhH7kA3TdmYXdPzgLuEHvJXCC4CJ8EENnkQNUlg5LG3n5Bm6Gy9k2j9uIDcA0qQ3e6gTvnKAInNy3JWl0/6JkHe8fH0UlJT0RVCtsEkAiyrHzWa5i/kmOe5gBxOZsE5edQD5aMWbwOUMU64b/vfzY+538W5+Vsb6YYvCFcbGaDSWrYIc20cbb3O+GbxL6x1XhAGJhliWGNvgiszKxK5aT9fvEV+1vfGm2We4S/jMDOjEKpF4q6hzxGtj1r1iD5nmM7Whav1ZCwciWjJaXrmccqTayxJWIyi0hK3OoJ8h/9Npjda4T0vqXp8tBupjugJ3F67Zsf09230rnzZPoVxQmeSb+9L6u8YkQbDbg==]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高失联测D4]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E8%81%94%E6%B5%8BD4%2F</url>
    <content type="text"><![CDATA[你一定知道密码趴 Incorrect Password! No content to display! U2FsdGVkX19T0UK/T4SgzSFGCVL9yNr2KpZuEbtYQvxIwftmpUGhxTITF7pmCK9bUEBV+7FmFCOt/LIP4+rf+ng+aUB8HdX5x0xVO1PwengMPetcLiXMAwFuDdAVKLGlUf79NXXunUnHelAahvsqbDZXwrIzYYd4c/zjlYcrHbjl75TYB87mGnTgk0a9UckR9yRxeycG7jLb9R4g4GJ+dJG59jZnUzVgqASwZgrk6jNQGjKbWzjAM2jxTOxa5yofzZ97MaR66TzUDV5lLxyP6ycaQlrw8LgARMfm0OS/CKYGVEHPFjQ3+Z2qDEr0b7g+nzjQtEc0pyAtPZg0IvBzS9+pAlfV3oyzUh+RGfyGtM9nXUTbm+315nFmAGg8W2FpAmC8ST/YoqbI8k9hhv+nIWPv9h6UqxFc3xeX79UxN+FctIQGNo4+5gOJUkAlZ1NL+OAWAbiJG8SEROQEhOrNjbd8SnR2gUqTq+sr0fXDOHWoxW0MTnC9f90ZJZ1aLT2+l/kWii+0nSzyCbmsiITk3FwKxD36xWMfJwGHV2ZqlgXpwEAnPXPuIHR+BE7sRDl7MpeX7jrDDn8v+fyCME59s+kVC5kYTP3BQ3Vy4UvCqbepmb8pFbl1OEGUwZsk7qndeSuUxCHa9bZX0LxHSVvp0qCVMyfPZ9A1AfkTNfrtG+yeO2ixEO6ioy1jFtMO+J18AKJEudPIKS8ulxYaKvTVug==]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普及五连测D2]]></title>
    <url>%2F2019%2F09%2F21%2FPJ%E4%BA%94%E8%BF%9E%E6%B5%8BD2%2F</url>
    <content type="text"><![CDATA[你一定知道密码趴 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 73题解]]></title>
    <url>%2F2019%2F09%2F20%2FCF%E9%A2%98%E8%A7%A3%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[qwq A.2048 Game我们发现,我们可以忽略掉$2048$以上的数,剩下的数开桶统计然后贪心即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 105;int n; ll num[N];int used[2050];int main ( void ) &#123; int T = _read (); while ( T-- ) &#123; memset ( used , 0 , sizeof ( used ) ); n = _read (); F ( i , 1 , n ) &#123; num[i] = _read (); if ( num[i] &lt;= 2048 ) used[num[i]]++; &#125; if ( used[2048] ) &#123; puts ( "YES" ); continue; &#125; for ( int i = 1 ; i &lt;= 1024 ; i *= 2 ) used[i * 2] += ( used[i] / 2 ); if ( used[2048] ) puts ( "YES" ); else puts ( "NO" ); &#125; return 0;&#125; B.Knights我们贪心的考虑一下,如果我们现在这个位置的骑士,在它能移动的八个方向上,都会碰到其他的骑士,那么这个位置对答案的贡献一定是最优的. 结合样例,我们可以发现这样一种构造方法,我们从点$(1,1)$开始进行一次$bfs$,然后按照骑士的移动方法,每次更新一层,然后把这一层的骑士染色成和现在的骑士颜色不一样的颜色. 对于剩下的,那么可以证明没有任何点能跳到这个点,所以随便什么颜色都可以. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/int n;char mp[105][105];const int dx[] = &#123; 0 , 1 , 1 , -1 , -1 , 2 , 2 , -2 , - 2 &#125;;const int dy[] = &#123; 0 , 2 , -2 , 2 , -2 , 1 , -1 , 1 , -1 &#125;;void dfs ( int x , int y , char col ) &#123; mp[x][y] = col; for ( int i = 1 ; i &lt;= 8 ; i++ ) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if ( xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= n &amp;&amp; mp[xx][yy] != 'W' &amp;&amp; mp[xx][yy] != 'B' ) dfs ( xx , yy , col == 'W' ? 'B' : 'W' ); &#125; return;&#125;int main ( void ) &#123; n = _read (); dfs ( 1 , 1 , 'W' ); bool flag = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= n ; j++ ) &#123; if ( mp[i][j] == 'W' || mp[i][j] == 'B' ) printf ("%c",mp[i][j]); else &#123; printf ("%c" , flag?'B':'W'); flag ^= 1; &#125; &#125; puts(""); &#125; return 0;&#125;// Main Code C.Perfect Team一个直观的感觉就是你从$c,m$中取一个$Min$,然后我们会发现可能人数凑不够$Min*3$,所以我们判断一下$min(Min,sum/3)$就是答案了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/int n;int c , m , x;int main ( void ) &#123; int T = _read (); while ( T-- ) &#123; read ( c , m , x ); int mins = min ( c , m ); int sums = c + m + x; printf ( "%d\n" , min ( mins , sums / 3 ) ); &#125; return 0;&#125;// Main Code D.Make The Fence Great Again毒瘤出题人一个DP数据范围开3e5 看到$3e5$的数据范围,第一反应就是贪心,但是发现貌似不怎么可做?然后开始考虑$DP$,发现如果$i$这个点被升高了的话,貌似对后边的点是有影响的,有后效性,怎么办?我们经过观察可知,如果一个点要升高,那么它最多升高两次,所以我们可以设$f_{i,j}$表示现在是第$i$个位置,其中$i$这个位置升高了$j$次. 转移的话很显然,我们枚举一个最小的$f_{i-1,k}$并且要保证$fence_{i-1}.high+k$不等于$fence_i.high+j$然后转移就好了. 时间复杂度的话是$O(n*16)$硬核O(nlogn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define int long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 3e5 + 10;int n , idx;struct Node &#123; int hi; int vi;&#125;fence[N];int f[N][5];signed main ( void ) &#123; int T = _read (); while ( T-- ) &#123; n = _read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; read ( fence[i].hi , fence[i].vi ); for ( int j = 0 ; j &lt;= 4 ; j++ ) f[i][j] = 1e17; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 0 ; j &lt;= 4 ; j++ ) &#123; for ( int k = 0 ; k &lt;= 4 ; k++ ) &#123; if ( fence[i].hi + j == fence[i - 1].hi + k ) continue; f[i][j] = min ( f[i][j] , f[i - 1][k] ); &#125; if ( f[i][j] == 1e17 ) continue; f[i][j] += 1ll * j * fence[i].vi; &#125; &#125; int ans = 1e17; for ( int i = 0 ; i &lt;= 4 ; i++ ) ans = min ( ans , f[n][i] ); writeln ( ans ); &#125; return 0;&#125;// Main Code 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO09FEB]改造路Revamping Trails题解]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%94%B9%E9%80%A0%E8%B7%AF%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[复习了一波分层图…. 可以发现这道题就是分层图裸题.我们可以设$dis_{time,i}$表示现在已经用了$time$次免费机会,到达了$i$这个点的时候的最短路径.那么我们在进行堆优化$Dijkstra$时($SPFA$跑分层图一般会死的很惨),我们对于每次转移时,判断一下是否使用一次免费机会即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define K 25#define N 10005#define M 4200005#define F(i,a,b) for(int i=a;i&lt;=b;i++)#define G(i,a,b) for(int i=head[a];i;i=b[i].next)using namespace std;int n,m,k,t,start,end;struct Edge&#123; int to; int data; int next;&#125;e[M];struct Que&#123; int time,cur; Que(int a,int b):time(a),cur(b)&#123;&#125;&#125;;int head[N],vis[K][N];bool inque[K][N];int ans=2147483647;struct cmp &#123; bool operator () ( Que x , Que y ) &#123; return vis[x.time][x.cur] &gt; vis[y.time][y.cur]; &#125;&#125;;priority_queue &lt; Que , vector &lt; Que &gt; , cmp &gt; qu;void add (int x,int y,int z)&#123; e[++t].to=y; e[t].data=z; e[t].next=head[x]; head[x]=t; return;&#125;inline void spfa (int x)&#123; memset(vis,0x3f3f3f3f,sizeof(vis)); vis[0][x]=0; inque[0][x]=1; qu.push(Que(0,1)); while (!qu.empty())&#123; Que j=qu.top(); qu.pop(); inque[j.time][j.cur]=0; G(i,j.cur,e)&#123; int k=e[i].to; if (vis[j.time][k]&gt;vis[j.time][j.cur]+e[i].data)&#123; vis[j.time][k]=vis[j.time][j.cur]+e[i].data; if (!inque[j.time][k])&#123; inque[j.time][k]=1; qu.push(Que(j.time,k)); &#125; &#125; &#125; if (j.time&lt;k) G(i,j.cur,e)&#123; int k=e[i].to; if (vis[j.time+1][k]&gt;vis[j.time][j.cur])&#123; vis[j.time+1][k]=vis[j.time][j.cur]; if (!inque[j.time+1][k])&#123; inque[j.time+1][k]=1; qu.push(Que(j.time+1,k)); &#125; &#125; &#125; &#125; F(i,0,k) ans=min(ans,vis[i][n]); return;&#125;int main()&#123; scanf ("%d%d%d",&amp;n,&amp;m,&amp;k); F(i,1,m)&#123; int x,y,z; scanf ("%d%d%d",&amp;x,&amp;y,&amp;z); add (x,y,z); add (y,x,z); &#125; spfa(1); printf ("%d\n",ans); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>最短路</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高失恋测D3]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%8F%90%E9%AB%98%E5%A4%B1%E6%81%8B%E6%B5%8BD3%2F</url>
    <content type="text"><![CDATA[你一定知道密码趴 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces round585题解]]></title>
    <url>%2F2019%2F09%2F15%2Fround585%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[A.傻逼题,暴力枚举即可(我也就只会傻逼题了) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)#define G(i,a,b,c) for(rint a=head[b];a;a=c[a].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 10005;int n , a1 , a2 , k1 , k2 , idx;int num[N];inline bool cmp1 ( int x , int y ) &#123; return x &gt; y;&#125;inline bool cmp2 ( int x , int y ) &#123; return x &lt; y;&#125;int main ( void ) &#123; read ( a1 , a2 , k1 , k2 , n ); for ( int i = 1 ; i &lt;= a1 ; i++ ) num[++idx] = k1; for ( int i = 1 ; i &lt;= a2 ; i++ ) num[++idx] = k2; std :: sort ( num + 1 , num + 1 + idx , cmp1 ); int ans = 0; int tmp = n; for ( int i = 1 ; i &lt;= idx ; i++ ) if ( tmp &lt; num[i] ) &#123; tmp = 0; break; &#125; else tmp -= num[i] - 1; if ( tmp == 0 ) printf ( "%d " , ans ); else printf ( "%d " , tmp ); std :: sort ( num + 1 , num + 1 + idx , cmp2 ); ans = 0 , tmp = n; for ( int i = 1 ; i &lt;= idx ; i++ ) if ( tmp &lt; num[i] ) break; else &#123; ans ++; tmp -= num[i]; &#125; printf ( "%d\n" , ans ); return 0;&#125;// Main Code B.分从后往前现在的数的正负性讨论即可,负负得正. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 4e5 + 10;int n;ll num[N] , s[N];ll tai,fro;ll odd,uodd;int main ( void ) &#123; read ( n ); F ( i , 1 , n ) &#123; num[i] = _read (); s[i] = s[i - 1] ^ ( num[i] &lt; 0 ); if ( s[i] == 1 ) &#123; tai += odd; fro += uodd; odd++; fro++; &#125; else &#123; tai += uodd; fro += odd; tai++; uodd++; &#125; &#125; std :: cout &lt;&lt; fro &lt;&lt; " " &lt;&lt; tai &lt;&lt; std :: endl; return 0;&#125; C.发现只有$A$和$B$,两种字符,很容易发现规律. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define MP std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,num,b) for(rint i=num;i&lt;=b;i++)#define D(i,num,b) for(rint i=num;i&gt;=b;i--)#define G(i,num,b,c) for(rint num=head[b];num;num=c[num].next)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/char s[3][200005];int n , sum;int can1,can2,bc;int cnt1[200005],cnt2[200005];int main()&#123; read ( n ); scanf ( "%s%s" , s[1] , s[2] ); for(int i=0;i&lt;n;i++)&#123; if(s[1][i]!=s[2][i])&#123; if(s[1][i]=='a')&#123; can1++; cnt1[can1]=i+1; &#125; else&#123; can2++; cnt2[can2]=i+1; &#125; &#125; &#125; if(n%2==1)&#123; puts ( "-1" ); return 0; &#125; if(can1%2==1)&#123; sum+=2; sum+=(n-2)/2; writeln ( sum ); printf ( "%d %d\n" , cnt1[1] , cnt1[1] ); printf ( "%d %d\n" , cnt1[1] , cnt2[1] ); for(int i=2;i&lt;=can1;i+=2) printf ( "%d %d\n" , cnt1[i] , cnt1[i + 1] ); for(int i=2;i&lt;=can2;i+=2) printf ( "%d %d\n" , cnt2[i] , cnt2[i + 1] ); return 0; &#125; sum=(can1+can2)/2; writeln ( sum ); for(int i=1;i&lt;=can1;i+=2) printf ( "%d %d\n" , cnt1[i] , cnt1[i + 1] ); for(int i=1;i&lt;=can2;i+=2) printf ( "%d %d\n" , cnt2[i] , cnt2[i + 1] ); return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普转提七连测D2]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%99%AE%E4%B8%93%E6%8F%90D2%2F</url>
    <content type="text"><![CDATA[你一定知道密码趴 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据生成]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[图和树的数据生成器 图有向图和无向图同样适用的数据生成器,可生成随机图 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;using namespace std;int n,m,s,T;inline int random() &#123; static int seed = s; return seed = (int)(seed*48271ll%2147483647);&#125;set&lt;int&gt;to[100005];//去重int main() &#123; srand ( time ( NULL ) ) ; cin &gt;&gt; T; cout &lt;&lt; T &lt;&lt; endl; while(T--) &#123; s = rand(); n = 96; m = 102; printf("%d %d \n",n,m); for(int i = 1 ; i &lt;= m ; i++) &#123; int u = random() % n + 1; int v = random() % n + 1; while(to[u].find(v) != to[u].end() || u == v) &#123; u = random() % n + 1; v = random() % n + 1; &#125; printf("%d %d\n",u,v); to[u].insert(v); &#125; printf("\n"); &#125; return 0;&#125; 树保证数据为一棵随机树 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;using namespace std;int a[10005],e[10005][2];int n = 1000;bool flag[10005];int main() &#123; freopen("testdata.in","w",stdout); printf("%d\n",n); for(int i = 1 ; i &lt;= n ; i++) &#123; a[i] = rand() % n + 1; while(flag[a[i]]) a[i] = rand() % n + 1; flag[a[i]] = 1; &#125; for(int i = 2 ; i &lt;= n ; i++) &#123; e[i-1][0] = a[i]; e[i-1][1] = a[rand() % (i - 1) + 1]; &#125; memset(flag,0,sizeof(flag)); for(int i = 1 ; i &lt; n ; i++) &#123; int x = rand() % (n - 1) + 1; while(flag[x]) x = rand() % (n - 1) + 1; flag[x] = 1; int f = rand() % 2; if(f) printf("%d %d\n",e[x][0],e[x][1]); else printf("%d %d\n",e[x][1],e[x][0]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>知识水平</category>
      </categories>
      <tags>
        <tag>数据制造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普及五联测D1]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%99%AE%E5%8F%8A%E4%BA%94%E8%81%94%E6%B5%8BD1%2F</url>
    <content type="text"><![CDATA[你一定知道密码趴 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解:树]]></title>
    <url>%2F2019%2F09%2F12%2F%E9%A2%98%E8%A7%A3-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[暴力都不想写的题… 考虑到题目中要求的最小的那个东西不太好求所以我们可以找一个最大的符合条件的值,我们记为$tmp$,那么有$ans=tmp+1$ 那我们考虑一下这个$tmp$怎么求.]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI普转提D1题解]]></title>
    <url>%2F2019%2F09%2F11%2FZROI%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[你一定知道密码趴 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散步]]></title>
    <url>%2F2019%2F09%2F11%2F%E6%95%A3%E6%AD%A5%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这题好难啊 首先可以发现可以二分答案. 我们可以考虑二分一个最长的路径长度$mid$,然后将每个点看成不能在最多连续走$mid$个相同的路的情况下,从$1$号点到$n$号点是否联通. 然后现在的问题就变成了判断图的连通性的问题.我们发现,每个点只有两条出边.而且每种类型的出边只有一条,那么可以发现同样的类型的路径的走路的路径,可以看作一个集合.我们可以设$dis_{i,siz}$表示$i$这个点一直按照$siz$类型的路径一直走,最后一段$siz$路径的长度,然后我们发现,如果$i$这个点走到$j$这个点时,那么$dis_{j,siz}=dis_{i,siz}+1$,而我们发现这个东西显然可以用带权并查集来维护.在使用了带权并查集之后,我们每次就可以在$O(logn)$的时间复杂度内求出以某个点为起点走到最远能走到那个点了.然后我们可以进行一次$bfs$.在某次更新中,可以发现,如果现在到达这个点的最后的路径是$siz$类型的话,如果现在这个点连向的$siz xor 1$类型的点还没有被入队过,那么就将这个点扔进队里. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define oo 2147483647#define PI 3.141592653590#define rint register int#define F(i,a,b) for(rint i=a;i&lt;=b;i++)#define D(i,a,b) for(rint i=a;i&gt;=b;i--)inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;template &lt; typename T &gt; void write ( T x ) &#123;if ( x &lt; 0 ) x = -x , putchar ( '-' );if ( x &gt; 9 ) write ( x / 10 );putchar ( x % 10 + 48 );return;&#125;template &lt; typename T &gt; void writeln ( T x ) &#123;write ( x ); printf ("\n"); &#125;template &lt; class T &gt; inline T gcd ( T x , T y ) &#123;if ( x &lt; y ) swap ( x , y );if ( !y ) return x;return gcd ( y , x % y );&#125;template &lt; class T &gt; inline T ksm ( T x , T y , T Mod ) &#123;T tmp = 1;while ( y ) &#123;if ( y % 2 == 1 ) tmp = ( tmp * x % Mod );x = ( x * x ) % Mod;y &gt;&gt;= 1;&#125;return tmp;&#125; /**********************************************************************************************************************************************************************************************************************************************************************/const int N = 2e5 + 10; int n;int G[N][2];int father[N][2] , dis[N][2];bool vis[N][2];struct Node &#123; int pos; int kid;&#125;;std :: queue &lt; Node &gt; qu;int find ( int x , int kd ) &#123; if ( father[x][kd] != x ) &#123; int tmp = father[x][kd]; father[x][kd] = find ( father[x][kd] , kd ); dis[x][kd] += dis[tmp][kd]; &#125; return father[x][kd];&#125;inline bool check ( int rdm ) &#123; memset ( vis , false , sizeof ( vis ) ); memset ( dis , 0 , sizeof ( dis ) ); F ( i , 1 , n ) father[i][0] = father[i][1] = i; qu.push ( Node &#123; 1 , 0 &#125; ); qu.push ( Node &#123; 1 , 1 &#125; ); while ( !qu.empty() ) &#123; int j = qu.front().pos; int siz = qu.front().kid; qu.pop(); int now = 0; while ( 1 ) &#123; int root = find ( j , siz ); now = dis[j][siz]; if ( now + 1 &gt; rdm ) break; int kt = G[root][siz]; int kj = find ( kt , siz ); if ( !vis[kt][siz ^ 1] ) &#123; vis[kt][siz ^ 1] = 1; qu.push ( Node &#123; kt , siz ^ 1 &#125; ); &#125; if ( kj == root ) break; father[root][siz] = kt; dis[root][siz] = 1; &#125; &#125; if ( vis[n][0] || vis[n][1] ) return 1; return 0;&#125;int main ( void ) &#123; read ( n ); F ( i , 1 , n ) &#123; G[i][0] = _read(); G[i][1] = _read(); &#125; int l = 0 , r = n + 1; while ( l &lt;= r ) &#123; int mid = ( l + r ) &gt;&gt; 1; if ( check ( mid ) ) r = mid - 1; else l = mid + 1; &#125; if ( l &gt; n ) puts ( "-1" ); else writeln ( l ); return 0;&#125;// Main Code]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 72 题解报告]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[qwq A.第一眼看上去貌似是个找规律$O(1)$题,实际看了一下,确实是找规律$O(1)$题.所以就开始愉快的找规律,于是就有了以下的提交记录: emmm…. QAQ然后我们考虑一下正解. 我们设原来我们有$str in exp$,我们设我们分给$str x$点的$exp$,分给$in y$点的$exp$,那么显然有: x+y=exp \ and \ str+x>in+y发现上边的这个方程,通过将$y$用$exp-x$代替之后,我们可以解出$x$的具体范围.而且我们可以发现:所有$x$的取值范围一共只有$exp + 1$种,所以就可以愉快的求出答案了. 最后别忘了判断$exp$为$0$的情况. 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; int str,in,exp; cin&gt;&gt;str&gt;&gt;in&gt;&gt;exp; if (exp==0)&#123; if(str&gt;in) cout&lt;&lt;"1"&lt;&lt;endl; else cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; if(in+exp-str&lt;0)&#123; cout&lt;&lt;exp+1&lt;&lt;endl; continue; &#125; int ans=min(exp+1,(exp+1)-max(0ll,((in+exp-str)/2+1))); if ( ans &lt; 0 ) ans = 0; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; B.这么可爱的怪兽我怎么可能忍心去打它呢 我们看到题,首先想到,如果我们砍一刀,这个怪兽不死,那么它如果长出来的头大于我们我们这次砍掉的头.那么我们这次的操作显然没用.所以,在前几刀砍不死怪兽的情况下,我们需要最大化每一次砍头时的$d_i-h_i$,同时我们发现.在某一次砍头中,如果这次的$d_j$非常大,大到一下子可以把怪兽剩下的头砍完.我们就可以不用管这次砍头的副作用$h_j$了. 所以我们维护两个最大值,即$d_i-h_i$的最大值以及$d_i$的最大值,然后直接找题意做即可. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n,x;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--)&#123; int maxs=-1e16; int Damage=-1e16; cin&gt;&gt;n&gt;&gt;x; for(int i=1;i&lt;=n;i++) &#123; int tx,ty; cin&gt;&gt;tx&gt;&gt;ty; maxs=max(maxs,tx); Damage=max(Damage,tx-ty); &#125; if ( x &lt;= maxs ) &#123; cout &lt;&lt; "1" &lt;&lt; endl; continue; &#125; if(Damage&lt;=0)&#123; cout&lt;&lt;"-1"&lt;&lt;endl; continue; &#125; int now = ( x - maxs ) / Damage; if ( now * Damage &lt; x - maxs ) now+=2; else now++; cout&lt;&lt;now&lt;&lt;endl; &#125; return 0;&#125; C.通过读题,我们可以发现一个很重要的东西:$\sum_{i=1}^t len_i&lt;=2*10^5$. 通过这个性质,我们可以发现,我们在枚举每一次的区间时,这个区间的最长长度为$log_2len$. 然后就做完了?? 我们枚举一下每个区间的左/右端点,然后直接暴力统计答案就好了. 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int N = 200000 + 10;int t,nex[N];char s[N];int main() &#123; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",s+1); int n=strlen(s+1); nex[n+1]=n+1; for(int i=n;i&gt;=1;i--) &#123; if(s[i]=='0') nex[i]=nex[i+1]; else nex[i]=i; &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; int now=0; for(int j=nex[i];j&lt;=min(n,nex[i]+20);j++)&#123; now=now*2+s[j]-'0'; if(now==j-i+1) ans++; &#125; &#125; printf("%d\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round #582解题报告]]></title>
    <url>%2F2019%2F09%2F11%2FRound-2%2F</url>
    <content type="text"><![CDATA[qwq A.Chips Moving题意就是给你n个数,你每次可以选择一个数,对他进行免费的加2或者减2.或者花费1的代价,对某个数进行加一或者减一,求让所有的数变成一样的最小代价. 很显然可以发现,奇数和奇数之间可以相互转变,偶数和偶数之间也可以相互转变,那么我们只需要考虑让奇数全部变成偶数或者让偶数变成奇数就好了. 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int cnto = 0; for (int i = 0; i &lt; n; ++i) &#123; int x; cin &gt;&gt; x; cnto += x &amp; 1; &#125; cout &lt;&lt; min(cnto, n - cnto) &lt;&lt; endl; return 0;&#125; B.Bad Prices题意就是给你一个序列$A$,让你求出所有$A_i$中,$\sum_{i=1}^n[A_i&gt;A_{j(i&lt;j&lt;=n)}?0:1]$ 显然可以直接维护一个后缀最小值,然后判断一下当前$A_i$的值和当前后缀最小值的大小关系,如果$A_i&gt;num_i$,那么ans++ 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std; const int N=150005; int n;int num[N];int mins[N]; int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(mins,0x3f3f3f3f,sizeof(mins)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;num[i]); for(int i=n-1;i&gt;=1;i--) mins[i]=min(mins[i+1],num[i+1]); int ans=0; for(int i=1;i&lt;n;i++) if(num[i]&gt;mins[i]) ans++; printf("%d\n",ans); &#125; return 0;&#125; // C.Book Reading显然可以发现,题目中要求的个位数字只受要除的数的个位的影响,所以我们在求出来了倍数的个数$num$时,可以发现,个位数字的出现是有周期的,而这个周期和周期中的数字是由要除的数字的个位决定的.而因为要除的数字的个位最多只有10个,所以我们可以先预处理出每个数字的周期以及他们的和,再对多出来的部分直接暴力就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define int long long using namespace std; int n,m;int ned[10],idx[10];int sum[10][10]; signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); for(int i=1;i&lt;=9;i++)&#123; int now=i; sum[i][++idx[i]]=i; now+=i; while(now!=i)&#123; if(now&gt;=10) now-=10; sum[i][++idx[i]]=now; now+=i; &#125; &#125; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=idx[i];j++) ned[i]+=sum[i][j]; int T; cin&gt;&gt;T; while(T--)&#123; int ans=0; cin&gt;&gt;n&gt;&gt;m; int numm=n/m; int tmp = m; tmp%=10; if(tmp==0||numm==0)&#123; cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; int fir = numm/idx[tmp]; ans+=fir*ned[tmp]; // cout&lt;&lt;fir&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl; int sos=0; for(int i=fir*idx[tmp]+1;i&lt;=numm;i++) ans+=sum[tmp][i-fir*idx[tmp]]; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; // D.Equalizing by Division我们可以发现,对于某一个数$i$,他能变成的数的个数为$log_2i+1$个,而且题目中$i$的权值也不大,所以我们可以开一个桶,按照从小到大的顺序处理每一个数字,每次处理的时候将它能变成的$log_2i$个数字在桶中的权值全部+1,同时花费就是从原来的i到目前的数字要除几次二,当发现有桶中的数字大于给定的$k$时,更新答案. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std; const int N = 2e5 + 10; int n,k,ans=2147483647;int num[N];struct Node&#123; int val; int now;&#125;buck[N]; int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; buck[num[i]].now++; if(buck[num[i]].now&gt;=k)&#123; cout&lt;&lt;"0"&lt;&lt;endl; return 0; &#125; &#125; sort(num+1,num+1+n); for(int i=1;i&lt;=n;i++)&#123; int idx=1,tmp=num[i]/2; while(tmp)&#123; buck[tmp].now++; buck[tmp].val+=idx; if(buck[tmp].now&gt;=k) ans=min(ans,buck[tmp].val); tmp/=2; idx++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; //]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Qualification解题报告]]></title>
    <url>%2F2019%2F09%2F11%2FQualification%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[qwq T1:题目中给你一个$D$和一个$M$(一年有$D$个月,一个月有$M$天)让你求出: 的个数.其中$d_1$表示个位,$d_{10}$表示十位. 因为数据范围比较小,所以可以直接暴力枚举解决qwq… 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int m,d,ans;int main(void)&#123; scanf("%d%d",&amp;m,&amp;d); for(int i=1;i&lt;=m;i++)&#123; for(int sw=22;sw&lt;=d;sw++)&#123; int g=sw%10; int s=sw/10; if(g&gt;=2&amp;&amp;s&gt;=2&amp;&amp;s*g==i) ans++; &#125; &#125; printf("%d\n",ans); return 0;&#125; T2:给你一个数列$A$,将这个$A$不断$copy k$次变成数列$B$.最后让你求出数列$B$的逆序对个数.$k&lt;=10^9$ 看到$k$那么大,肯定可以$n^2$暴力了啊qwq 我们考虑这k组中的每一组.如果我们考虑原数列$A$中的每一位$A_i$,如果出现了一个$A_j&lt;A_i$,那么在从第$2$组开始,到第$k$组,这些比$A_i$小的数都会对$A_i$有贡献,而且第$3$组到第$k$组也会对第$2$组有贡献,这样一直递推下去,会发现有$1+(k-1)*(k-1)/2$次贡献,而且最后不要忘了一组中对自己的贡献. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=2004;const int HA=1e9+7;int n,k,ans;int num[N],dd[N];inline int ksm(int x,int y)&#123; int tmp=1; while(y)&#123; if(y&amp;1) tmp=(tmp*x)%HA; x=(x*x)%HA; y&gt;&gt;=1; &#125; return tmp%HA;&#125;signed main()&#123; scanf("%lld%lld",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;num[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; if(num[j]&lt;num[i]) dd[i]++; &#125; for(int i=1;i&lt;=n;i++)&#123; ans=(ans+k*(k-1)%HA*ksm(2,HA-2)%HA*dd[i]%HA)%HA; int tdp = 0; for(int j=i+1;j&lt;=n;j++) if(num[j]&lt;num[i]) tdp++; ans = ( ans + tdp * k ) % HA; &#125; printf("%lld\n",ans); return 0; &#125; T4:T3我不会欸qwq(捂脸)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Atcoder题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round #573 (Div. 2)解题报告]]></title>
    <url>%2F2019%2F09%2F11%2FRound-1%2F</url>
    <content type="text"><![CDATA[qwq A:没啥可说的,直接按照$Mod 4$分类然后讨论就好了. B:显然可以发现答案只能是0,1,2,3中的某一个,我们只需要将读入记录下来,然后对于每一种胜利的情况分组枚举一下,记录一个最小的ans就可以了. C:考虑每一次操作中,这一页的最右边能消除几个.我们可以设我们已经消除了$sum$个数字,那么当前的$m_i$在消除之后中的书中的位置就是$m_i-sum$,我们就可以推导出来当前$m_i$的这一页的最右边的一个数字就是$((m_i-sum)/k+1)*k$,我们只需要开一个关于i的指针就可以了,时间复杂度为$O(m)$. D:考虑必胜情况:在另外一个人开始取的时候有$2$个或者以上的重复组.或者在有1个重复组时,取出一个重复组(因为不取就会输)之后回和另外一个元素再组成一个重复组. 我们再考虑完这种情况之后,可以发现,我们在将原来的数组排序之后,如果两边都按照最优方式取石子,那么最后的(在决定胜负之前),石子的序列一定是$B_i=i-1$的这样的一个等差数列.所以我们需要对原数组排序,然后统计一个$\sum_{i=1}^n A_i-(i-1)$,判断一下这个$sum$的奇偶性就可以了. PS:一定要先判断有没有例外的必胜情况(我就是这么WA了4发qwq….) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=1e5+10;int n,idxx;int num[N],dis[N];map&lt;int,bool&gt;mp;signed main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; sort(num+1,num+1+n); int sum=0,dpp=0; for(int i=1;i&lt;=n;i++)&#123; if(num[i]==num[i-1]&amp;&amp;i&gt;=2)&#123; dpp++; dis[++idxx]=num[i]; &#125; sum+=num[i]-i+1; mp[num[i]]=1; &#125; if(n==1)&#123; if(sum&amp;1) cout&lt;&lt;"sjfnb"&lt;&lt;endl; else cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(dpp==1&amp;&amp;num[1]==0&amp;&amp;num[2]==0)&#123; cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(dpp==1&amp;&amp;n==2)&#123; cout&lt;&lt;"sjfnb"&lt;&lt;endl; return 0; &#125; if(dpp==1)&#123; if(mp[dis[1]-1]) cout&lt;&lt;"cslnb"&lt;&lt;endl; else &#123; if(!(sum&amp;1)) cout&lt;&lt;"cslnb"&lt;&lt;endl; else cout&lt;&lt;"sjfnb"&lt;&lt;endl; &#125; return 0; &#125; if(dpp&gt;=2)&#123; cout&lt;&lt;"cslnb"&lt;&lt;endl; return 0; &#125; if(!(sum&amp;1)) cout&lt;&lt;"cslnb"&lt;&lt;endl; else cout&lt;&lt;"sjfnb"&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Round]]></title>
    <url>%2F2019%2F09%2F11%2FRound%2F</url>
    <content type="text"><![CDATA[qwq A:这道题能想到二进制转十进制然后判断满足的个数，但是转十进制范围已经超过了$long long$，直接模拟会溢出因为满足条件数值的都是4的次幂，所以二进制首位1后跟的$2k$个$0$即为$4$的$k$次幂直接对$0$的个数分析即可 B:很明显的一道贪心题目,当求最小的$sum$时,显然当$1$最多时,$sum$最小.当求$sum$最大时同理.又因为当$a_i$是一个偶数时,$\frac{a_i}{2}$肯定存在,而且$a_i$的最小值为1,所以显然$a_i$的值就只能是$2^j$. C:(个人感觉比$D$难$QAQ…$)让你在给定的序列$P$中求一个子序列,使得在图中按照该子序列进行最短路径移动时可以完整经过原序列$P$.乍一看一点思路都没有.但是仔细思考可以发现一点点思路.我们可以从题目中给出的起点(也就是一号点)开始进行移动,然后在原序列$P$中如果需要经过$P_{i}$和$P_{i+1}$,那么我们显然可以得到$P_i$与$P_{i+1}$一定是直接相连的(因为题目中没有给出无解的情况).那么我们可以扩展一下,假设我们现在在$P_j$号点,我们要走到$P_k$号点.那么如果$dis[P_j][P_k]==j-k$,那么在有解的情况下,一定是有$P_j$经过了所有的$j&lt;i&lt;k$的点(可以自己画个图证明一下).在这种情况下,我们就可以选择扩展答案了. (感觉还是放一下代码比较好qwq) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int oo = 0x3f3f3f3f;const int N = 105;const int M = 1e6 + 10;int n,m,idx;char mp[N][N];int G[N][N],point[M],ans[M];int qu[M&lt;&lt;1];int head=1,tai=0;int main()&#123; memset ( G , 0x3f3f3f3f , sizeof ( G ) ); scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%s" , mp[i] + 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; for ( int j = 1 ; j &lt;= n ; j++ ) if ( mp[i][j] == '1' ) G[i][j] = 1; G[i][i] = 1; &#125; for ( int k = 1 ; k &lt;= n ; k++ ) for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) G[i][j] = min ( G[i][j] , G[i][k] + G[k][j] ); scanf("%d",&amp;m); for ( int i = 1 ; i &lt;= m ; i++ ) scanf ( "%d" , &amp;point[i] );// for(int i=1;i&lt;=n;i++)&#123;// for(int j=1;j&lt;=n;j++)// printf("%d " ,G[i][j]);// puts("");// &#125; int st=1,now=2; while(now&lt;=m)&#123; int diss=now-st; if(diss==G[point[st]][point[now]])&#123; if(head&lt;=tai) head++; qu[++tai]=now; now++; &#125; else &#123; ans[++idx]=point[st]; if(head&lt;=tai) st=qu[head++]; &#125; &#125; ans[++idx]=point[st]; if(ans[idx]!=point[m]) ans[++idx]=point[m]; printf("%d\n",idx); for(int i=1;i&lt;=idx;i++) printf ("%d ",ans[i]); return 0;&#125; D:感觉比$C$简单啊$QAQ$….让你求一个字符串使得这个字符串和给定01字符串的每一个子区间的最长单调不降区间长度一样长.我们自己理解了以后可以发现,一个区间的最长单调不降区间长度只是和每一个$1$后的$0$有关系,而和$0$后的$1$无关.(因为对于两个子串$11$和$01$,它们的最长不降区间是一样的).那么我们就可以考虑把原字符串的一些$1$变成$0$.就可以了. 但是怎么改变呢?我们考虑到,对于某一段连续的$1$,那么这段连续区间中的第一个1很显然是不必要的(而且不是最后一个1),那么我们可以把这些个1变成0.(然后就做完辣qwq) 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int tmpp;char ss[N] , tt[N];int main()&#123; scanf ( "%s" , ss + 1 ); int len = strlen ( ss + 1 ); for ( int i = 1 ; i &lt;= len ; i++ ) tt[i] = ss[i]; for ( int i = len ; i &gt;= 1 ; i-- ) &#123; if ( ss[i] == '1' &amp;&amp; tmpp &gt;= 0 ) tt[i] = '0'; int cur=ss[i] == '1' ? 1 : -1; tmpp = min ( tmpp + cur , cur ); &#125; for ( int i = 1 ; i &lt;= len ; i++ ) printf ( "%c" , tt[i] ); return 0;&#125;// E:现在还不会qwq]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeForces题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190819模拟赛题解]]></title>
    <url>%2F2019%2F09%2F11%2F20190819%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[qwq 又是爆零的一次比赛欸qwq… T1: 让你在一个矩阵中,找出一条路径,使得经过的路径方差最小. 我就直接放题解了qwq… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;template &lt;class T&gt;bool Reduce(T &amp;a,T const &amp;b)&#123; return a&gt;b?a=b,1:0;&#125;const int N=31,inf=1e9+7,S=59*30;int n,m,ans;int a[N][N];int f[N][N];int cnt=0;void init()&#123; std::ios::sync_with_stdio(false); freopen("path.in","r",stdin); freopen("path.out","w",stdout); std::cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) std::cin&gt;&gt;a[i][j];&#125;int calc(const int &amp;sum,const int &amp;i,const int &amp;j)&#123; return (n+m-1)*a[i][j]*a[i][j]-2*sum*a[i][j];&#125;int dp(int sum)&#123; for(int i=0;i&lt;N;++i) for(int j=0;j&lt;N;++j) f[i][j]=inf; f[1][1]=calc(sum,1,1); for(int j=2;j&lt;=m;++j) Reduce(f[1][j],f[1][j-1]+calc(sum,1,j)); for(int i=2;i&lt;=n;++i) Reduce(f[i][1],f[i-1][1]+calc(sum,i,1)); for(int i=2;i&lt;=n;++i) for(int j=2;j&lt;=m;++j)&#123; Reduce(f[i][j],f[i-1][j]+calc(sum,i,j)); Reduce(f[i][j],f[i][j-1]+calc(sum,i,j)); &#125; return sum*sum+f[n][m];&#125;int main()&#123; init(); ans=inf; for(int sum=1;sum&lt;=S;++sum) Reduce(ans,dp(sum)); std::cout&lt;&lt;ans; return 0;&#125; T2:让你每次从一个区间向另一个区间连边,最后求起点到所有点的最短路. 很显然是线段树优化建图,开两颗线段树A,B,第一颗线段树从儿子节点向父亲连边,另外一条线段树从父亲向儿子连边.但是一个点一个点的向区间连边太麻烦了,所以我们需要建一个虚点,每次从区间[l1,r1]向一个虚点连边,然后再用这个虚点向区间[l2,r2]连边,这样就可以了. (但是我被卡常了) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; const int N = 500010;const int M = 2210000;int n , m , p , tot , cnt , root_f , root_s;struct edge&#123; int to; int next; int date;&#125;e[11000000];struct Node&#123; int lc; int rc;&#125;tree[N&lt;&lt;2];int head[M] , dis[M] , pos[N];bool vis[M];std :: priority_queue &lt; std :: pair &lt; int , int &gt; , std :: vector &lt; std :: pair &lt; int , int &gt; &gt; , std :: greater &lt; std :: pair &lt; int , int &gt; &gt; &gt; q; inline void add(int x,int y,int date)&#123; e[++cnt].to=y; e[cnt].next=head[x]; head[x]=cnt; e[cnt].date=date; return;&#125;void FBuild(int &amp;root,int l,int r)&#123; root=++tot; if ( l == r ) &#123; pos[l]=root; return; &#125; int mid=l+r&gt;&gt;1; FBuild(tree[root].lc,l,mid); FBuild(tree[root].rc,mid+1,r); add(tree[root].lc,root,0); add(tree[root].rc,root,0); return;&#125;void SBuild(int &amp;root,int l,int r)&#123; root=++tot; if(l==r)&#123; add(root,pos[l],0); return; &#125; int mid=l+r&gt;&gt;1; SBuild(tree[root].lc,l,mid); SBuild(tree[root].rc,mid+1,r); add(root,tree[root].lc,0); add(root,tree[root].rc,0); return;&#125;void FAdd(int root,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; add(root,tot,1); return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) FAdd(tree[root].lc,l,mid,x,y); if(y&gt;mid) FAdd(tree[root].rc,mid+1,r,x,y);&#125;void SAdd(int root,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) &#123; add(tot,root,1); return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) SAdd(tree[root].lc,l,mid,x,y); if(y&gt;mid) SAdd(tree[root].rc,mid+1,r,x,y); return;&#125;inline void Dijkstra()&#123; memset(dis,0x3f3f3f3f,sizeof(dis)); q.push(std :: make_pair(0,pos[p])); dis[pos[p]]=0; while(!q.empty())&#123; int x=q.top().second; q.pop(); if(vis[x]) continue; vis[x]=1; for(int i=head[x];i;i=e[i].next)&#123; int y=e[i].to; if(dis[x]+e[i].date&lt;dis[y])&#123; dis[y]=dis[x]+e[i].date; q.push(std ::make_pair(dis[y],y)); &#125; &#125; &#125; return;&#125;int main ( void ) &#123; freopen("road.in","r",stdin); freopen("road.out","w",stdout); n = read(); m = read(); p = read(); FBuild ( root_f , 1 , n ); SBuild ( root_s , 1 , n ); while ( m-- ) &#123; int x1 = read() , y1 = read() , x2 = read() , y2 = read(); tot++; FAdd(root_f,1,n,x1,y1); SAdd(root_s,1,n,x2,y2); tot++; FAdd(root_f,1,n,x2,y2); SAdd(root_s,1,n,x1,y1); &#125; Dijkstra(); for(int i=1;i&lt;=n;++i) printf("%d\n",dis[pos[i]]/2); return 0;&#125; T3:给你一个矩阵,让你求出这个矩阵中的一个最大的子矩阵,使得这个子矩阵的每一行和每一列都是等差数列 暂时咕咕咕一会,不会]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邪教算法学习小结]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%82%AA%E6%95%99%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[qwq 事实证明,邪教算法是很有用的qwq(以下材料大多抄袭OI-wiki)qwq Part1:随机函数:但是并找不到什么随机化好题qwq,,,,,先Pass了再说qwq… Part2:爬山算法:个人理解就是一个比较跳的贪心(真的是个贪心)….一般常用于单峰函数的求解,但是单峰函数为啥不写三分呢? 爬山算法的一般流程其实就是:选定一个初始答案,通过某种方法计算出另外一个答案,if 另一个答案更优 then 转移否则不变, 很形象的就是了爬山这种东西. 例题 JSOI2008球形空间产生器 空间模型的爬山就是很正常的模板了,直接给代码了qwq 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10005;int n;double tot , f[1005][1005];double ans[N] , cans[N] , dis[N];inline void check () &#123; tot = 0; for ( int i = 1 ; i &lt;= n + 1 ; i++ ) &#123; cans[i] = 0; dis[i] = 0; for ( int j = 1 ; j &lt;= n ; j++ ) dis[i] += ( f[i][j] - ans[j] ) * ( f[i][j] - ans[j] ); dis[i] = sqrt ( dis[i] ); tot += dis[i]; &#125; tot /= ( n + 1 ); for ( int i = 1 ; i &lt;= n + 1 ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) cans[j] += ( dis[i] - tot ) * ( f[i][j] - ans[j] ) / tot; return;&#125;int main() &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n + 1 ; i++ ) for ( int j = 1 ; j &lt;= n ; j++ ) &#123; scanf ( "%lf" , &amp;f[i][j] ); ans[j] += f[i][j]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) ans[i] /= ( n + 1 ); for ( double T = 10001 ; T &gt;= 0.0000001 ; T *= 0.99995 ) &#123; check (); for ( int j = 1 ; j &lt;= n ; j++ ) ans[j] += cans[j] * T; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%.3lf " , ans[i] ); return 0;&#125; Part3. 模拟退火理解了爬山算法了之后,可以发现爬山算法存在的很显然的一个局限性:只能贪心,而这种在处理一些多峰函数时往往会只找到函数的某个极大值而不是最大值.所以我们就要引入模拟退火这种方法.,那么$What is $模拟退火呢? (以下内容来自WIKI) : 12345模拟退火来自冶金学的专有名词退火。退火是将材料加热后再经特定速率冷却，目的是增大晶粒的体积，并且减少晶格中的缺陷。材料中的原子原来会停留在使内能有局部最小值的位置，加热使能量变大，原子会离开原来位置，而随机在其他位置中移动。退火冷却时速度较慢，使得原子有较多可能可以找到内能比原先更低的位置。模拟退火的原理也和金属退火的原理近似：我们将热力学的理论套用到统计学上，将搜寻空间内每一点想像成空气内的分子；分子的能量，就是它本身的动能；而搜寻空间内的每一点，也像空气分子一样带有“能量”，以表示该点对命题的合适程度。算法先以搜寻空间内一个任意点作起始：每一步先选择一个“邻居”，然后再计算从现有位置到达“邻居”的概率。可以证明，模拟退火算法所得解依概率收敛到全局最优解。 听起来很懵逼是不是qwq..没关系,其实就是如果你通过现在的这个状态,以某种方式得到了另外一个答案时,你不再像爬山算法那样直接转移,而已要像下图: 发生转移之后,随着温度T的不断降低,可以发现$\frac{-\Delta E}{T}$是不断减小的(因为在新状态更劣的情况下,$-\Delta E$一定为负数),那么$e^\frac{-\Delta E}{T}$一定也是不断减小的并且趋向于0.即模拟退火算法在温度较低时退化为爬山算法.这时只能寻找当前的函数极大值,所以怎么调参使得温度$T$较大时转移到正确的峰函数区间是解决问题的关键(但是还是只能靠运气qwq) 一般模拟退火的代码大概框架如下: 123456789101112inline void SA () &#123; for ( double T = StartTemplature ; T &gt;= EndTemplature ; T *= Coolingcoefficient ) &#123; Typename Newans = Getans();//此处Getans为某个获得新答案的函数. Typename delta = ans - Newans; if ( Newans &gt; ans ) //这里假设当值大时答案更优 ans = Newans; else if ( exp ( -delta / T ) &lt; ( double ) rand () % RAND_MAX ) ans = Newans; &#125; return;&#125; 其实为了保证答案的正确性,一般都会跑多次模拟退火从而增加求得最优解的概率.(调参也是个非常痛苦的过程,因为模拟退火比爬山算法更为看脸随机,所以每个参数的小差别可能导致答案的天壤之别.) 例题 [TJOI2010]分金币 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt; #include &lt;ctime&gt;#define int long longconst int N = 1005;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int n , ans = 2147483647;int num[N];inline int get () &#123; int sum1 = 0 , sum2 = 0; for ( int i = 1 ; i &lt;= ( n + 1 ) / 2 ; i++ ) sum1 += num[i]; for ( int i = ( n + 1 ) / 2 + 1 ; i &lt;= n ; i++ ) sum2 += num[i]; return abs ( sum1 - sum2 );&#125;inline void SA () &#123; double T = 5000; while ( T &gt;= 1e-10 ) &#123; int l = rand () % n + 1 , r = rand () % n + 1; std :: swap ( num[l] , num[r] ); int sum = get (); if ( sum &lt; ans ) ans = sum; else if ( exp ( ( ans - sum ) / T ) &lt; (double(rand())/RAND_MAX) ) std :: swap ( num[l] , num[r] ); T *= 0.98; &#125; return;&#125;signed main ( void ) &#123; srand ( rand() ); int T = read (); while ( T-- ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) num[i] = read (); for ( int i = 1 ; i &lt;= 100 ; i++ ) SA (); printf ( "%lld\n" , ans ); ans = 2147483647; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Noip2018游记]]></title>
    <url>%2F2018%2F11%2F17%2FNoip2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[真没想到我能活着苟到写游记的一天$qwq$ Day-1最近几天有点累，早上就不去学校了（然而事实证明这是很正确的抉择）。早上一觉睡到了$8:20$，早上起来想起来$wucstdio$大佬说过立过的$flag$不拔在$Noip$会掉$rp$然后早睡起来就开始肝猪国杀，一直到$10:40$左右重构完了（历时$3$天终于写完了）下午回到学校，发现早上是信心鼓励赛幸好没去23333然后下午+晚上一直在写模板题。（顺便凑出来了$AC520$） Day 0早上教练居然给我们请假不用早来了哎$qwq….$上午开始走，一开始的时候还想在车上背个板子什么的然后SCP真好看又颓了会知乎然后就发现到了$cyyz$了 住宿安排完成了之后居然才$2:30$多一点，然后在宿舍里不知道该干啥。不过感觉$cyyz$的移动信号貌似比$SDSC$的时候快了一点（大雾）然后$wucstdio$给我打电话说楼下有很多大佬，自己迅速下楼去膜神仙。 终于见到了$rqy$姐姐本人了好兴奋$qwq$，不过$rqy$姐姐好像比自己想的稍微内敛了一点。 但是这并改变不了rqy姐姐是人赢的性质据说看见神仙可以rp++,（但是rp貌似被rqy姐姐吸走了QAQ) 晚上全宿舍都在打板子，但是试机的时候$wyxdrqc$和$zyp$大佬还有很多人（包括我）试机的时候线段树都打错了（大雾）。给自己喜欢的人打了个电话，加油qaq… Day 1早上起来，自己冷静了一下，打开题目一看$T1$，哎我为什么$T1$只会$70$分啊….，然后自己又推了1h还是没有推出来，心态当场爆炸qwq…T2当成数论推了半天，然后自己冷静的写了一个乱搞做法，也不知道能得多少分。T3完全不会，打一个直径分滚粗了。 出考场：啊你们怎么都做过原题吗？啊T2是个裸背包吗？啊T3你们都会写70分吗？心态崩了我要妹子QWQ….. 下午心态一直RE中，在宿舍里颓了一下午。不管怎么说第二天都想翻盘。 Day 2第二天睡了一觉，发现心情稍微好了一点。到了考场之后，看到第一题$m=n$我就感觉药丸…. 为什么$Noip$的$T1$要考基环树啊….. 写了个$60$分的树上贪心，然后开始想环上怎么做。然而我很$zz$的没有看数据范围可以$n^2$过，一直在写$O(n)$的做法。然后我就写挂了，自己补了只有环的做法，$72分滚了$。 T2看的时候：啊？读题读了$10mins$确定我不会，然后就决定打表了。 T3：……为什么$Noip$要考$ddp$啊。。。。 出了考场发现大家都说D2不会做当时甚至有些开心。 然后晚上就回去上晚自习了。 一年半的OI一场空，$D1TI$见祖宗说我是再适合不过的了。本来还以为自己能去$PKUWC$,好吧，我还是太$naive$了，感觉自己要与省一擦肩而过….剩下一年自己就养生好了，再来一年起码要拿一个$1=$啊$qwq…..$ 回家之后心态一直RE,,,,不过幸好$wucstdio$大佬能和我谈了谈人生….瞬间感觉$wucstdio$成了我的人生导师qaq…. 以后的路自己就要自己决定了，不过自己决定那些比赛也是要一起参加的qaq… 那些能进入省选的$OIer$们要加油鸭$qaq…$我会一直陪着你们的$@wyxdrqc @wucstdio @lingyuqing$ 你们的$wqyzstql$也要和你们一起努力了。]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考前模板整理]]></title>
    <url>%2F2018%2F11%2F07%2F%E8%80%83%E5%89%8D%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[$Noip$之前在这里整理一波模板….集成了一下所有的$TG$和$PJ$应该会考的模板 PS:所有模板纯属现场手搓，不保证正确性（比如手抖打错字母什么的），如果找到错误请及时告知我qwq 快速排序最基本的板子了吧,$C++$选手表示开心$qaq$。1234567891011121314151617#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5 + 10int n;int num[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;num[i] ); sort ( num + 1 , num + 1 + n ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , num[i] , i == n ? '\n' : ' ' ); return 0;&#125; 并查集12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5 + 10;int n , m;int find ( int x ) &#123; if ( x != father[x] ) father[x] = find ( father[x] ); return father[x];&#125;int main ( void ) &#123; scanf ( "%d%d" , &amp;n , &amp;m ); for ( int i = 1 ; i &lt;= n ; i++ ) father[i] = i; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x , y , z; scanf ( "%d%d%d" , &amp;z , &amp;x , &amp;y ); if ( z == 1 ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; &#125; else if ( z == 2 ) &#123; x = find ( x ) , y = find ( y ); if ( x == y ) puts ( "Y" ); else puts ( "N" ); &#125; &#125; return 0;&#125; 快速幂个人感觉这个还是个挺重要的板子了吧…..12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int Fast_Power ( int x , int y ) &#123; int sum = 1; while ( y ) &#123; if ( y &amp; 1 ) sum = sum * x; x = x * x; y &gt;&gt;= 1; &#125; return sum;&#125;int main ( void ) &#123; int n , m; scanf ( "%d%d" , &amp;n , &amp;m ); printf ( "%d\n" , Fast_Power ( n , m ) ); return 0;&#125; 线性筛素数这个其实只是筛素数的话是挺简单的，但是我决定连$\phi$一起筛出来（如果用不到的话就把$phi$数组自动忽略掉就好了）12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 5e5 + 10;int n , cnt;int prime[N] , phi[N];bool flag[N];int main ( void ) &#123; flag[1] = 1; phi[1] = 1; scanf ( "%d" , &amp;n ); for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; flag[i] = 1; prime[++cnt] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; for ( int i = 1 ; i &lt;= cnt ; i++ ) printf ( "%d " , prime[i] ); puts ( "" ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d " , phi[i] ); return 0;&#125; 【模板】堆又是一个$C++$党的福利$qwq$,直接用$priority_queue$模拟就好啦123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using std :: priority_queue;int n;priority_queue &lt; int , std :: vector &lt; int &gt; , std :: greater &lt; int &gt; &gt; qu;int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int opts; scanf ( "%d" , &amp;opts ); if ( opts == 1 ) &#123; int x; scanf ( "%d" , &amp;x ); qu.push ( x ); &#125; else if ( opts == 2 ) printf ( "%d\n" , qu.top () ); else if ( opts == 3 ) qu.pop (); &#125; return 0;&#125; 字符串蛤希其实我个人比较倾向于写自然溢出或者直接随机一个质数$qwq$12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;typedef unsigned long long ull;const ull base = 233;const int N = 1e4;const int M = 1e3;int n;char s[N][M];ull has[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%s" , s[i] + 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; int len = strlen ( s[i] + 1 ); for ( int j = 1 ; j &lt;= len ; j++ ) has[i] = has[i] * base + s[i][j]; &#125; std :: sort ( has + 1 , has + 1 + n ); int ans = 0; for ( int i = 1 ; i &lt;= n ; i++ ) if ( has[i] != has[i + 1] ) ans++; printf ( "%d\n" , ans ); return 0;&#125; 最小生成树不会写$prim$的蒟蒻瑟瑟发抖….123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e4 + 10;const int M = 2e5 + 10;int n , m;struct Edge &#123; int from; int to; int data;&#125;e[M];int father[N];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline bool cmp ( Edge x , Edge y ) &#123; return x.data &lt; y.data;&#125;int find ( int x ) &#123; if ( x != father[x] ) father[x] = find ( father[x] ); return father[x];&#125;void Union ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); father[x] = y; return;&#125;inline bool Judge ( int x , int y ) &#123; x = find ( x ) , y = find ( y ); return ( x == y ) ? true : false;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) father[i] = i; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); e[i].from = x; e[i].to = y; e[i].data = z; &#125; std :: sort ( e + 1 , e + 1 + m , cmp ); int NowEdge = 0 , NowVal = 0; for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int l = e[i].from , r = e[i].to; if ( Judge ( l ,r ) ) continue; Union ( l , r ); NowEdge++; NowVal += e[i].data; if ( NowEdge == n - 1 ) break; &#125; if ( NowEdge == n - 1 ) printf ( "%d\n" , NowVal ); else puts ( "orz" ); return 0;&#125; 单源最短路 （有负权边）这张图有负权边，所以只能写某已经死掉的$SPFA$了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int N = 1e4 + 10;const int M = 1e5 + 10;using std :: queue;int n , m , t;struct Edge &#123; int to; int data; int next;&#125;e[M];int head[N] , dis[N];bool inque[N];inline int read () &#123; int s = 0; bool flag = 0; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '0' ) flag = 1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return ( flag ) ? -s : s;&#125;void Spfa ( int x ) &#123; memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[x] = 1;dis[x] = 0; qu.push ( x ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].data ) &#123; dis[k] = dis[j] + e[i].data; if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; return;&#125;int main ( void ) &#123; n = read () , m = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); add ( x , y , z ); &#125; Spfa ( 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , dis[i] == 0x3f3f3f3f ? 2147483647 : dis[i] , i == n ? '\n' : ' ' ); return 0;&#125; 单源最短路 （无负权边）在题目明确说没有负权边的情况下，跑堆优化的$Dijkstra$一定是最稳的其实代码长得都差不多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define F(i,a,b) for ( int i = a ; i &lt;= b ; i++ )#define MP std::make_pair#define se second#define fi firsttypedef std::pair &lt; int , int &gt; pll;const int N = 1e5 + 10; const int M = 4e5 + 20;std::priority_queue &lt; pll , std::vector &lt; pll &gt; , std::greater &lt; pll &gt; &gt; qu;int n , m , s , t;struct Edge &#123; int to; int data; int next;&#125;e[M];int head[N] , dis[N];bool inque[N];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void Heap_Dijkstra ( int x ) &#123; memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); dis[x] = 0; qu.push ( MP ( dis[x] , x ) ); while ( !qu.empty () ) &#123; int j = qu.top ().se; qu.pop (); if ( inque[j] ) continue; inque[j] = 1; for ( int i = head[j] ; i ; i = e[i].next ) &#123; int k = e[i].to; if ( dis[k] &gt; dis[j] + e[i].data ) &#123; dis[k] = dis[j] + e[i].data; qu.push ( MP ( dis[k] , k ) ); &#125; &#125; &#125; return;&#125;int main ( void ) &#123; n = read (); m = read (); s = read (); F ( i , 1 , m ) &#123; int x = read () , y = read () , z = read (); add ( x , y , z ); &#125; Heap_Dijkstra ( s ); F ( i , 1 , n ) printf ( "%d " , dis[i] ); return 0;&#125; 就先整理这些吧…留个坑等着填….]]></content>
      <categories>
        <category>吹水</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2010] 所驼门王的宝藏]]></title>
    <url>%2F2018%2F11%2F05%2Fi-t%2F</url>
    <content type="text"><![CDATA[一道思维难度很简单，代码实现难度非常$mmp$的毒瘤题…..(这很$SDOI…..$) 题目连接：SDOI2010 所驼门王的宝藏 好，我们直接跳过题目背景。 然后我们会发现，如果这道题能把图建出来，那么直接一遍$DAG$上$DP$就过了。 蒽，这不是$sb$题吗？ 然后让我们看数据范围：$1&lt;=n&lt;=1000000$ 笑容逐渐消失 但是我们考虑一下，既然我们要建一张$DAG$。那么，我们完全没有必要对所有的点进行两两连边。我们只需要对每一行和每一列进行连边，把他们连成一个环，这样的话，建边复杂度就会从$O(n^2)$变成$O(n)$了。 然后对于自由门的情况，对不起，我不知道怎么优化，所以我决定暴力建边。 （分析可以发现即使全是自由门，你暴力建边也不会$TLE$） 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;map&gt;const int N = 1e6 + 10;const int M = 5e6 + 10;using std :: map;using std :: stack;int ans = -0x3f3f3f3f;int n , r , c , t;int dx[] = &#123; 0 , 0 , 1 , 1 , 1 , -1 , -1 , -1 &#125;;int dy[] = &#123; 1 , -1 , 1 , 0 , -1 , 1 , 0 , -1 &#125;;struct Node &#123; int x; int y; int opts; int id;&#125;p[N];struct Edge &#123; int from; int to; int next; &#125;e[M];int idx , Bcnt;int head[N] , dfn[N] , low[N];int Belong[N] , size[N] , f[N];int degree[N];bool instack[N];map &lt; std :: pair &lt; int , int &gt; , int &gt; mp;map &lt; std :: pair &lt; int , int &gt; , int &gt; mat;stack &lt; int &gt; st;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].from = x; e[t].next = head[x]; head[x] = t; return;&#125;bool cmp1 ( Node a , Node b ) &#123; if ( a.x != b.x ) return a.x &lt; b.x; if ( a.opts == 1 ) return 1; if ( b .opts == 1 ) return 0; return a.y &lt; b.y;&#125;bool cmp2 ( Node a , Node b ) &#123; if ( a.y != b.y ) return a.y &lt; b.y; if ( a.opts == 2 ) return 1; if ( b.opts == 2 ) return 0; return a.x &lt; b.x;&#125;void Tarjan ( int cur ) &#123; dfn[cur] = low[cur] = ++idx; instack[cur] = 1; st.push ( cur ); for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( !dfn[j] ) &#123; Tarjan ( j ); low[cur] = min ( low[cur] , low[j] ); &#125; else if ( instack[j] ) low[cur] = min ( low[cur] , dfn[j] ); &#125; int k; if ( low[cur] == dfn[cur] ) &#123; Bcnt++; do &#123; k = st.top ();; st.pop (); instack[k] = 0; Belong[k] = Bcnt; size[Bcnt]++; &#125; while ( k != cur ); &#125; return;&#125;void dfs ( int cur , int father ) &#123; if ( f[cur] &gt; size[cur] ) return; f[cur] = size[cur]; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == father ) continue; dfs ( j , cur ); f[cur] = max ( f[cur] , f[j] + size[cur] ); &#125; return;&#125;int main ( void ) &#123; n = read () , r = read () , c = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; p[i].x = read (); p[i].y = read (); p[i].opts = read (); p[i].id = i; mp[std::make_pair ( p[i].x , p[i].y )] = i; &#125; std :: sort ( p + 1 , p + n + 1 , cmp1 ); int first = 1 , last = 1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( p[i].x != p[i + 1].x ) &#123; if ( first != last ) add ( p[last].id , p[first].id ); last = first = i + 1; &#125; else &#123; if ( p[last].opts == 1 ) add ( p[last].id , p[i + 1].id ); if ( p[i + 1].opts == 1 ) last = i + 1; if ( p[first].opts != 1 ) last = first = i + 1; &#125; &#125; first = last = 1; std :: sort ( p + 1 , p + 1 + n , cmp2 ); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( p[i].y != p[i + 1].y ) &#123; if ( first != last ) add ( p[last].id , p[first].id ); last = first = i + 1; &#125; else &#123; if ( p[last].opts == 2 ) add ( p[last].id , p[i + 1].id ); if ( p[i + 1].opts == 2 ) last = i + 1; if ( p[first].opts != 2 ) last = first = i + 1; &#125; &#125; //printf ( "%d\n" , t ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( p[i].opts == 3 ) for ( int j = 0 ; j &lt; 8 ; j++ ) &#123; int xx = p[i].x + dx[j]; int yy = p[i].y + dy[j]; if ( mp[std :: pair &lt; int , int &gt; ( xx , yy )] ) add ( p[i].id , mp[std :: pair &lt; int , int &gt; ( xx , yy )] ); &#125; // printf ( "%d\n" , t ); // for ( int i = 1 ; i &lt;= t ; i++ ) // printf ( "%d %d\n" , e[i].from , e[i].to ); for ( int i = 1 ; i &lt;= n ; i++ ) if ( !Belong[i] ) Tarjan ( i ); for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = head[i] ; j ; j = e[j].next ) &#123; int k = e[j].to; if ( Belong[i] != Belong[k] ) mat[std :: make_pair ( Belong[i] , Belong[k] )] = 1; &#125; t = 0; memset ( head, 0 , sizeof ( head ) ); for ( auto it = mat.begin () ; it != mat.end() ; it++ ) &#123; add ( it -&gt; first.first , it -&gt; first.second ); degree[it -&gt; first.second]++; &#125; // for ( int i = 1 ; i &lt;= Bcnt ; i++ ) // printf ( "%d " , degree[i] ); for ( int i = 1 ; i &lt;= Bcnt ; i++ ) if ( degree[i] == 0 ) &#123; dfs ( i , 0 ); ans = max ( ans , f[i] ); &#125; printf ( "%d\n" , ans ); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qbxt D2T2 Code 题解]]></title>
    <url>%2F2018%2F11%2F04%2F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[看了一眼之后完全就是一脸懵逼的题…. 首先先读题$qaq$…..题目的大致意思就是给你一个矩阵，然后问你把这个矩阵横竖填成异或值为$1$的矩阵的方案数。 很明显，这道题没有什么枚举上界，所以你想直接枚举的话是不太可能的。那么我们怎么办呢$?$ 我也不知道 既然枚举补星，那么我们就用一个比较常见的正难则反的思想。对于这道题，我们可以容斥的去做 那么，首先，所有的方案是什么呢？ All = 2^{n*m}为什么呢？一共有n+m个校验码，我们按位数考虑，在只有1位的情况下，那么这一位可能是$0$或者$1$。那么就是$(2^n)^m$的方案数了。 然后我们考虑对于每一位删掉不合法的情况：因为异或起来是$1$，那么对于没一行或者每一列，$1$的个数总是奇数。那么我们就可以根据这个东西来进行删除不合法状态的操作了 最后统计出来答案 我们发现，因为有$k$位，而我们是按位考虑的。所以我们最后要取答案的$k$次方。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define int long longconst int N = 505;const int MOD = 1e9 + 7;int c[N][N];int n , m , k , t , ans;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int Fast_Power ( int x , int y ) &#123; int sum = 1; while ( y ) &#123; if ( y &amp; 1 ) sum = sum * x % MOD; x = x * x % MOD; y &gt;&gt;= 1; &#125; return sum;&#125;signed main() &#123; for ( int i = 1 ; i &lt;= 500 ; i++ ) c[i][i] = c[i][0]=1; for ( int i = 2 ; i &lt;= 500 ; i++ ) for ( int j = 1 ; j &lt; i ; j++ ) c[i][j] = ( c[i - 1][j] + c[i - 1][j - 1] ) %MOD; t = read(); while ( t-- ) &#123; n = read () , m = read() , k = read (); int ans = Fast_Power ( 2 , n * m ); for ( int i = 0 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) &#123; if ( i == 0 &amp;&amp; j == 0 ) continue; if ( ( i + j ) &amp; 1 ) ans = ( ans + MOD - Fast_Power ( 2 , ( n - i ) * ( m - j ) ) * c[n][i] % MOD * c[m][j] % MOD ) % MOD; else ans = ( ans + Fast_Power ( 2 , ( n - i ) * ( m - j ) ) * c[n][i] % MOD * c[m][j] % MOD ) % MOD; &#125; ans = Fast_Power ( ans , k ); printf ( "%lld\n" , ans ); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解] Noip2016D1T3 换教室]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%8D%A2%E6%95%99%E5%AE%A4%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一道被天天爱跑步抢尽了风头的最没有排面的$T3…..$说实话，这道题我刚开始是不会的，然后我看了L_Y_T大爷的$Blog$之后才恍然大悟（$Blog$写的很好，赞一个）先安利完$Blog$再说L_Y_T大爷的Blog 看了$Blog$之后,突然发现，这东西要求的概率知识点我都是会的，只是DP式子想不出来而已$qaq…$(我好菜啊) 因为题目中说，我们最多可以换$m$次，而题目中说的你只能在开始之前选择方案的说法完全没用，毕竟谁会知道你是预测了未来呢（逃 然后，因为有$n$个课程，所以我们设$f[i][j][0/1]$来表示第i个点,第j次换,换不换 然后我们分情况来表示转移：每个教室分为两种情况 1.换2.不换这个是挺平常的然后复杂在换与不换的分情况上了~~~不换:不换是分为这样几种情况:上一个也不换 , 上一个换 且成功,上一个换但失败同理,换也有好多种情况:上一个点不换,这个点失败上一个点不换,这个点成功上一个点换成功,这个点成功上一个点换成功,这个点失败上一个点换失败,这个点成功上一个点换失败,这个点也失败 然后方程好复杂的，是：1234567891011121314151617181920212223242526 上一点不换:f[i-1][j-1][0]这一点换1.失败消耗体力: dis[c[i-1]][c[i]] 分析: 由于上一个点不换,所以上一个点一定是在c[]中的;假定这次失败,那么这次也只能去c[]中的教室;2.成功消耗体力: dis[c[i-1]][d[i]]分析: 由于上一个点不换,所以上一个点一定是在c[]中的;假定这次成功,那么这次能去d[]中的教室;那么,失败的概率是1-k[],成功的概率是k[].综上,这种情况就是:f[i-1][j-1][0]+dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1.0-k[i]) 同理,上一点换,这一点换1.上一点失败,这一点失败(以后省一点哈)消耗体力: dis[c[i-1]][c[i]]概率:都失败这运气也没谁了!!!! 概率:(1.0-k[i-1])*(1.0-k[i])2.失败,成功消耗体力: dis[c[i-1]][d[i]]概率 : (1.0-k[i-1])*k[i]3.成功,失败消耗体力 : dis[d[i-1]][c[i]]概率: k[i-1]*(1.0-k[i])4.成功,成功消耗体力: dis[d[i-1]][d[i]] 概率: k[i-1]*k[i] 然后对于不换的方程：12f[i][j][0] = min(f[i-1][j][0]+dis[c[i-1]][c[i]],f[i-1][j][1]+dis[c[i-1]][c[i]]*(1.0-k[i-1])+dis[d[i-1]][c[i]]*k[i-1]) ; 之前需要Floyd预处理一下，然后就好啦(这道题的确比天天爱跑步简单23333)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 2050;const int M = 350;int n , m , v , e;int c[N] , d[N] ;double G[M][M] , f[N][N][2];double k[N];template &lt; class T &gt;inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;int main ( void ) &#123; scanf ( "%d%d%d%d" , &amp;n , &amp;m , &amp;v , &amp;e ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;c[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%d" , &amp;d[i] ); for ( int i = 1 ; i &lt;= n ; i++ ) scanf ( "%lf" , &amp;k[i] ); for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= m ; j++ ) f[i][j][0] = f[i][j][1] = 0x3f3f3f3f; for ( int i = 1 ; i &lt;= v ; i++ ) G[i][i] = 0 ; for ( int i = 1 ; i &lt;= e ; i++ ) &#123; int x , y; double z; scanf ( "%d%d%lf" , &amp;x , &amp;y , &amp;z ); if ( G[x][y] &gt; z ) G[x][y] = G[y][x] = z; &#125; for ( int l = 1 ; l &lt;= v ; l++ ) for ( int i = 1 ; i &lt;= v ; i++ ) for ( int j = 1 ; j &lt;= v ; j++ ) G[i][j] = min ( G[i][j] , G[i][l] + G[l][j] ); f[1][0][0] = f[1][1][1] = 0.0000; for ( int i = 2 ; i &lt;= n ; i++ ) for ( int j = 0 ; j &lt;= min ( i , m ) ; j++ ) &#123; f[i][j][0] = min ( f[i - 1][j][0] + G[c[i - 1]][c[i]] , f[i - 1][j][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1] ); if(j &gt;= 1) &#123; f[i][j][1] = min ( f[i - 1][j - 1][0] + G[c[i - 1]][d[i]] * k[i] + G[c[i - 1]][c[i]] * ( 1.0 - k[i] ) , f[i - 1][j - 1][1] + G[c[i - 1]][c[i]] * ( 1.0 - k[i - 1] ) * ( 1.0 - k[i] ) + G[c[i - 1]][d[i]] *k[i] * ( 1.0 - k[i - 1] ) + G[d[i - 1]][c[i]] * k[i - 1]* ( 1.0 - k[i] ) + G[d[i - 1]][d[i]] * k[i - 1] * k[i] ); &#125; &#125; double ans = 0x7fffffff; for ( int i = 0 ; i &lt;= m ; i++ ) for ( int j = 0 ; j &lt;= 1 ; j++ ) ans = min ( ans , f[n][i][j] ); printf ( "%.2lf\n" , ans ) ; return 0 ;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率入门]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%A6%82%E7%8E%87%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[其实这道初赛题是我第一次做的概率题 我们来看一眼这道毒瘤题： 题面其实已经很清楚了，我们可以发现，当这个青蛙在第$1$块石头时，那么这只青蛙完全可以不用跳，我们设$f(k)$表示这只青蛙在$k$号荷叶上，期望需要$f(k)$次跳到$1$号荷叶，那么我们有： f(1)=0我们接着来考虑当这只青蛙在$2$号荷叶时的情况，它可以跳到$1$号和$2$号荷叶，当它跳到$1$号荷叶时，它完成了任务，跳了一步。当它跳到$2$号时，它还有$f(2)$步，因为每一次跳跃时，跳跃到每一个荷叶上的几率是相等的，所以我们有： f(2)=[1+(1+f(2))]/2同理，我们可以得到： f(3)=[1+(1+f(2))+(1+f(3))]/3推广到一般形式则有: f(k)=[\sum_{i=1}^k{f(i)+1}]/k我们化简一下，有： f(k)=1+\frac {1}{k}\sum_{i=1}^kf(i) 我们看到这个式子：$f(k)=1+\frac {1}{k}\sum_{i=1}^kf(i)$ 当$i==k$的时候,我们会发现式子里出现了一个$f(k)$….. 这咋求啊 我们展开这个式子，会发现原来的式子等价于： f(k)=1+\frac {1}{k}\sum_{i=1}^{k-1}f(i)+\frac 1kf(k)这时候如果把$f(k)$看作一个未知数的话，我们可以发现$f(k)$的这一项是可以合并的。但是我们先两边同乘一个$k$，把分母去掉，就会有： k*f(k)=k+\sum_{i=1}^{k-1}f(i)+f(k)这样答案就很显然了，合并掉等式两边相等的$f(k)$，会得到： (k-1)*f(k)=k+\sum_{i=1}^{k-1}f(i)最后，两边同除$(k-1)$，有最后答案上的公式： f(k)=\frac{k}{k-1}(1+\frac {\sum_{i=1}^{k-1}f(i)}{k-1})通过这个式子计算可以得到$f(5)=\frac{37}{12}$,也就是答案 做完了QAQ(写Markdown好累啊qwq…)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2015]WIL-Wilcze题解]]></title>
    <url>%2F2018%2F11%2F02%2FPOI2015-WIL-Wilcze%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[其实这本来是$QBXT$的$T2$，但是由于毒瘤$zhw$跑得快（雾），导致我们发现这是某$poi$原题。 首先看题面:题目链接 详细读了一遍之后，其实对于这道题，我的第一反应是贪心（也许是因为我太菜了）。然后打了一遍，小样例过了，然后被大样例$hack$。 之后我又用命分析了一下。可以发现，因为题目中保证每个数的值全部$&gt;=0$，即每个数都是正整数。所以我们与其选长度不到$d$的区间删除，不如直接选择长度为$d$的区间删除。 那么在一段长度已知的序列中，长度为$d$的子序列个数是已知的，那么我们就可以预处理出每一段长度为$d$的子序列。然后我们又发现，题目中要求区间的长度不超过p，那么我们很明显的可以想到尺取法。 然后我们就可以用单调队列来维护我们预处理出的这些长度为$d$的子序列。然后对于区间长度取$max$就是答案了。 最后怒斥一波出原题的出题人$qaq$….(虽然$zhw$很帅) 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;deque&gt;typedef long long ll;using std::deque;const ll N=2000010;ll n,p,d;ll a[N];ll sum[N];ll hea[N];struct Node&#123; ll pos,val; Node(ll pos,ll val):pos(pos),val(val)&#123;&#125; Node()&#123;&#125;&#125;;inline void read(ll &amp;x)&#123; ll s=0,w=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;s=s*10+ch-'0';ch=getchar();&#125; x=s*w; return;&#125;deque&lt;Node&gt;q;int main()&#123; read(n);read(p);read(d); for(int i=1;i&lt;=n;i++)read(a[i]),sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n-d;i++) hea[i]=sum[i+d]-sum[i]; for(int i=n-d+1;i&lt;=n;i++) hea[i]=sum[n]-sum[i]; ll ans=0; int l=0; for(int i=d+1;i&lt;=n;i++) &#123; while(!q.empty()&amp;&amp;q.back().val&lt;hea[i-d])q.pop_back(); q.push_back(Node(i-d,hea[i-d])); while(l&lt;i-d&amp;&amp;sum[i]-sum[l]-q.front().val&gt;p) &#123; l++; while(l&gt;q.front().pos)q.pop_front(); &#125; ans=std::max(ans,(ll)i-l); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复赛冲刺Day1R1-Color题解]]></title>
    <url>%2F2018%2F11%2F01%2F%E5%A4%8D%E8%B5%9B%E5%86%B2%E5%88%BADay1R1-Colory%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这道题是考试时的$T2$，我感觉这道题出的特别好（虽然当时并不会做 首先看题目:$emmmmm…..$什么鬼啊这个题是$QAQ$ 当时直接一脸懵逼，然后只会写2^n 枚举每一种填充方式，然后再检测的方法…然而这道题这么做只有10分啊$qaq….$ 然后赛后题解告诉我：这题TM是个欧拉回路！！！！当时我就懵逼了….然后当dalao们给我把这道题讲明白了之后，我才发现这道题思路的奇妙。 首先，我们发现，对于一个点，它对应着一个横坐标和一个纵坐标。蒽….一个点对应着两个数值，这个时候我们应该想到什么？二分图？对了，这东西还真的就是要你用二分图的思想来建图….(心态崩了我要妹子$QAQ$) 我们建图，然后我们发现，因为一个点对应着一个横坐标和一个纵坐标，那么我们想到：在二分图中，每一条边也是对应着两种点。那么受到这样的启发，我们就可以建图了：我们把横坐标和纵坐标分别看成一种点，然后将题目中给你的点看成这张图上的边，那么因为题目中要求：黑点和白点的绝对值差不大于1…..，那么我们能想到什么呢？我们要对这些边进行黑白染色，所以我们要一个点出发，一直走一条欧拉回路，这样能走遍所有的边。 但是这样做，我们会发现一个问题：只有$subtask4$的$30$分数据告诉你是偶数。而存在欧拉回路的图的特点是什么呢？每个点的度数都是偶数，那么当点的度数是奇数的时候，我们怎么办呢？ 我在这里选择了度数为奇数的点向一个虚拟节点连边，然后当所有点的度数都是偶数时，这时候没有其他点向这个点连边所以这时候这个虚拟节点对答案没有影响。 然后，我们就直接对边进行染色就可以了。 我只想说，这道题出的真的好，佩服出题人。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt; const int N = 5e5 + 10; struct Data &#123; int v; int p;&#125;data[N];struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int n , m , t = 1 , num;int head[N] , d[N];int x[N] , y[N] , ans[N];bool flag[N]; inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline bool cmp ( Data x , Data y ) &#123; return x.v&lt;y.v;&#125;void lisanhua () &#123; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = x[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; x[data[i].p] = num; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; data[i].v = y[i]; data[i].p = i; &#125; std :: sort ( data + 1 , data + 1 + n , cmp ); data[0].v = -1; for ( int i = 1 ; i &lt;= n ; i++ ) &#123; if ( data[i].v != data[i - 1].v ) num++; y[data[i].p] = num; &#125; return;&#125;void dfs ( int cur , bool last ) &#123; for ( int i = head[cur] ; i ; i = e[i].next ) &#123; if ( flag[i &gt;&gt; 1] ) continue; int j = e[i].to; flag[i &gt;&gt; 1] = 1; d[cur]--; d[j]--; ans[i &gt;&gt; 1] = !last; dfs ( j , !last ); &#125; return;&#125; int main ( void ) &#123; n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; x[i] = read (); y[i] = read (); &#125; lisanhua(); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; d[x[i]]++; d[y[i]]++; add ( x[i] , y[i] ); add ( y[i] , x[i] ); &#125; for ( int i = 1 ; i &lt;= num ; i++ ) if ( d[i] &amp; 1 ) &#123; d[i]++; d[num + 1]++; add ( i , num + 1 ); add ( num + 1 , i ); &#125; num++; memset ( ans , -1 , sizeof ( ans ) ); for ( int i = 1 ; i &lt;= num ; i++ ) while ( d[i] ) dfs ( i , 1 ); for ( int i = 1 ; i &lt;= n ; i++ ) printf ( "%d%c" , ans[i] , i == n ? '\n' : ' ' ); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复赛冲刺Day1R1-Count题解]]></title>
    <url>%2F2018%2F11%2F01%2FqbxtD1T1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[其实我感觉这道数论题还是挺简单的（虽然我不会） 这道数论题，我初看的时候是挺一脸懵逼的，然后据$wucstdio$大爷提供的思路，我们可以发现：题意求的是$x$,$y$在$mod P$下的逆元，存在解的条件是$gcd(x,p)==1$，即x,p互质。所以由题解有设 1 到 P − 1 中与 P 互质的数有 s 个，考虑这 s 个数与它们的逆元组成的二元组，这些二元组一定符合条件，那么只要考虑去重的问题 所以我们只需要知道从$1$到$n$中和$n$互质的数的个数这个东西是什么呢？这个东西很明显是$phi$函数。所以我们只需要求出$\phi(p)$，再加上$x^2\equiv1\pmod{p}$的数，最后除$2$就好了。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e7 + 10;int n;int tot , prime[N] , phi[N];bool flag[N];int main ( void ) &#123; scanf ( "%d" , &amp;n ); flag[1] = 1; phi[1] = 1; for ( int i = 2 ; i &lt;= n ; i++ ) &#123; if ( !flag[i] ) &#123; prime[++tot] = i; phi[i] = i - 1; &#125; for ( int j = 1 ; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n ; j++ ) &#123; flag[i * prime[j]] = 1; if ( i % prime[j] == 0 ) &#123; phi[i * prime[j]] = phi[i] *prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; long long ans = phi[n]; for ( long long i = 1 ; i &lt;= n ; i++ ) if ( i * i % n == 1 ) ans++; printf ( "%lld\n" , ( long long ) ( ans ) / 2 ); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A*学习笔记]]></title>
    <url>%2F2018%2F10%2F19%2FA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[例题：$LuoguP2324$:骑士精神 $A*$嘛，很早时候就听说过，貌似是一种很神奇的算法。听长者讲过一遍，一直都想自己打一遍。但是一直没机会。所以来自己写一遍就好啦。 $A*$的重点就是一个叫做估价函数的东西，但是这个叫估价函数的东西你必须要好好写，不然你会搜出来$WA$的好成绩对于这道题，我就是将现在的棋盘和目标棋盘不同棋子数的差当作估价函数（其实是正确的)。然后，我们就可以加一个类似于剪枝的东西：如果现在的步数$+$估价函数估计的值$&gt;$现在的$max$，直接$return$就好。剩下的东西就是个大爆搜了， 以下是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int goal[7][7] = &#123; &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;, &#123; 0 , 1 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 1 , 1 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 2 , 1 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 1 &#125;, &#123; 0 , 0 , 0 , 0 , 0 , 0 &#125;&#125;;char mp[6][6];int now[6][6];bool flag;int dx[] = &#123; 0 , 1 , 1 , -1 , -1 , 2 , 2 , -2 , -2 &#125;;int dy[] = &#123; 0 , 2 , -2 , 2 , -2 , 1 , -1 , 1 , -1 &#125;;inline int calcu () &#123; int tmp = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) &#123; if ( now[i][j] != goal[i][j] ) tmp++; &#125; return tmp;&#125;inline void swap ( int &amp;x , int &amp;y ) &#123; int t = x; x = y; y = t; return;&#125;void A_Star ( int x , int y , int dep , int MaxStep ) &#123; if ( flag ) return; if ( dep == MaxStep ) &#123; if ( calcu () == 0 ) &#123; flag = 1; printf ( "%d\n" , MaxStep ); return; &#125; return; &#125; for ( int i = 1 ; i &lt;= 8 ; i++ ) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if ( xx &gt; 5 || xx &lt; 1 || yy &gt; 5 || yy &lt; 1 ) continue; swap ( now[x][y] , now[xx][yy] ); if ( calcu () + dep &lt;= MaxStep ) A_Star ( xx , yy , dep + 1 , MaxStep ); swap ( now[x][y] , now[xx][yy] ); &#125; return;&#125;int main ( void ) &#123; int ttt; scanf ( "%d" , &amp;ttt ); while ( ttt-- ) &#123; flag = 0; for ( int i = 1 ; i &lt;= 5 ; i++ ) scanf ( "%s" , mp[i] + 1 ); int st_x , st_y; for ( int i = 1 ; i &lt;= 5 ; i++ ) for ( int j = 1 ; j &lt;= 5 ; j++ ) if ( mp[i][j] == '*' ) &#123; st_x = i; st_y = j; now[i][j] = 2; &#125; else now[i][j] = mp[i][j] - '0'; if ( calcu () == 0 ) &#123; puts ( "0" ); return 0; &#125; for ( int i = 1 ; i &lt;= 15 ; i++ ) if ( !flag ) A_Star ( st_x , st_y , 0 , i ); if ( !flag ) puts ( "-1" ); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wucstdio的毒瘤模拟赛]]></title>
    <url>%2F2018%2F10%2F18%2Fwucstdio%E7%9A%84%E6%AF%92%E7%98%A4%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[$wucstdio$大爷的Flag还是没有倒…. T1: 反正我刚开始对这道题是完全没有什么信心的qaq（才不会告诉你我直接去看的$T2$） 考虑$50$分的情况：一条链。所以就是一个等差数列了qwq 考虑剩余的正解，我们可以把每一步的期望值当成这棵树的权值，然后因为从上向下和从下向上的期望值可能不太一样，所以我们需要两个函数来表示：（相当于两条边）。 我们设$f(x) g(x)$分别表示从下向上和从上向下的情况，所以我们考虑求出$f(x)$时，我们要考虑以下情况： 直接走到这个节点的父节点，所以这种情况下，对这个节点对答案的贡献就是$\frac {1}{d[x]}了$ 还有一种情况就是这个节点先跳到他的儿子，再跳回这个节点，再跳过去。这个时候，因为我们需要一步来跳过去，所以这种情况对答案的贡献就是:$\sum_{j=son} \frac {1}{d[x]}[1 + f(x) + f(j) ]$ 我们综合考虑一下这两种情况对答案的贡献值，将这两个式子加起来，我们就会得到下边的这个式子： f(x) = \frac{1}{d} + \sum_{j=son}\frac{1}{d}\times[1 +f(x) + f ( j )]我们安置我们做期望的一贯思路（好像我做过多少期望一样QwQ），因为$num[son]=p-1$，所以我们可以得到这样一个式子： d\times f(x)=1+d-1+(d-1)f(x)+\sum_{j}f(j)化简一下之后有： f(x)=d+\sum_{j}f(j)然后我们来考虑一下$g(x)$这个东西怎么求，当我们经过观察之后，我们可以发现这个式子有三种情况： 他的父亲直接跳到他这里，这种情况对答案的贡献就是$\frac{1}{d[father]}$ 他的父亲先跳到他的爷爷，然后再跳回来，这种情况下，对答案的贡献就是：$\frac{1}{d[father]}\times (1 + g(p) +g(x) )$ 他的父亲跳到他的兄弟然后再跳到他自己。 我们把这三种情况加起来，就会有： g(x)=\dfrac {1}{d[father]} \times(1+g(p)+g(x))+\dfrac {1}{d[father]}+\sum_{pa_j=pa_x\&\&j\not=x}\dfrac {1}{d[father]} (1+f(j)+g(x))继续化简有： g(x)=g(p)+f(p)-f(x)通过这种方式，我们就可以把$g(x) f(x)$算出来，相当于边长。 算出边长后，这个问题就转化成了：给你一颗树，求树的直径。我选择了DP求直径，就很简单了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;const int N = 2e5 + 10;int n , m , t;struct Edge &#123; int to; int next;&#125;e[N &lt;&lt; 1];int head[N];int now_ans;int f[N] , g[N] , p[N];int LongDis[N][2] , SecondDis[N][2];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125; inline void add ( int x , int y ) &#123; e[++t].to = y; e[t].next = head[x]; head[x] = t; return;&#125;inline int min ( int x , int y ) &#123; return x &lt; y ? x : y;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;void Find_f ( int root , int fa ) &#123; f[root] = p[root]; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Find_f ( j , root ); f[root] += f[j]; &#125; return;&#125;void Find_g ( int root , int fa ) &#123; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; g[j] = f[root] + g[root] - f[j]; Find_g ( j , root ); &#125; return;&#125;void Work ( int root , int fa ) &#123; int Frist = 0 , Second = 0; for ( int i = head[root] ; i ; i = e[i].next ) &#123; int j = e[i].to; if ( j == fa ) continue; Work ( j , root ); if ( LongDis[j][0] + g[j] &gt; LongDis[root][0] ) &#123; SecondDis[root][0] = LongDis[root][0]; LongDis[root][0] = LongDis[j][0] + g[j]; Frist = j; &#125; else if ( LongDis[j][0] + g[j] &gt; SecondDis[root][0] ) SecondDis[root][0] = LongDis[j][0] + g[j]; if ( LongDis[j][1] + f[j] &gt; LongDis[root][1] ) &#123; SecondDis[root][1] = LongDis[root][1]; LongDis[root][1] = LongDis[j][1] + f[j]; Second = j; &#125; else if ( LongDis[j][1] + f[j] &gt; SecondDis[root][1] ) SecondDis[root][1] = LongDis[j][1] + f[j]; &#125; if ( Frist != Second ) now_ans = max ( LongDis[root][0] + LongDis[root][1] , now_ans ); else if ( Frist == Second ) now_ans = max ( now_ans , max ( SecondDis[root][1] + LongDis[root][0] , SecondDis[root][0] + LongDis[root][1] ) ); return;&#125;int main ( void ) &#123; freopen ( "tree.in" , "r" , stdin ); freopen ( "tree.out" , "w" , stdout ); n = read (); for ( int i = 1 ; i &lt; n ; i++ ) &#123; int x = read () , y = read (); add ( x , y ); add ( y , x ); p[x]++; p[y]++; &#125; Find_f ( 1 , 0 ); Find_g ( 1 , 0 ); Work ( 1 , 0 ); printf ( "%d.00000\n" , now_ans ); return 0;&#125; T2:其实暴力还是挺显然的]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前排打出题人的一套题]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%89%8D%E6%8E%92%E6%89%93%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E4%B8%80%E5%A5%97%E9%A2%98%2F</url>
    <content type="text"><![CDATA[不管怎么样，先打死出题人再说qaq… T1:人贩子$LLFZ$ 题意很显然就是最优贸易啊…. 一眼看出来是缩点+DP….但是为什么我之前是SPFA过的啊QAQ…写SPFA比较稳….然后….就写了…. 上代码吧…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int N = 1e5 + 10;const int M = 1e6 + 10;const int INF = 2147483647;#define G(i,a,b,c) for ( int i = b[a] ; i ; i = c[i].next )int n , m , t , cnt;struct Edge &#123; int to; int data; int next;&#125;e[M] , e_[M];int head[N] , head_[N];int maxs[N] , mins[N];int dis[N] , value[N];bool inque[N];std :: queue &lt; int &gt; qu;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline void add ( int x , int y , int z ) &#123; e[++t].to = y; e[t].data = z; e[t].next = head[x]; head[x] = t; return;&#125;inline void add_ ( int x , int y , int z ) &#123; e_[++cnt].to = y; e_[cnt].data = z; e_[cnt].next = head_[x]; head_[x] = cnt; return;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123; return x &lt; y ? x : y;&#125;template &lt; class T &gt;inline T max ( T x , T y ) &#123; return x &gt; y ? x : y;&#125;void Heap_Dijkstra () &#123; std :: memset ( dis , 0x3f3f3f3f , sizeof ( dis ) ); inque[1] = 1 , dis[1] = value[1]; qu.push ( 1 ); while ( !qu.empty () ) &#123; int j = qu.front (); inque[j] = 0; qu.pop (); G ( i , j , head , e ) &#123; int k = e[i].to; if ( dis[k] &gt; min ( dis[j] , e[i].data ) ) &#123; dis[k] = min ( dis[j] , e[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) mins[i] = dis[i]; std :: memset ( dis , -0x3f3f3f3f , sizeof ( dis ) ); inque[n] = 1 , dis[n] = value[n]; qu.push ( n ); while ( !qu.empty () ) &#123; int j = qu.front (); qu.pop (); inque[j] = 0; G ( i , j , head_ , e_ ) &#123; int k = e_[i].to; if ( dis[k] &lt; max ( dis[j] , e_[i].data ) ) &#123; dis[k] = max ( dis[j] , e_[i].data ); if ( !inque[k] ) &#123; inque[k] = 1; qu.push ( k ); &#125; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) maxs[i] = dis[i]; return;&#125; int main ( void ) &#123; freopen ( "child.in" , "r" , stdin ); freopen ( "child.out" , "w" , stdout ); n = read (); m = read (); for ( int i = 1 ; i &lt;= n ; i++ ) value[i] = read (); for ( int i = 1 ; i &lt;= m ; i++ ) &#123; int x = read () , y = read () , z = read (); if ( z == 1 ) &#123; add ( x , y , value[y] ); add_ ( y , x , value[x] ); &#125; else if ( z == 2 ) &#123; add ( x , y , value[y] ); add ( y , x , value[x] ); add_ ( y , x , value[x] ); add_ ( x , y , value[y] ); &#125; &#125; Heap_Dijkstra (); int ans = -INF; for ( int i = 1 ; i &lt;= n ; i++ ) ans = max ( ans , maxs[i] - mins[i] ); printf ( "%d\n" , ans ); return 0;&#125; T2 : food 再来拿出题人祭天祭一波… 话说我直接读题读错了然后写了个错误的DP然后还A了是什么鬼啊…. 话说我考虑了前缀和，那么我还过了，说明直接加起来然后除就可以? 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int N = 15;int n , ans = -1;int A , B , C;int p1 , p2 , p3;int MaxTime[N];int f[N][105][105][105];inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;inline int max ( int x , int y ) &#123; return x &gt; y ? x : y;&#125;int main ( void ) &#123; freopen ( "food.in" , "r" , stdin ); freopen ( "food.out" , "w" , stdout ); A = read () , B = read () , C = read (); p1 = read () , p2 = read () , p3 = read (); n = read (); for ( int i = 1 ; i &lt;= n ; i++ ) &#123; MaxTime[i] = read (); MaxTime[i] = MaxTime[i - 1] + MaxTime[i]; &#125; for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = A ; j * p1 &lt;= MaxTime[i] &amp;&amp; j&lt;=100 ; j++ ) for ( int k = B; j * p1 + k * p2 &lt;= MaxTime[i] &amp;&amp; k &lt;= 100 ; k++ ) for ( int l = C ; j * p1 + k * p2 + l * p3 &lt;= MaxTime[i] &amp;&amp; l &lt;=100 ; l++ ) &#123; f[i][j][k][l] = max ( f[i][j][k][l] , max ( f[i - 1][j - A][k - B][l - C] + 1 , f[i][j - A][k - B][l - C] + 1 ) ); ans = max ( ans , f[i][j][k][l] ); &#125; printf ( "%d\n" , ans ); return 0;&#125; T3: Happy 再吐槽一波为什么Noip模拟赛会考离散对数（然而我并不会….） 其实应该是一道签到题吧。。。 暴力水过…. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;inline int read () &#123; int s = 0 , w = 1; char ch = getchar (); while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125; while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125; return s * w;&#125;int P , A , B;bool app[50005];int main ( void ) &#123; freopen ( "happy.in" , "r" , stdin ); freopen ( "happy.out" , "w" , stdout ); int T = read (); while ( T-- ) &#123; int now = 1; memset ( app , false , sizeof ( app ) ); P = read () , A = read () , B = read (); for ( int i = 1 ; ; i++ ) &#123; now = ( now * A ) % P; if ( now == B ) &#123; printf ( "%d\n" , i ); break; &#125; if ( app[now] ) &#123; puts ( "Couldn't Produce!" ); break; &#125; app[now] = 1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My_Code_Style]]></title>
    <url>%2F2018%2F10%2F13%2FMy_Code_Style%2F</url>
    <content type="text"><![CDATA[介绍下本蒟蒻的丑死的码风$qwq$…(码风大概是魔改了神犇$Menci$的) 在打CF时并不是这个码风 码风概述： 所有的#include后必须有一个空格,例如#include 无论什么样子的程序，都必须写cstdio cstring algorithm iostream这四个头文件。 在主程序的int main()中要加$void$，即为int main(void) 一般不写using namespace std; 所有的变量必须定义在第一个自定义函数之前，且变量和第一个自定义函数，最后一个自定义函数和$main$之间必须有一个换行 每个函数之后尽可能有$return$， 在一般情况下，在花括号内的内容不加逗号 缩进： 对于每个代码块，使用4空格或者等长的Tab缩进。 括号： 大括号不换行 空格： 个人感觉自己的空格比较的毒瘤。 1.在每个函数声明时，函数名后的括号与函数名之间必须有一个空格,而且括号内如果需要声明变量，则要先有一个空格，且逗号的前后都必须有一个空格。 2.在for循环的声明中，每一个字符（变量名除外），都要用空格隔开。 3.数组内一般不加空格，但是如果有运算符则运算符前后必须有空格。 4.每个可以前后匹配的括号前后必须有空格。 变量： 1.基本所有变量都是全局变量，但有些ans,sum最后统计答案时使用的变量可以定义为局部变量。 2.所有的变量名称都必须与要存储的东西的中文意思有沾边，比如树直接定义为tree而不是T。（极度不能容忍变量名直接为a,b,c,d,e,f,g,的情况。 3.定义N,M等时一般只用N,M为名称而不是MAXN,MAXM. 4.定义的结构体类型在定义变量时必须紧接着声明完成结构体后，并且结构体中变量需要定义一个加一个换行。 5.在变量命名时较长的变量名可以用_来连接，并且大小写交替使用，如Add_Tree_Val 把上边所有毒瘤的码风结合起来之后代码大概长这个样子qwq.. update:还是加上模板舒服qwq 不要吐槽我的丑逼$Splay…..$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#define ll long long#define pll std::pair&lt;int,int&gt;#define mp std::make_pair#define fi first#define se second#define oo 2147483647#define PI 3.141592653590#define rint register inttemplate &lt; class T &gt; inline void read ( T &amp;x ) &#123;T s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;x = s * w;return;&#125;template &lt; class T , typename ...Argc &gt; inline void read ( T &amp;x , Argc &amp;...Args ) &#123;read ( x );read ( Args... );return;&#125; template &lt; class T &gt; inline T max ( T x , T y ) &#123;return x &gt; y ? x : y;&#125;template &lt; class T &gt; inline T min ( T x , T y ) &#123;return x &lt; y ? x : y;&#125;template &lt; class T &gt; inline void abs ( T x ) &#123;return x &gt; 0 ? x : -x;&#125;inline int _read () &#123;int s = 0 , w = 1;char ch = getchar ();while ( ch &gt; '9' || ch &lt; '0' ) &#123; if ( ch == '-' ) w = -1; ch = getchar ();&#125;while ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) &#123; s = s * 10 + ch - '0'; ch = getchar ();&#125;return s * w;&#125;template &lt;typename T&gt; void write(T x) &#123;if (x &lt; 0) x = -x, putchar('-');if (x &gt; 9) write(x / 10);putchar(x % 10 + 48);return;&#125;template &lt;typename T&gt; void writeln(T x) &#123; write(x); printf ("\n"); &#125;/**********************************************************************************************************************************************************************************************************************************************************************/const int N = 1e6 + 5;int root , tot , n;struct Tree &#123; int ch[2]; int val; int father; int size; int cnt;&#125;tree[N];void pushup ( int cur ) &#123; tree[cur].size = tree[tree[cur].ch[0]].size + tree[tree[cur].ch[1]].size + tree[cur].cnt; return;&#125;void rotate ( int x ) &#123; int y = tree[x].father; int z = tree[y].father; int k = tree[y].ch[1] == x; tree[z].ch[tree[z].ch[1] == y] = x; tree[x].father = z; tree[y].ch[k] = tree[x].ch[k ^ 1]; tree[tree[x].ch[k ^1]].father = y; tree[x].ch[k ^ 1] = y; tree[y].father = x; pushup ( x ); pushup ( y ); return;&#125;void Splay ( int x , int goal ) &#123; while ( tree[x].father != goal ) &#123; int y = tree[x].father; int z = tree[y].father; if ( z != goal ) ( tree[y].ch[0] == x ) ^ ( tree[z].ch[0] == y ) ? rotate ( x ) : rotate ( y ); rotate ( x ); &#125; if ( goal == 0 ) root = x; return;&#125;void insert ( int x ) &#123; int cur = root , father = 0; while ( cur &amp;&amp; tree[cur].val != x ) &#123; father = cur; cur = tree[cur].ch[x &gt; tree[cur].val]; &#125; if ( cur ) tree[cur].cnt++; else &#123; cur = ++tot; if ( father ) tree[father].ch[x &gt; tree[father].val] = cur; tree[cur].ch[0] = tree[cur].ch[1] = 0; tree[cur].father = father; tree[cur].val = x; tree[cur].cnt = 1; tree[cur].size = 1; &#125; Splay ( cur , 0 ); return;&#125;void Find ( int x ) &#123; int cur = root; if ( !cur ) return; while ( tree[cur].ch[x &gt; tree[cur].val] &amp;&amp; x != tree[cur].val ) cur = tree[cur].ch[ x &gt; tree[cur].val]; Splay ( cur , 0 ); return;&#125;int Next ( int x , int f )&#123; Find ( x ); int cur = root; if ( tree[cur].val &gt; x &amp;&amp; f ) return cur; if ( tree[cur].val &lt; x &amp;&amp; !f ) return cur; cur = tree[cur].ch[f]; while ( tree[cur].ch[f ^ 1] ) cur = tree[cur].ch [f ^ 1]; return cur;&#125;void Delete ( int x ) &#123; int last = Next ( x , 0 ); int next = Next ( x , 1 ); Splay ( last , 0 ); Splay ( next , last ); int del = tree[next].ch[0]; if ( tree[del].cnt &gt; 1 ) &#123; tree[del].cnt--; Splay ( del , 0 ); &#125; else tree[next].ch[0] = 0; return;&#125;int kth ( int x ) &#123; int cur = root; if ( tree[cur].size &lt; x ) return 0; while ( 1 ) &#123; int y = tree[cur].ch[0]; if ( x &gt; tree[y].size + tree[cur].cnt ) &#123; x -= tree[y].size + tree[cur].cnt; cur = tree[cur].ch[1]; &#125; else if ( tree[y].size &gt;= x ) cur = y; else return tree[cur].val; &#125;&#125;int main ( void ) &#123; n = read (); insert ( 2147483647 ); insert ( -2147483647 ); while ( n-- ) &#123; int opt = read (); if ( opt == 1 ) &#123; int x = read (); insert ( x ); &#125; else if ( opt == 2 ) &#123; int x = read (); Delete ( x ); &#125; else if ( opt == 3 ) &#123; int x = read (); Find ( x ); printf ( "%d\n" , tree[tree[root].ch[0]].size ); &#125; else if ( opt == 4 ) &#123; int x = read (); printf ( "%d\n" , kth ( x + 1 ) ); &#125; else if ( opt == 5 ) &#123; int x = read (); printf ( "%d\n" , tree[Next ( x , 0 )].val ); &#125; else if ( opt == 6 ) &#123; int x = read (); printf ( "%d\n" , tree[Next ( x , 1 )].val ); &#125; &#125; return 0;&#125; 因为知道了自己是多么的菜,所以才要更加努力去追求那个永远也不可能实现的梦想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CodeStyle</tag>
      </tags>
  </entry>
</search>
